{
    "nl_description": "Extend all objects of size 1 to the maximum size without overlapping.",
    "code": "(do\n    (rule\n        (vars (this x))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (extend_node (direction_of x) false)\n        )\n    )\n)"
}

{
    "nl_description": "Recolor all objects of color R to color B.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) R)\n        )\n        (apply\n            (update_color B)\n        )\n    )\n)"
}

{
    "nl_description": "Extend all the objects toward the right edge of the grid without overlapping.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (extend_node right true)\n        )\n    )\n)"
}

{
    "nl_description": "Move all red objects one step up.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) R)\n        )\n        (apply\n            (move_node up)\n        )\n    )\n)"
}

{
    "nl_description": "Move all the objects of color R to the right, and convert the object at X to color F.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) R)\n        )\n        (apply\n            (move_node right)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) X)\n        )\n        (apply\n            (update_color F)\n        )\n    )\n)"
}

{
    "nl_description": "Extend all objects in the image that are touching the outer border of the grid, without overlapping.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (or\n                (column_equals (column_of this) center)\n                (color_equals (color_of this) X)\n            )\n        )\n        (apply\n            (extend_node (direction_of this) false)\n        )\n    )\n)"
}

{
    "nl_description": "Recolor all objects of color R to color B.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) R)\n        )\n        (apply\n            (update_color B)\n        )\n    )\n)"
}

{
    "nl_description": "Rotate all objects clockwise by 90 degrees",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (rotate_node 90)\n        )\n    )\n)"
}

{
    "nl_description": "Extend all the green objects while leaving a trail, until they hit a blue object.",
    "code": "(do\n    (rule\n        (vars (this x))\n        (filter\n            (color_equals (color_of this) G)\n        )\n        (apply\n            (extend_node (direction_of x) false)\n        )\n    )\n)"
}

{
    "nl_description": "Move all objects to the right, if they share the row with an object of color X, and then color them in the order of RGB.",
    "code": "(do\n    (rule\n        (vars (this x))\n        (filter\n            (neighbor_of this x)\n        )\n        (apply\n            (move_node right)\n            (update_color\n                (color_of x)\n            )\n        )\n    )\n)"
}

{
    "nl_description": "Move all blue objects one step up, and then color them in red.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) B)\n        )\n        (apply\n            (move_node up)\n            (update_color R)\n        )\n    )\n)"
}

{
    "nl_description": "Rotate all objects that have a height of 2 by 90 degrees clockwise.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (height_equals (height_of this) 2)\n        )\n        (apply\n            (rotate_node 90)\n        )\n    )\n)"
}

{
    "nl_description": "Move all blue objects one step down, then rotate them by 90 degrees clockwise.",
    "code": "(do\n   (rule\n       (vars (this))\n       (filter\n           (color_equals (color_of this) B)\n       )\n       (apply\n           (move_node down)\n           (rotate_node 90)\n       )\n   )\n)"
}

{
    "nl_description": "Extend all squares in the grid until they hit another object, then mirror them horizontally.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (shape_equals (shape_of this) square)\n        )\n        (apply\n            (extend_node (direction_of this) false)\n            (mirror horizontal)\n        )\n    )\n)"
}

{
    "nl_description": "Recolor all blue objects to red if they are neighbors of an object with color X.",
    "code": "(do\n    (rule\n        (vars (this x))\n        (filter\n            (and\n                (color_equals (color_of this) B)\n                (and\n                    (neighbor_of this x)\n                    (color_equals (color_of x) X)\n                )\n            )\n        )\n        (apply\n            (update_color R)\n        )\n    )\n)"
}

{
    "nl_description": "Move all objects to the right to the maximum extent.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (move_node_max right)\n        )\n    )\n)"
}

{
    "nl_description": "Move all cyan-colored objects to the bottom of the grid and then flip them vertically.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) C)\n        )\n        (apply\n            (move_node_max down)\n            (flip vertical)\n        )\n    )\n)"
}

{
    "nl_description": "Rotate all objects in the grid 90 degrees clockwise.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (rotate_node 90)\n        )\n    )\n)"
}

{
    "nl_description": "Move objects of color R one step up, objects of color B one step right, and objects of color G one step left.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) R)\n        )\n        (apply\n            (move_node up)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) B)\n        )\n        (apply\n            (move_node right)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) G)\n        )\n        (apply\n            (move_node left)\n        )\n    )\n)"
}

{
    "nl_description": "Recolor all objects different than the horizontal and vertical neighbors of X to the color of X, then fill the rectangle of size max surrounding X with color O.",
    "code": "(do\n    (rule\n        (vars (this x))\n        (filter\n            (and\n                (not (color_equals (color_of this) X))\n                (or\n                    (neighbor_of this x)\n                    (and\n                        (color_equals (color_of x) X)\n                        (or\n                            (neighbor_of this x)\n                            (neighbor_of x this)\n                        )\n                    )\n                )\n            )\n        )\n        (apply\n            (update_color (color_of x))\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (and\n                (or\n                    (neighbor_of this x)\n                    (and\n                        (color_equals (color_of x) X)\n                        (or\n                            (neighbor_of this x)\n                            (neighbor_of x this)\n                        )\n                    )\n                )\n                (size_equals (size_of this) max)\n            )\n        )\n        (apply\n            (fill_rectangle O false)\n        )\n    )\n)"
}

{
    "nl_description": "Extend all objects towards the object of maximum size, without overlapping.",
    "code": "(do\n    (rule\n        (vars (this x))\n        (filter\n            (neighbor_of this x)\n        )\n        (apply\n            (extend_node (direction_of x) false)\n        )\n    )\n)"
}

{
    "nl_description": "Move all objects of color R one step to the right.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) R)\n        )\n        (apply\n            (move_node right)\n        )\n    )\n)"
}

{
    "nl_description": "Extend all objects of size 1 toward the object of maximum size, without overlapping.",
    "code": "(do\n    (rule\n        (vars (this x))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this x)\n                    (size_equals (size_of x) max)\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of x) false)\n        )    \n    )\n)"
}

{
    "nl_description": "Move all red objects one step down and to the right, and then change them to blue.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) R)\n        )\n        (apply\n            (move_node down_right)\n            (update_color B)\n        )\n    )\n)"
}

{
    "nl_description": "Mirror the objects with respect to the vertical axis.",
    "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (mirror this)\n        )\n    )\n)"
}

{
    "nl_description": "Move all green objects towards blue objects if they are neighbors, without overlapping.",
    "code": "(do\n    (rule\n        (vars (this x))\n        (filter\n            (and\n                (color_equals (color_of this) G)\n                (and\n                    (neighbor_of this x)\n                    (color_equals (color_of x) B)\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of x))\n        )    \n    )\n)"
}

{
    "nl_description": "Move all green and blue objects towards red objects.",
    "code": "(do\n    (rule\n        (vars (this x))\n        (filter\n            (or\n                (color_equals (color_of this) G)\n                (color_equals (color_of this) B)\n            )\n        )\n        (apply\n            (move_node_max (direction_of x))\n        )\n    )\n)"
}