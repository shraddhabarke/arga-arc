{
    "model": "gpt-4o-2024-05-13",
    "usage": {
        "completion_tokens": 12424,
        "prompt_tokens": 6514,
        "total_tokens": 18938,
        "prompt_tokens_details": {
            "cached_tokens": 0
        },
        "completion_tokens_details": {
            "reasoning_tokens": 0
        }
    },
    "request_time": 13.955678939819336,
    "n_requested": 100,
    "prompt_messages": [
        {
            "role": "system",
            "content": "You are an assistant chatbot with human-like perception, reasoning and learning capabilities.\nYou can solve tasks concisely, efficiently, and moreover, correctly.\nLet's engage in perception- and logic-based tasks.\nYou only output source code.\nNo explanations or any other text.\nOnly code."
        },
        {
            "role": "user",
            "content": "You are an efficient assistant for logical reasoning and code generation.\nYou will help me solve a visual perception and reasoning task.\nI will first provide you with the definition of a Domain Specific Language you will use for writing a solution for the task.\nI will then present you with the description of the task that you will be tested in.\nYou will then respond the queries I make regarding the solution of the task.\n\n\nThis is the definition of the DSL you will use to solve the task.\nIt is given as a context-free grammar in the EBNF format used by the Lark parser generator, with some informative comments about the semantics.\nYou will return a string that is parseable by the `program` non-terminal of the grammar.\n\n```\nlibrary: \"(\" program* \")\"\n\n// Rules are executed one after another, in the order they appear.\n// There could be no rules, in which case the program does nothing.\nprogram: \"(\" \"do\" rule* \")\"\n\n// First, it declares the variables that will be used in the filter and transform expressions.\n// Second, it defines a filter expression that an object must satisfy in order to be transformed.\n// Then, it defines a list of transforms that will be applied objects that satisfy the filter expression.\nrule: \"(\" \"rule\" decl filter xform_list \")\"\n\n// The `vars` declaration specifies the names of the variables that will be used in the filter and transform expressions.\n// The `this` variable is always declared, and it refers to the object that is being transformed.\n// There could also be an additional optional variable `other` that refers to another object in the grid,\n// which is not being transformed, but is used in the filter expression.\ndecl: \"(\" \"vars\" \"(\" VAR_THIS VAR_OTHER? \")\" \")\"\n\n// A filter is a predicate over the objects in the grid.\n// If no filter is given, then all the objects are selected.\nfilter: \"(\" \"filter\" filter_expr? \")\"\n\n// It can be a primitive filter operation, or a boolean expression using the `and`, `or`, and `not` connectives.\n// IMPORTANT: The `and` and `or` connectives are strictly binary, so to take the conjunction or disjunction \n// of more than two expressions, the binary connectives must be nested.\n// AGAIN, the `and` and `or` connectives are not variadic, so the following is not allowed:\n// (and true true false)\n// Instead, the following must be used:\n// (and true (and true false))\n// The `not` connective is unary as expected.\n// The objects that are transformed are the ones that satisfy the filter expression.\nfilter_expr: filter_prim\n           | \"(\" OP_AND filter_expr filter_expr \")\"   \n           | \"(\" OP_OR filter_expr filter_expr \")\"\n           | \"(\" OP_NOT filter_expr \")\"\n\nfilter_prim: \"(\" COLOR_EQ fcolor_expr fcolor_expr \")\"           \n           | \"(\" SIZE_EQ size_expr size_expr \")\"                \n           | \"(\" HEIGHT_EQ height_expr height_expr \")\"          \n           | \"(\" WIDTH_EQ width_expr width_expr \")\"             \n           | \"(\" DEGREE_EQ degree_expr degree_expr \")\"          \n           | \"(\" SHAPE_EQ shape_expr shape_expr \")\"             \n           | \"(\" COLUMN_EQ column_expr column_expr \")\"         \n           | \"(\" NEIGHBOR_OF VAR VAR \")\"      // true if the two objects are neighbors\n\n\n// Transforms are applied one after another, in the order they appear.\nxform_list: \"(\" \"apply\" xform+ \")\"\n\n// A single transform is applied to all the objects that are bound to the `this` variable. \n// The transform is applied to each such object independently and simultaneously.\nxform:     \"(\" TR_UPDATE_COLOR color_expr \")\"                          // change this object color to the given color \n         | \"(\" TR_MOVE_NODE direction_expr \")\"                         // move this object in the given direction\n         | \"(\" TR_EXTEND_NODE direction_expr OVERLAP \")\"               // extend (move while leaving a trail) this object in the given direction\n                                                                  // if overlap is false, then the object is extended until it hits another object,\n                                                                  // otherwise it is extended until the edge of the grid.\n         | \"(\" TR_MOVE_NODE_MAX direction_expr \")\"                     // move this object until it hits another object, in the given direction\n         | \"(\" TR_ROTATE_NODE ROT_ANGLE \")\"                       // rotate this object by the given angle\n         | \"(\" TR_ADD_BORDER color_expr \")\"                            // color this exterior pixels of the object with the given color\n         | \"(\" TR_FILL_RECTANGLE color_expr OVERLAP \")\"                // color this interior of a hollow rectangle with the given color\n         | \"(\" TR_HOLLOW_RECTANGLE color_expr \")\"                      // color this interior of a solid rectangle with the given color\n         | \"(\" TR_MIRROR mirror_expr \")\"\n         | \"(\" TR_FLIP SYMMETRY_AXIS \")\"                          // flip this object with respect to the given axis\n         | \"(\" TR_INSERT OBJECT_ID img_pts_expr RELATIVE_POSITION \")\" // insert a copy of this object at the position of the given object\n         | \"(\" TR_NOOP \")\"                                        // do nothing\n\nfcolor_expr: FCOLOR\n           | \"(\" COLOR_OF VAR \")\"\n\ncolor_expr: COLOR\n          | \"(\" COLOR_OF VAR \")\"\n\nsize_expr: SIZE\n         | \"(\" SIZE_OF VAR \")\"\n\nheight_expr: HEIGHT\n           | \"(\" HEIGHT_OF VAR \")\"\n\nwidth_expr: WIDTH\n          | \"(\" WIDTH_OF VAR \")\"\n\ndegree_expr: DEGREE\n           | \"(\" DEGREE_OF VAR \")\" \n\nshape_expr: SHAPE\n          | \"(\" SHAPE_OF VAR \")\"\n\ncolumn_expr: COLUMN\n           | \"(\" COLUMN_OF VAR \")\"\n\ndirection_expr: DIRECTION\n              | \"(\" DIRECTION_OF VAR \")\"\n\nimg_pts_expr: IMAGE_POINTS\n            | \"(\" IMAGE_POINTS_OF VAR \")\"\n\nmirror_expr: \"(\" MIRROR_AXIS_OF VAR \")\"\n\nOBJECT_ID: /[0-9]+/\nFCOLOR: \"O\" // black\n      | \"B\" // blue\n      | \"R\" // red\n      | \"G\" // green\n      | \"Y\" // yellow\n      | \"X\" // grey\n      | \"F\" // fuchsia\n      | \"A\" // orange\n      | \"C\" // cyan  \n      | \"W\" // brown\n\nSIZE: \"min\" | \"max\" | \"even\" | \"odd\" | /[0-9]+/  // size of objects\nDEGREE: \"min\" | \"max\" | \"even\" | \"odd\" | /[0-9]+/  // degree of objects\nHEIGHT: \"min\" | \"max\" | \"even\" | \"odd\" | /[0-9]+/  // height of objects\nWIDTH: \"min\" | \"max\" | \"even\" | \"odd\" | /[0-9]+/  // width of objects\nCOLUMN: \"center\" | \"even\" | \"odd\" | /[0-9]+/  // column of objects\nSHAPE: \"square\" | \"enclosed\"  // shape of objects\n\nDIRECTION: \"up\"\n         | \"down\"\n         | \"left\"\n         | \"right\"\n         | \"up_left\"\n         | \"up_right\"\n         | \"down_left\"\n         | \"down_right\"\n\nSYMMETRY_AXIS: \"vertical\" | \"horizontal\" | \"diagonal_left\" | \"diagonal_right\"\n\n// The angle of clockwise rotation, in degrees.\nROT_ANGLE: \"0\" \n         | \"90\" \n         | \"180\" \n         | \"270\"\n\nCOLOR: \"O\" // black\n      | \"B\" // blue\n      | \"R\" // red\n      | \"G\" // green\n      | \"Y\" // yellow\n      | \"X\" // grey\n      | \"F\" // fuchsia\n      | \"A\" // orange\n      | \"C\" // cyan  \n      | \"W\" // brown\n\nOVERLAP: BOOL\n\nBOOL: \"true\" | \"false\"\n\nIMAGE_POINTS: \"top\" | \"bottom\" | \"left\" | \"right\" | \"top_left\" | \"top_right\" | \"bottom_left\" | \"bottom_right\" \n\nRELATIVE_POSITION: \"source\"\n                 | \"target\"\n                 | \"middle\"\n\nVAR: VAR_THIS | VAR_OTHER\nVAR_THIS: \"this\"\nVAR_OTHER: \"other\"\n\nOP_AND: \"and\"\nOP_OR: \"or\"\nOP_NOT: \"not\"\n\nCOLOR_OF: \"color_of\"\nSIZE_OF: \"size_of\"\nHEIGHT_OF: \"height_of\"\nWIDTH_OF: \"width_of\"\nDEGREE_OF: \"degree_of\"\nSHAPE_OF: \"shape_of\"\nCOLUMN_OF: \"column_of\"\nDIRECTION_OF: \"direction_of\"\nIMAGE_POINTS_OF: \"img_pts_of\"\nMIRROR_AXIS_OF: \"mirror_axis_of\"\n\nCOLOR_EQ: \"color_equals\"\nSIZE_EQ: \"size_equals\"\nDEGREE_EQ: \"degree_equals\"\nHEIGHT_EQ: \"height_equals\"\nWIDTH_EQ: \"width_equals\"\nSHAPE_EQ: \"shape_equals\"\nCOLUMN_EQ: \"column_equals\"\nNEIGHBOR_OF: \"neighbor_of\"\n\nTR_UPDATE_COLOR: \"update_color\"\nTR_MOVE_NODE: \"move_node\"\nTR_EXTEND_NODE: \"extend_node\"\nTR_MOVE_NODE_MAX: \"move_node_max\"\nTR_ROTATE_NODE: \"rotate_node\"\nTR_ADD_BORDER: \"add_border\"\nTR_FILL_RECTANGLE: \"fill_rectangle\"\nTR_HOLLOW_RECTANGLE: \"hollow_rectangle\"\nTR_MIRROR: \"mirror\"\nTR_FLIP: \"flip\"\nTR_INSERT: \"insert\"\nTR_NOOP: \"noop\"\n\nCOMMENT: /\\s*/ \";;\" /[^\\n]/*\n\n%import common.WS\n%import common.LCASE_LETTER\n%import common.INT\n%ignore WS\n%ignore COMMENT\n```\n\n\nNow we continue with the visual perception and reasoning task.\nThe input for the task is a small number of pairs of grids of characters.\nThe value of each of the cells of the grids are the colors defined in the DSL, so we can think of grids as images.\nEach pair of images correspond to an input-output example for an unknown program P.\nFor each pair, the program P is evaluated on the image grid and operates on the objects that appear in it.\nThe output of the program is then the output image.\nThe objects in the images are easy and natural to identify for humans, so there is no need to define them explicitly.\nHowever you are able to abstract them correctly, and the DSL is interpreted with the same correct abstraction.\n\n\nNow I will show you some demonstration tasks along with the output you would be expected to produce for each of them.\n\n## DEMONSTRATION TASK 1\n\n### INPUT\nPAIR 1\nINPUT GRID:\nO O O O O O O O\nO O O O O R O O\nO R O O O R O R\nO R R O O R O O\nO O O O O O O O\nO R R O O O O O\nO R R O R R O O\nO O O O O O O O\nOUTPUT GRID:\nO O O O O O O O\nO O O O O Y O O\nO Y O O O Y O Y\nO Y Y O O Y O O\nO O O O O O O O\nO Y Y O O O O O\nO Y Y O Y Y O O\nO O O O O O O O\n\nPAIR 2\nINPUT GRID:\nO O O O O O O O O O\nO O O O R O O O O O\nO G O O R O O W O O\nO O G O O O W W O O\nO O G O O O O O O O\nO O O O X O O O O O\nO O O O O O F F F O\nO B O O O O O O O O\nO B B B B O O C C O\nO O O O O O O C O O\nOUTPUT GRID:\nO O O O O O O O O O\nO O O O Y O O O O O\nO Y O O Y O O Y O O\nO O Y O O O Y Y O O\nO O Y O O O O O O O\nO O O O Y O O O O O\nO O O O O O Y Y Y O\nO Y O O O O O O O O\nO Y Y Y Y O O Y Y O\nO O O O O O O Y O O\n\n### EXPECTED OUTPUT\n{\n    \"nl_description\": \"Recolor all objects to color Y\",\n    \"code\": \"(do\\n    (rule\\n        (vars (this))\\n        (filter)\\n        (apply\\n            (update_color Y)\\n        )\\n    )\\n)\"\n}\n\n\n## DEMONSTRATION TASK 2\n\n### INPUT\nPAIR 1\nINPUT GRID:\nO O O O O O O O\nO F F O O O R O\nO F F O O O O O\nO O O O O O O O\nO O O O O O O O\nO O O O O O O O\nO O A O O X X O\nO O O O O O O O\nOUTPUT GRID:\nO O O O O O O O\nO F F R R R R O\nO F F O O O O O\nO O A O O O O O\nO O A O O O O O\nO O A O O O O O\nO O A O O X X O\nO O O O O O O O\n\nPAIR 2\nINPUT GRID:\nO O O O O O O O O O\nO O O Y O G G G G O\nO O F O O G G G G O\nO O O O O O O O O O\nO O O O O O O O O O\nO O O O O O O O O O\nO C C C O O O O O O\nO C C C O O O O A O\nO C C C O O O X O O\nO O O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O O O\nO O O Y O G G G G O\nO O F Y O G G G G O\nO O F Y O O O O O O\nO O F Y O O O O O O\nO O F Y O O O O O O\nO C C C O O O O O O\nO C C C A A A A A O\nO C C C X X X X O O\nO O O O O O O O O O\n\n### EXPECTED OUTPUT\n{\n    \"nl_description\": \"Extend all the objects of size 1 toward the object of maximum size, without overlapping.\",\n    \"code\": \"(do\\n    (rule\\n        (vars (this other))\\n        (filter\\n            (and\\n                (size_equals (size_of this) 1)\\n                (and\\n                    (neighbor_of this other)\\n                    (size_equals (size_of other) max)\\n                )\\n            )\\n        )\\n        (apply\\n            (extend_node (direction_of other) false)\\n        )    \\n    )\\n)\"\n}\n\n\n## DEMONSTRATION TASK 3\n\n### INPUT\nPAIR 1\nINPUT GRID:\nO O O O O O O O O O\nO O O O O O O G O O\nO O G O O O O G O O\nO O G G O O O G G O\nO O O O O O O O O O\nO G G O O O O O O O\nO G G O O G G G O O\nO O O O O O O O O O\nO O G G O O O G O O\nO O O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O O O\nO O B O O O O G O O\nO O B B O O O G O O\nO O O O O O O G G O\nO O O O O O O O O O\nO G G O O B B B O O\nO G G O O O O O O O\nO O O O O O O O O O\nO O G G O O O G O O\nO O O O O O O O O O\n\nPAIR 2\nINPUT GRID:\nO O O O O O O O O O O O O O O O\nO O O O O O O O O O O O O G O O\nO B B O O O O O O C C C O G G O\nO O O O O F O O O O O O O O O O\nO O O O O F O O O O R R O O O O\nO O O O O F O O O O R R O O O O\nO O O O O O O O W O O O O O O O\nO O O A O O O W W O O O X O O O\nO O O A A O O W W O O O X X X O\nO O O O O O O O O O O O O O O O\nO O O O O O O O O O Y Y O O O O\nO O O O B O O O O O O O O O O O\nO Y O O B O O O G O O O O F F O\nO Y O O O O O O G O O O O F F O\nO Y Y Y O O O O G O O O O O O O\nO O O O O O O O O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O O O O O O B O O\nO O O O O O O O O B B B O B B O\nO B B O O B O O O O O O O O O O\nO O O O O B O O O O O O O O O O\nO O O O O B O O O O R R O O O O\nO O O O O O O O O O R R O O O O\nO O O B O O O O W O O O O O O O\nO O O B B O O W W O O O X O O O\nO O O O O O O W W O O O X X X O\nO O O O O O O O O O O O O O O O\nO O O O O O O O O O Y Y O O O O\nO O O O B O O O B O O O O O O O\nO Y O O B O O O B O O O O F F O\nO Y O O O O O O B O O O O F F O\nO Y Y Y O O O O O O O O O O O O\nO O O O O O O O O O O O O O O O\n\n### EXPECTED OUTPUT\n{\n    \"nl_description\": \"Move all objects of size 3 one step up, and then recolor them to color B.\",\n    \"code\": \"(do\\n    (rule\\n        (vars (this))\\n        (filter\\n            (size_equals (size_of this) 3)\\n        )\\n        (apply\\n            (move_node up)\\n            (update_color B)\\n        )\\n    )\\n)\"\n}\n\n\n## DEMONSTRATION TASK 4\n\n### INPUT\nPAIR 1\nINPUT GRID:\nO O O O R O O O A O\nO B O O O O B O O O\nO O O O O O O O O O\nO O O O X X X O O O\nO O O O X X X O O F\nW O O O O O O O O O\nO O F O O O Y O O O\nO O O O O O O O O O\nO O O O G O O O W O\nO O O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O A O\nO B O O O O O O O O\nO O O O R O B O O O\nO O O O X X X O O O\nO O O O X X X F O O\nW O O O G O Y O O O\nO O F O O O O O O O\nO O O O O O O O O O\nO O O O O O O O W O\nO O O O O O O O O O\n\nPAIR 2\nINPUT GRID:\nO O O F O O O R O O O O\nO O O O O O O O O Y O O\nO O O O O B O O O O O O\nO O R O O O O O G O O O\nB O O O O G O O O O O A\nO O O O O O R O O O W O\nO O O O O O O O C O O O\nG O X X O O O O O O O R\nO O X X O O O O O O Y O\nO O X X O O A O O O O O\nO F X X O O O O O O O O\nO O O O O Y O O O O O O\nOUTPUT GRID:\nO O O O O O O R O O O O\nO O O O O O O O O Y O O\nO O O O O B O O O O O O\nO O O O O O O O G O O O\nB O O O O G O O O O O A\nO O O O O O R O O O W O\nO O R F O O O O C O O O\nO G X X R O O O O O O O\nO O X X Y O O O O O O O\nO O X X A O O O O O O O\nO F X X O O O O O O O O\nO O O O O Y O O O O O O\n\nPAIR 3\nINPUT GRID:\nO G O O O O O O\nO O O A O O A O\nW O O O W O O O\nO O O O O O O B\nO R O X O F O O\nO O O O O O O O\nO G O O F O O G\nO O B O O A O O\nOUTPUT GRID:\nO G O O O O O O\nO O O O O O A O\nW O O O W O O O\nO O O A O O O B\nO O R X F O O O\nO O O O O O O O\nO G O O F O O G\nO O B O O A O O\n\n### EXPECTED OUTPUT\n{\n    \"nl_description\": \"Move all objects of color different than X, toward the object of color X, if they are neighbors of it.\",\n    \"code\": \"(do\\n    (rule\\n        (vars (this other))\\n        (filter\\n            (and\\n                (not (color_equals (color_of this) X))\\n                (and\\n                    (neighbor_of this other)\\n                    (color_equals (color_of other) X)\\n                )\\n            )\\n        )\\n        (apply\\n            (move_node_max (direction_of other))\\n        )\\n    )\\n)\"\n}\n\n\nNow follows task you will be evaluated on.\nOutput the solution as a JSON object, which should contain both a natural language description of the solution and the solution written in the DSL.\nThe code should be parseable by the DSL grammar.\nThe JSON must have the following structure:\n\n{\n    \"nl_description\": \"TO_BE_FILLED\",\n    \"code\": \"TO_BE_FILLED\"\n}\n\n## TEST TASK\n\nPAIR 1\nINPUT GRID:\nC C C C C C C C C C C C\nC C G G G C C C C C C C\nC C G G G C C C C C C C\nC C G G G C C C C Y C C\nC C G G G C C C C C C C\nC C C C C C C C C C C C\nC C C C C C C C C C C C\nC C C C C C C Y C C C C\nC C C C C C C C C C C C\nOUTPUT GRID:\nC C C C C C C C C C C C\nC C G G G C C C C C C C\nC C G G G C C C C C C C\nC C G G G Y Y Y Y Y C C\nC C G G G C C C C C C C\nC C C C C C C C C C C C\nC C C C C C C C C C C C\nC C C C C C C Y C C C C\nC C C C C C C C C C C C\n\nPAIR 2\nINPUT GRID:\nR R R R R R R R R R R R\nR R R R R R R R R R R R\nR R R B B B R R R R R R\nR R R B B B R R R R R R\nR R R B B B R R R R R R\nR R R R R R R R R R R R\nR R R R R R R R R R R R\nR R R R R R R R R R R R\nR R R C R R R R R R R R\nR R R R R R R R R R R R\nOUTPUT GRID:\nR R R R R R R R R R R R\nR R R R R R R R R R R R\nR R R B B B R R R R R R\nR R R B B B R R R R R R\nR R R B B B R R R R R R\nR R R C R R R R R R R R\nR R R C R R R R R R R R\nR R R C R R R R R R R R\nR R R C R R R R R R R R\nR R R R R R R R R R R R\n\nPAIR 3\nINPUT GRID:\nB B B B R B B B B B B B\nB B B B B B B B B B B B\nB B B B B B B B B B B B\nB B B B B B B B B B B B\nB B B Y Y Y Y B B B B B\nB B B Y Y Y Y B B B B B\nB B B Y Y Y Y B B B R B\nB B B Y Y Y Y B B B B B\nB B B B B B B B B B B B\nB B B B B B B B B B B B\nB B B B B B B B B B B B\nB R B B B B B B B B B B\nB B B B B B B B B B B B\nB B B B B B B B B B B B\nOUTPUT GRID:\nB B B B R B B B B B B B\nB B B B R B B B B B B B\nB B B B R B B B B B B B\nB B B B R B B B B B B B\nB B B Y Y Y Y B B B B B\nB B B Y Y Y Y B B B B B\nB B B Y Y Y Y R R R R B\nB B B Y Y Y Y B B B B B\nB B B B B B B B B B B B\nB B B B B B B B B B B B\nB B B B B B B B B B B B\nB R B B B B B B B B B B\nB B B B B B B B B B B B\nB B B B B B B B B B B B\n\nPAIR 4\nINPUT GRID:\nB B B B B B B B B B B B B B B B B B\nB B B B B B B B Y B B B B B B B B B\nB B B B B B B B B B B B B B B B B B\nB B B B B B B B B B B Y B B B B B B\nB B B B B B B B B B B B B B B Y B B\nB B Y B B B B X X X X X B B B B B B\nB B B B B B B X X X X X B B B B B B\nB B B B B B B X X X X X B B B B B B\nB B B B B B B X X X X X B B B B B B\nB B B B B B B B B B B B B B B B B B\nB B B B B B B B B B B B B B B B B B\nB B B B B B B B B B B B B Y B B B B\nB B B B B B B B B B B B B B B B B B\nB B B B B B B B B B B B B B B B B B\nOUTPUT GRID:\nB B B B B B B B B B B B B B B B B B\nB B B B B B B B Y B B B B B B B B B\nB B B B B B B B Y B B B B B B B B B\nB B B B B B B B Y B B Y B B B B B B\nB B B B B B B B Y B B Y B B B Y B B\nB B Y Y Y Y Y X X X X X B B B B B B\nB B B B B B B X X X X X B B B B B B\nB B B B B B B X X X X X B B B B B B\nB B B B B B B X X X X X B B B B B B\nB B B B B B B B B B B B B B B B B B\nB B B B B B B B B B B B B B B B B B\nB B B B B B B B B B B B B Y B B B B\nB B B B B B B B B B B B B B B B B B\nB B B B B B B B B B B B B B B B B B\n"
        }
    ],
    "n_valid_json": 100,
    "n_can_parse": 76,
    "completions": [
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend the object of size 1 towards the adjacent object",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) true)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of color Y to the maximum length horizontally, without overlapping",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) Y)\n        )\n        (apply\n            (extend_node right false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend node horizontally to the left and right with color Y for all square-shaped objects of color G and object of color B",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (or\n                (shape_equals (shape_of this) square)\n                (color_equals (color_of this) G)\n            )\n        )\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects towards the nearest object of color X, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (and\n                    (not (color_equals (color_of this) X))\n                    (color_equals (color_of other) X)\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of color different than X rightwards, such that they overlap with objects of color X.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) X))\n                (neighbor_of this other)\n                (color_equals (color_of other) X)\n            )\n        )\n        (apply\n            (extend_node right true)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of other) X)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Recolor any vertical object of size greater than 3 that has another vertical object next to it on the right side, to fill the gap between both objects.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 4)\n                (size_equals (size_of other) 4)\n                (neighbor_of this other)\n                (column_equals (column_of this) (column_of other))\n            )\n        )\n        (apply\n            (update_color (color_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (neighbor_of this other)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend horizontally the bottommost row of each object of height >= 1 but only switch position with other objects of color Y or C.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (height_equals (height_of this) 3)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node_max down)\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend nodes of color G and size 1 towards neighboring nodes of color R and size 1, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) G)\n                (and\n                    (size_equals (size_of this) 1)\n                    (and\n                        (neighbor_of this other)\n                        (and\n                            (color_equals (color_of other) R)\n                            (size_equals (size_of other) 1)\n                        )\n                    )\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects that are neighbors to an object of color other than C or Y in the direction until they collide, otherwise fill C.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (not (color_equals (color_of other) Y))\n                (not (color_equals (color_of other) C))\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n            (update_color C)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (not (color_equals (color_of other) C))\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of size three with color G, B or Y to nearby adjacent cells with color Y or R.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 3)\n                (or\n                    (color_equals (color_of this) G)\n                    (color_equals (color_of this) B)\n                    (color_equals (color_of this) Y)\n                )\n                (or\n                    (neighbor_of this other)\n                    (or\n                        (color_equals (color_of other) Y)\n                        (color_equals (color_of other) R)\n                    )\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) true)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 10 col 21\n\n                    (color_equals (color_of this) Y)\n                    ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend the rightmost edge of the Y-colored objects, in a horizontal direction, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) Y)\n        )\n        (apply\n            (extend_node right false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move objects of color 'Y' towards neighboring shapes, extend them without overlapping, if they are neighbors.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) Y)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend objects towards another object with different color, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (not (color_equals (color_of this) (color_of other)))\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Recolor the objects to the right of the G and B objects to the respective colors.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of other this)\n                (or\n                    (color_equals (color_of other) G)\n                    (color_equals (color_of other) B)\n                )\n            )\n        )\n        (apply\n            (update_color (color_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Recolor any object adjacent to the object with color Y to match the color of Y and extend it in that direction.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of other) Y)\n            )\n        )\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects vertically towards the closest object of a different color until they hit it.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) (color_of other)))\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects neighbor to Y with a single cell.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of other) Y)\n            )\n        )\n        (apply\n            (extend_node (direction_of this) true)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all the objects with a neighbor of color Y, towards the objects of color Y, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of other) Y)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of size 1 till the border of the grid in all directions.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (extend_node up false)\n            (extend_node down false)\n            (extend_node left false)\n            (extend_node right false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend objects towards the neighboring objects of a certain Y color",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of other) Y)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) true)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend downwards all objects of color C, B, and G when they are neighbors to another object and of size larger than 1.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (or\n                    (or\n                        (color_equals (color_of this) C)\n                        (color_equals (color_of this) B)\n                    )\n                    (color_equals (color_of this) G)\n                )\n                (and\n                    (size_equals (size_of this) (max (size_of this) 1))\n                    (neighbor_of this other)\n                )\n            )\n        )\n        (apply\n            (extend_node down false)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'm' in the current parser context, at line 14 col 50\n\n           (size_equals (size_of this) (max (size_of this) 1))\n                                        ^\nExpected one of: \n\t* SIZE_OF\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend the horizontal lines of objects to the left or right if they are next to another object, and recolor them in the middle row.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (or\n                    (neighbor_of this other)\n                    (neighbor_of this other)\n                )\n            )\n        )\n        (apply\n            (extend_node right false)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (and\n                (size_equals (size_of this) max)\n                (column_equals (column_of this) 5)\n            )\n        )\n        (apply\n            (update_color R)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches ')' in the current parser context, at line 10 col 13\n\n            )\n            ^\nExpected one of: \n\t* LPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects until they hit another object, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (neighbor_of this other)\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color Y toward neighboring objects.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) Y)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend objects towards the neighboring objects with different colors, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) (color_of other)))\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend nodes that are neighbors of the object to the maximum extent along the direction of the object.",
            "code": "(do (rule (vars (this other)) (filter (neighbor_of this other)) (apply (extend_node (direction_of other) true))))",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of size 1 to the right if they are neighbors of an object of size greater than 1, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (not (size_equals (size_of other) 1))\n                )\n            )\n        )\n        (apply\n            (extend_node right false)\n        )    \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "For each object having a horizontal neighbor with different color, recolor that row's end with the neighbor's color.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (not (color_equals (color_of this) (color_of other)))\n            )\n        )\n        (apply\n            (update_color (color_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all neighboring objects towards the objects of color Y.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (neighbor_of this other)\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Recolor all objects adjacent to the color C or R to the color Y.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (or\n                (neighbor_of this other)\n                (or\n                    (color_equals (color_of other) C)\n                    (color_equals (color_of other) R)\n                )\n            )\n        )\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of size 1 towards the nearest object of any size, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move a specific color (Y, C, R) down until it hits another object. If 'C' encounters 'Y', it extends 'Y'.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) C)\n                (color_equals (color_of other) Y)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node down false)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) C)\n                (color_equals (color_of other) R)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node down false)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) C)\n        )\n        (apply\n            (move_node_max down)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (neighbor_of this other)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend objects of color different than the most common color Y, if they neighbor it, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) Y))\n                (neighbor_of this other)\n                (color_equals (color_of other) Y)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of other) Y)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color that are a neighbor to the object of color Y and update their color to Y.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of other) Y)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all Y colored objects to the right, without overlapping with other objects.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) Y)\n        )\n        (apply\n            (extend_node right false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend the objects that are neighbors of G and B (and not already colored G or B) towards them, without overlapping.",
            "code": "(do\n  (rule\n    (vars (this other))\n    (filter\n      (and\n        (or\n          (color_equals (color_of other) G)\n          (color_equals (color_of other) B)\n        )\n        (and\n          (neighbor_of this other)\n          (not\n            (or\n              (color_equals (color_of this) G)\n              (color_equals (color_of this) B)\n            )\n          )\n        )\n      )\n    )\n    (apply\n      (extend_node (direction_of other) false)\n    )\n  )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of color different than C and X toward the last row or column they intersected.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) C))\n                (and\n                    (not (color_equals (color_of this) X))\n                    (color_equals (color_of other) (color_of this))\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) true)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of color different than the dominant color Y towards color Y with overlapping",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) Y))\n                (neighbor_of this other)\n                (color_equals (color_of other) Y)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) true)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of other) Y)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all the objects of color different than the background color, towards the nearest neighboring object of maximum width, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) C))\n                (and\n                    (neighbor_of this other)\n                    (width_equals (width_of other) max)\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )    \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of size 5 toward the nearest color other than their own, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 5)\n                (and\n                    (neighbor_of this other)\n                    (not (color_equals (color_of this) (color_of other)))\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all the objects with color C and B towards the color Y, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (or\n                    (color_equals (color_of this) C)\n                    (color_equals (color_of this) B)\n                )\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) Y)\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend objects of size 5 if they are neighbors of color Y objects and color them Y, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 5)\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) Y)\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n            (update_color Y)\n        )    \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend the object touching the bottom border towards left and color it as the object it touched.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (column_equals (column_of other) odd)\n            )\n        )\n        (apply\n            (extend_node left false)\n            (update_color (color_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Find the longest horizontal object and extend all neighbours of it towards its border, if not overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (width_equals (width_of other) max)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend objects towards the right or down direction if their neighbors are colored Y or C, and change their color to the color of these neighbors.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (or\n                    (color_equals (color_of other) Y)\n                    (color_equals (color_of other) C)\n                )\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n            (update_color (color_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend a line of objects adjacent to certain objects until they encounter an object or the grid boundary.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of other) R)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node down false)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of other) G)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node right false)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of other) B)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node up false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of size 1 towards the nearest object of a different color, overlapping when necessary.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (not (color_equals (color_of this) (color_of other)))\n            )\n        )\n        (apply\n            (extend_node (direction_of other) true)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of color different than X with size equal to 3, 5 or 7, in all cardinal directions, overlapping.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (and\n                (not (color_equals (color_of this) X))\n                (or\n                    (size_equals (size_of this) 3)\n                    (or\n                        (size_equals (size_of this) 5)\n                        (size_equals (size_of this) 7)\n                    )\n                )\n            )\n        )\n        (apply\n            (extend_node up true)\n            (extend_node down true)\n            (extend_node left true)\n            (extend_node right true)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects until they encounter another object.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (neighbor_of this other)\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects adjacent to other objects with different color.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (not (color_equals (color_of this) (color_of other)))\n            )\n        )\n        (apply\n            (extend_node (direction_of other) true)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of color C downwards, and then recolor them to color Y.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) C)\n        )\n        (apply\n            (extend_node down false)\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move objects of color different than X and C to the right if they are neighbors of objects of color X",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) X))\n                (and\n                    (not (color_equals (color_of this) C))\n                    (and\n                        (neighbor_of this other)\n                        (color_equals (color_of other) X)\n                    )\n                )\n            )\n        )\n        (apply\n            (move_node right)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 towards the object of size greater than 1 if they are neighbors, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (not (size_equals (size_of other) 1))\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )    \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all the objects of size 4 toward the nearest object they are neighbors with, overlapping if necessary.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 4)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) true)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend the green block downwards if it touches a yellow block.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) G)\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) Y)\n                )\n            )\n        )\n        (apply\n            (extend_node down true)\n        )    \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend the nearest objects towards the nearest object downwards until they hit another object, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (column_equals (column_of this) (column_of other))\n            )\n        )\n        (apply\n            (extend_node down false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move objects of size 1 towards objects of size 3 or larger when they are neighbors.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (or\n                        (size_equals (size_of other) 3)\n                        (size_equals (size_of other) max)\n                    )\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of minimum size and color X towards the objects of color different than X, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) min)\n                (color_equals (color_of this) X)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all the objects adjacent to another with color changed afterward without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (neighbor_of this other)\n        )\n        (apply\n            (extend_node (direction_of other) false)\n            (update_color (color_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of color different than C by adding adjacent cells of color C towards the bottom.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) C))\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node down true)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend row objects vertically such that their sizes become consistent at column edges.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (or\n                (size_equals (size_of this) 3)\n                (size_equals (size_of this) 4)\n            )\n        )\n        (apply\n            (extend_node down true)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "If any object touches the 'Y' object, extend 'Y' objects in all directions.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of other) Y)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node up true)\n            (extend_node down true)\n            (extend_node left true)\n            (extend_node right true)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects adjacent to objects of color Y towards objects of color Y, until they hit another object.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (neighbor_of this other)\n            (color_equals (color_of other) Y)\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 6 col 13\n\n            (color_equals (color_of other) Y)\n            ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend the horizontal segment of objects by 1 to the right, if they are next to an object of size 3",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of other) 3)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node right false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend objects of color C that are neighbors to objects of color differing from C towards the Y objects, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) C)\n                (neighbor_of this other)\n                (not (color_equals (color_of other) C))\n            )\n        )\n        (apply\n            (extend_node down false)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (not (color_equals (color_of other) C))\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color Y towards the first column, and then recolor them to color Y",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) Y)\n        )\n        (apply\n            (move_node_max left)\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Recolor all of the neighbors of objects of color Y to color Y.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (neighbor_of this other)\n            (color_equals (color_of other) Y)\n        )\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 6 col 13\n\n            (color_equals (color_of other) Y)\n            ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects towards the nearest neighbor with the same color and size as the max size object in the grid, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (size_equals (size_of other) max)\n                (color_equals (color_of this) (color_of other))\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of this) (color_of \n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all horizontal objects of size 5 or greater downward, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (and\n                (size_equals (size_of this) 5)\n                (size_equals (size_of this) 6)\n                (size_equals (size_of this) 7)\n                (size_equals (size_of this) 8)\n            )\n        )\n        (apply\n            (extend_node down false)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (size_equals (size_of this) 7)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all the objects of color different than X toward the object of color X, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) X))\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) X)\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects whose color is different from 'X' towards neighboring 'X' objects without overlap.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) X))\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) X)\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color Y one step up.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) Y)\n        )\n        (apply\n            (move_node up)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color R, G, or C downward towards the object of color Y, if they are neighbors of it.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (or\n                    (color_equals (color_of this) R)\n                    (or\n                        (color_equals (color_of this) G)\n                        (color_equals (color_of this) C)\n                    )\n                )\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) Y)\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend objects to the right and left to match the length of the object below.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (shape_equals (shape_of this) enclosed)\n                (neighbor_of this other)\n                (height_equals (height_of other) max)\n            )\n        )\n        (apply\n            (extend_node right false)\n            (extend_node left false)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (height_equals (height_of other) max)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend objects of any color towards Y while leaving a trail, but do not extend further if the object hits the border.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (not (color_equals (color_of this) Y))\n        )\n        (apply\n            (extend_node (right) false)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'r' in the current parser context, at line 8 col 27\n\n            (extend_node (right) false)\n                          ^\nExpected one of: \n\t* DIRECTION_OF\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of color Y towards the maximum size object in the same column until they are neighbors, and color them with color Y.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) Y)\n                (and\n                    (neighbor_of this other)\n                    (size_equals (size_of other) max)\n                )\n            )\n        )\n        (apply\n            (extend_node down false)\n            (update_color Y)\n        )    \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend objects towards neighbor objects of a different color.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (not (color_equals (color_of this) (color_of other)))\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move an object horizontally and color it with that corresponding to a neighboring object of different color.",
            "code": "(do (rule (vars (this other)) (filter (and (neighbor_of this other) (not (color_equals (color_of this) (color_of other))))) (apply (move_node (direction_of other)) (update_color (color_of other)))))",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 toward the object of maximum size, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (size_equals (size_of other) max)\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )    \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "When a 'this' object is a neighbor of a 'Y' object, if its color is 'this' and not 'Y', move the 'this' object towards the 'Y' object.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of other) Y)\n                (neighbor_of this other)\n                (not (color_equals (color_of this) Y))\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (not (color_equals (color_of this) Y))\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Recolor the objects neighboring the object of color Y to the color of the object.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (neighbor_of this other)\n        )\n        (apply\n            (update_color (color_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend specific objects horizontally or vertically depending on their neighboring object of color Y, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of other) Y)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move objects that are neighbors of yellow objects to overlap with them.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of other) Y)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) true)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of color Y towards the nearest neighboring object to the right without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) Y)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node right false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of color other than X along the direction towards the nearest object of color X if they are neighbors, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) X))\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) X)\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )    \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Recolor all neighboring objects of color C to Y.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) Y)\n                (neighbor_of other this)\n                (color_equals (color_of other) C)\n            )\n        )\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of other) C)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move objects of color different than color C, that are neighbors to a C object, right towards a C object.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) C))\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) C)\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend the object of color C towards the adjacent non-C object intersecting its region, and then recolor it to C.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) Y)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend objects that are neighbors of objects of color other than their own color, to the direction of the neighbor object color without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) (color_of other)))\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )    \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of color different than C, R, and B and toward the object of color C, R, and B, if they are neighbors of it, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) C))\n                (not (color_equals (color_of this) R))\n                (not (color_equals (color_of this) B))\n                (and\n                    (neighbor_of this other)\n                    (or\n                        (color_equals (color_of other) C)\n                        (color_equals (color_of other) R)\n                        (color_equals (color_of other) B)\n                    )\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (not (color_equals (color_of this) B))\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of color different from C, R, and B, towards the neighboring object of maximum size with color C, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) C))\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) C)\n                    (size_equals (size_of other) max)\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 10 col 21\n\n                    (size_equals (size_of other) max)\n                    ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "For objects that are both neighbors and columns of x and y match, move them up and change the color to the object's color of the maximum size (G in input 1, C in input 2, Y in input 3, X in input 4).",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (and (column_equals (column_of this) (column_of other))\n                     (or\n                         (color_equals (color_of other) G)\n                         (or\n                             (color_equals (color_of other) C)\n                             (color_equals (color_of other) Y))))))\n        )\n        (apply\n            (move_node up)\n            (update_color (color_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches ')' in the current parser context, at line 13 col 9\n\n        )\n        ^\nExpected one of: \n\t* LPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "For any object of different color being a neighbor of Y colored object, color the neighbors of Y with Y as well.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) Y))\n                (neighbor_of this other)\n                (color_equals (color_of other) Y) \n            )\n        )\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of other) Y) \n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all the objects of color different than the initial grid color, in the direction of the object of the same color, without overlapping",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) (color_of (grid block))))\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of this) (color_of other))\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )    \n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 6 col 62\n\n(color_equals (color_of this) (color_of (grid block))))\n                                        ^\nExpected one of: \n\t* VAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Recolor objects that are immediate neighbors of other objects of different color.",
            "code": "(do \n    (rule \n        (vars (this other)) \n        (filter (neighbor_of this other)) \n        (apply (update_color Y)) \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend objects of size 1 towards the nearest object when they are in the same row or column.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (or\n                    (neighbor_of this other)\n                    (column_equals (column_of this) (column_of other))\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) true)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all neighbor Y-colored objects to the end of the line.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) Y)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects towards the nearest object of color different from their own, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) (color_of other)))\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all the objects of size 5 towards the bottommost object until they hit another object, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 5)\n                (and\n                    (neighbor_of this other)\n                    (height_equals (height_of other) max)\n                )\n            )\n        )\n        (apply\n            (extend_node down false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of minimum size towards the object with the maximum size in their direction.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) min)\n                (neighbor_of this other)\n                (size_equals (size_of other) max)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) true)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (size_equals (size_of other) max)\n                ^\nExpected one of: \n\t* RPAR\n"
        }
    ],
    "task_id": "2c608aff"
}