{
    "model": "gpt-4o-2024-05-13",
    "usage": {
        "completion_tokens": 14265,
        "prompt_tokens": 5654,
        "total_tokens": 19919,
        "prompt_tokens_details": {
            "cached_tokens": 0
        },
        "completion_tokens_details": {
            "reasoning_tokens": 0
        }
    },
    "request_time": 13.738652229309082,
    "n_requested": 100,
    "prompt_messages": [
        {
            "role": "system",
            "content": "You are an assistant chatbot with human-like perception, reasoning and learning capabilities.\nYou can solve tasks concisely, efficiently, and moreover, correctly.\nLet's engage in perception- and logic-based tasks.\nYou only output source code.\nNo explanations or any other text.\nOnly code."
        },
        {
            "role": "user",
            "content": "You are an efficient assistant for logical reasoning and code generation.\nYou will help me solve a visual perception and reasoning task.\nI will first provide you with the definition of a Domain Specific Language you will use for writing a solution for the task.\nI will then present you with the description of the task that you will be tested in.\nYou will then respond the queries I make regarding the solution of the task.\n\n\nThis is the definition of the DSL you will use to solve the task.\nIt is given as a context-free grammar in the EBNF format used by the Lark parser generator, with some informative comments about the semantics.\nYou will return a string that is parseable by the `program` non-terminal of the grammar.\n\n```\nlibrary: \"(\" program* \")\"\n\n// Rules are executed one after another, in the order they appear.\n// There could be no rules, in which case the program does nothing.\nprogram: \"(\" \"do\" rule* \")\"\n\n// First, it declares the variables that will be used in the filter and transform expressions.\n// Second, it defines a filter expression that an object must satisfy in order to be transformed.\n// Then, it defines a list of transforms that will be applied objects that satisfy the filter expression.\nrule: \"(\" \"rule\" decl filter xform_list \")\"\n\n// The `vars` declaration specifies the names of the variables that will be used in the filter and transform expressions.\n// The `this` variable is always declared, and it refers to the object that is being transformed.\n// There could also be an additional optional variable `other` that refers to another object in the grid,\n// which is not being transformed, but is used in the filter expression.\ndecl: \"(\" \"vars\" \"(\" VAR_THIS VAR_OTHER? \")\" \")\"\n\n// A filter is a predicate over the objects in the grid.\n// If no filter is given, then all the objects are selected.\nfilter: \"(\" \"filter\" filter_expr? \")\"\n\n// It can be a primitive filter operation, or a boolean expression using the `and`, `or`, and `not` connectives.\n// IMPORTANT: The `and` and `or` connectives are strictly binary, so to take the conjunction or disjunction \n// of more than two expressions, the binary connectives must be nested.\n// AGAIN, the `and` and `or` connectives are not variadic, so the following is not allowed:\n// (and true true false)\n// Instead, the following must be used:\n// (and true (and true false))\n// The `not` connective is unary as expected.\n// The objects that are transformed are the ones that satisfy the filter expression.\nfilter_expr: filter_prim\n           | \"(\" OP_AND filter_expr filter_expr \")\"   \n           | \"(\" OP_OR filter_expr filter_expr \")\"\n           | \"(\" OP_NOT filter_expr \")\"\n\nfilter_prim: \"(\" COLOR_EQ fcolor_expr fcolor_expr \")\"           \n           | \"(\" SIZE_EQ size_expr size_expr \")\"                \n           | \"(\" HEIGHT_EQ height_expr height_expr \")\"          \n           | \"(\" WIDTH_EQ width_expr width_expr \")\"             \n           | \"(\" DEGREE_EQ degree_expr degree_expr \")\"          \n           | \"(\" SHAPE_EQ shape_expr shape_expr \")\"             \n           | \"(\" COLUMN_EQ column_expr column_expr \")\"         \n           | \"(\" NEIGHBOR_OF VAR VAR \")\"      // true if the two objects are neighbors\n\n\n// Transforms are applied one after another, in the order they appear.\nxform_list: \"(\" \"apply\" xform+ \")\"\n\n// A single transform is applied to all the objects that are bound to the `this` variable. \n// The transform is applied to each such object independently and simultaneously.\nxform:     \"(\" TR_UPDATE_COLOR color_expr \")\"                          // change this object color to the given color \n         | \"(\" TR_MOVE_NODE direction_expr \")\"                         // move this object in the given direction\n         | \"(\" TR_EXTEND_NODE direction_expr OVERLAP \")\"               // extend (move while leaving a trail) this object in the given direction\n                                                                  // if overlap is false, then the object is extended until it hits another object,\n                                                                  // otherwise it is extended until the edge of the grid.\n         | \"(\" TR_MOVE_NODE_MAX direction_expr \")\"                     // move this object until it hits another object, in the given direction\n         | \"(\" TR_ROTATE_NODE ROT_ANGLE \")\"                       // rotate this object by the given angle\n         | \"(\" TR_ADD_BORDER color_expr \")\"                            // color this exterior pixels of the object with the given color\n         | \"(\" TR_FILL_RECTANGLE color_expr OVERLAP \")\"                // color this interior of a hollow rectangle with the given color\n         | \"(\" TR_HOLLOW_RECTANGLE color_expr \")\"                      // color this interior of a solid rectangle with the given color\n         | \"(\" TR_MIRROR mirror_expr \")\"\n         | \"(\" TR_FLIP SYMMETRY_AXIS \")\"                          // flip this object with respect to the given axis\n         | \"(\" TR_INSERT OBJECT_ID img_pts_expr RELATIVE_POSITION \")\" // insert a copy of this object at the position of the given object\n         | \"(\" TR_NOOP \")\"                                        // do nothing\n\nfcolor_expr: FCOLOR\n           | \"(\" COLOR_OF VAR \")\"\n\ncolor_expr: COLOR\n          | \"(\" COLOR_OF VAR \")\"\n\nsize_expr: SIZE\n         | \"(\" SIZE_OF VAR \")\"\n\nheight_expr: HEIGHT\n           | \"(\" HEIGHT_OF VAR \")\"\n\nwidth_expr: WIDTH\n          | \"(\" WIDTH_OF VAR \")\"\n\ndegree_expr: DEGREE\n           | \"(\" DEGREE_OF VAR \")\" \n\nshape_expr: SHAPE\n          | \"(\" SHAPE_OF VAR \")\"\n\ncolumn_expr: COLUMN\n           | \"(\" COLUMN_OF VAR \")\"\n\ndirection_expr: DIRECTION\n              | \"(\" DIRECTION_OF VAR \")\"\n\nimg_pts_expr: IMAGE_POINTS\n            | \"(\" IMAGE_POINTS_OF VAR \")\"\n\nmirror_expr: \"(\" MIRROR_AXIS_OF VAR \")\"\n\nOBJECT_ID: /[0-9]+/\nFCOLOR: \"O\" // black\n      | \"B\" // blue\n      | \"R\" // red\n      | \"G\" // green\n      | \"Y\" // yellow\n      | \"X\" // grey\n      | \"F\" // fuchsia\n      | \"A\" // orange\n      | \"C\" // cyan  \n      | \"W\" // brown\n\nSIZE: \"min\" | \"max\" | \"even\" | \"odd\" | /[0-9]+/  // size of objects\nDEGREE: \"min\" | \"max\" | \"even\" | \"odd\" | /[0-9]+/  // degree of objects\nHEIGHT: \"min\" | \"max\" | \"even\" | \"odd\" | /[0-9]+/  // height of objects\nWIDTH: \"min\" | \"max\" | \"even\" | \"odd\" | /[0-9]+/  // width of objects\nCOLUMN: \"center\" | \"even\" | \"odd\" | /[0-9]+/  // column of objects\nSHAPE: \"square\" | \"enclosed\"  // shape of objects\n\nDIRECTION: \"up\"\n         | \"down\"\n         | \"left\"\n         | \"right\"\n         | \"up_left\"\n         | \"up_right\"\n         | \"down_left\"\n         | \"down_right\"\n\nSYMMETRY_AXIS: \"vertical\" | \"horizontal\" | \"diagonal_left\" | \"diagonal_right\"\n\n// The angle of clockwise rotation, in degrees.\nROT_ANGLE: \"0\" \n         | \"90\" \n         | \"180\" \n         | \"270\"\n\nCOLOR: \"O\" // black\n      | \"B\" // blue\n      | \"R\" // red\n      | \"G\" // green\n      | \"Y\" // yellow\n      | \"X\" // grey\n      | \"F\" // fuchsia\n      | \"A\" // orange\n      | \"C\" // cyan  \n      | \"W\" // brown\n\nOVERLAP: BOOL\n\nBOOL: \"true\" | \"false\"\n\nIMAGE_POINTS: \"top\" | \"bottom\" | \"left\" | \"right\" | \"top_left\" | \"top_right\" | \"bottom_left\" | \"bottom_right\" \n\nRELATIVE_POSITION: \"source\"\n                 | \"target\"\n                 | \"middle\"\n\nVAR: VAR_THIS | VAR_OTHER\nVAR_THIS: \"this\"\nVAR_OTHER: \"other\"\n\nOP_AND: \"and\"\nOP_OR: \"or\"\nOP_NOT: \"not\"\n\nCOLOR_OF: \"color_of\"\nSIZE_OF: \"size_of\"\nHEIGHT_OF: \"height_of\"\nWIDTH_OF: \"width_of\"\nDEGREE_OF: \"degree_of\"\nSHAPE_OF: \"shape_of\"\nCOLUMN_OF: \"column_of\"\nDIRECTION_OF: \"direction_of\"\nIMAGE_POINTS_OF: \"img_pts_of\"\nMIRROR_AXIS_OF: \"mirror_axis_of\"\n\nCOLOR_EQ: \"color_equals\"\nSIZE_EQ: \"size_equals\"\nDEGREE_EQ: \"degree_equals\"\nHEIGHT_EQ: \"height_equals\"\nWIDTH_EQ: \"width_equals\"\nSHAPE_EQ: \"shape_equals\"\nCOLUMN_EQ: \"column_equals\"\nNEIGHBOR_OF: \"neighbor_of\"\n\nTR_UPDATE_COLOR: \"update_color\"\nTR_MOVE_NODE: \"move_node\"\nTR_EXTEND_NODE: \"extend_node\"\nTR_MOVE_NODE_MAX: \"move_node_max\"\nTR_ROTATE_NODE: \"rotate_node\"\nTR_ADD_BORDER: \"add_border\"\nTR_FILL_RECTANGLE: \"fill_rectangle\"\nTR_HOLLOW_RECTANGLE: \"hollow_rectangle\"\nTR_MIRROR: \"mirror\"\nTR_FLIP: \"flip\"\nTR_INSERT: \"insert\"\nTR_NOOP: \"noop\"\n\nCOMMENT: /\\s*/ \";;\" /[^\\n]/*\n\n%import common.WS\n%import common.LCASE_LETTER\n%import common.INT\n%ignore WS\n%ignore COMMENT\n```\n\n\nNow we continue with the visual perception and reasoning task.\nThe input for the task is a small number of pairs of grids of characters.\nThe value of each of the cells of the grids are the colors defined in the DSL, so we can think of grids as images.\nEach pair of images correspond to an input-output example for an unknown program P.\nFor each pair, the program P is evaluated on the image grid and operates on the objects that appear in it.\nThe output of the program is then the output image.\nThe objects in the images are easy and natural to identify for humans, so there is no need to define them explicitly.\nHowever you are able to abstract them correctly, and the DSL is interpreted with the same correct abstraction.\n\n\nNow I will show you some demonstration tasks along with the output you would be expected to produce for each of them.\n\n## DEMONSTRATION TASK 1\n\n### INPUT\nPAIR 1\nINPUT GRID:\nO O O O O O O O\nO O O O O R O O\nO R O O O R O R\nO R R O O R O O\nO O O O O O O O\nO R R O O O O O\nO R R O R R O O\nO O O O O O O O\nOUTPUT GRID:\nO O O O O O O O\nO O O O O Y O O\nO Y O O O Y O Y\nO Y Y O O Y O O\nO O O O O O O O\nO Y Y O O O O O\nO Y Y O Y Y O O\nO O O O O O O O\n\nPAIR 2\nINPUT GRID:\nO O O O O O O O O O\nO O O O R O O O O O\nO G O O R O O W O O\nO O G O O O W W O O\nO O G O O O O O O O\nO O O O X O O O O O\nO O O O O O F F F O\nO B O O O O O O O O\nO B B B B O O C C O\nO O O O O O O C O O\nOUTPUT GRID:\nO O O O O O O O O O\nO O O O Y O O O O O\nO Y O O Y O O Y O O\nO O Y O O O Y Y O O\nO O Y O O O O O O O\nO O O O Y O O O O O\nO O O O O O Y Y Y O\nO Y O O O O O O O O\nO Y Y Y Y O O Y Y O\nO O O O O O O Y O O\n\n### EXPECTED OUTPUT\n{\n    \"nl_description\": \"Recolor all objects to color Y\",\n    \"code\": \"(do\\n    (rule\\n        (vars (this))\\n        (filter)\\n        (apply\\n            (update_color Y)\\n        )\\n    )\\n)\"\n}\n\n\n## DEMONSTRATION TASK 2\n\n### INPUT\nPAIR 1\nINPUT GRID:\nO O O O O O O O\nO F F O O O R O\nO F F O O O O O\nO O O O O O O O\nO O O O O O O O\nO O O O O O O O\nO O A O O X X O\nO O O O O O O O\nOUTPUT GRID:\nO O O O O O O O\nO F F R R R R O\nO F F O O O O O\nO O A O O O O O\nO O A O O O O O\nO O A O O O O O\nO O A O O X X O\nO O O O O O O O\n\nPAIR 2\nINPUT GRID:\nO O O O O O O O O O\nO O O Y O G G G G O\nO O F O O G G G G O\nO O O O O O O O O O\nO O O O O O O O O O\nO O O O O O O O O O\nO C C C O O O O O O\nO C C C O O O O A O\nO C C C O O O X O O\nO O O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O O O\nO O O Y O G G G G O\nO O F Y O G G G G O\nO O F Y O O O O O O\nO O F Y O O O O O O\nO O F Y O O O O O O\nO C C C O O O O O O\nO C C C A A A A A O\nO C C C X X X X O O\nO O O O O O O O O O\n\n### EXPECTED OUTPUT\n{\n    \"nl_description\": \"Extend all the objects of size 1 toward the object of maximum size, without overlapping.\",\n    \"code\": \"(do\\n    (rule\\n        (vars (this other))\\n        (filter\\n            (and\\n                (size_equals (size_of this) 1)\\n                (and\\n                    (neighbor_of this other)\\n                    (size_equals (size_of other) max)\\n                )\\n            )\\n        )\\n        (apply\\n            (extend_node (direction_of other) false)\\n        )    \\n    )\\n)\"\n}\n\n\n## DEMONSTRATION TASK 3\n\n### INPUT\nPAIR 1\nINPUT GRID:\nO O O O O O O O O O\nO O O O O O O G O O\nO O G O O O O G O O\nO O G G O O O G G O\nO O O O O O O O O O\nO G G O O O O O O O\nO G G O O G G G O O\nO O O O O O O O O O\nO O G G O O O G O O\nO O O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O O O\nO O B O O O O G O O\nO O B B O O O G O O\nO O O O O O O G G O\nO O O O O O O O O O\nO G G O O B B B O O\nO G G O O O O O O O\nO O O O O O O O O O\nO O G G O O O G O O\nO O O O O O O O O O\n\nPAIR 2\nINPUT GRID:\nO O O O O O O O O O O O O O O O\nO O O O O O O O O O O O O G O O\nO B B O O O O O O C C C O G G O\nO O O O O F O O O O O O O O O O\nO O O O O F O O O O R R O O O O\nO O O O O F O O O O R R O O O O\nO O O O O O O O W O O O O O O O\nO O O A O O O W W O O O X O O O\nO O O A A O O W W O O O X X X O\nO O O O O O O O O O O O O O O O\nO O O O O O O O O O Y Y O O O O\nO O O O B O O O O O O O O O O O\nO Y O O B O O O G O O O O F F O\nO Y O O O O O O G O O O O F F O\nO Y Y Y O O O O G O O O O O O O\nO O O O O O O O O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O O O O O O B O O\nO O O O O O O O O B B B O B B O\nO B B O O B O O O O O O O O O O\nO O O O O B O O O O O O O O O O\nO O O O O B O O O O R R O O O O\nO O O O O O O O O O R R O O O O\nO O O B O O O O W O O O O O O O\nO O O B B O O W W O O O X O O O\nO O O O O O O W W O O O X X X O\nO O O O O O O O O O O O O O O O\nO O O O O O O O O O Y Y O O O O\nO O O O B O O O B O O O O O O O\nO Y O O B O O O B O O O O F F O\nO Y O O O O O O B O O O O F F O\nO Y Y Y O O O O O O O O O O O O\nO O O O O O O O O O O O O O O O\n\n### EXPECTED OUTPUT\n{\n    \"nl_description\": \"Move all objects of size 3 one step up, and then recolor them to color B.\",\n    \"code\": \"(do\\n    (rule\\n        (vars (this))\\n        (filter\\n            (size_equals (size_of this) 3)\\n        )\\n        (apply\\n            (move_node up)\\n            (update_color B)\\n        )\\n    )\\n)\"\n}\n\n\n## DEMONSTRATION TASK 4\n\n### INPUT\nPAIR 1\nINPUT GRID:\nO O O O R O O O A O\nO B O O O O B O O O\nO O O O O O O O O O\nO O O O X X X O O O\nO O O O X X X O O F\nW O O O O O O O O O\nO O F O O O Y O O O\nO O O O O O O O O O\nO O O O G O O O W O\nO O O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O A O\nO B O O O O O O O O\nO O O O R O B O O O\nO O O O X X X O O O\nO O O O X X X F O O\nW O O O G O Y O O O\nO O F O O O O O O O\nO O O O O O O O O O\nO O O O O O O O W O\nO O O O O O O O O O\n\nPAIR 2\nINPUT GRID:\nO O O F O O O R O O O O\nO O O O O O O O O Y O O\nO O O O O B O O O O O O\nO O R O O O O O G O O O\nB O O O O G O O O O O A\nO O O O O O R O O O W O\nO O O O O O O O C O O O\nG O X X O O O O O O O R\nO O X X O O O O O O Y O\nO O X X O O A O O O O O\nO F X X O O O O O O O O\nO O O O O Y O O O O O O\nOUTPUT GRID:\nO O O O O O O R O O O O\nO O O O O O O O O Y O O\nO O O O O B O O O O O O\nO O O O O O O O G O O O\nB O O O O G O O O O O A\nO O O O O O R O O O W O\nO O R F O O O O C O O O\nO G X X R O O O O O O O\nO O X X Y O O O O O O O\nO O X X A O O O O O O O\nO F X X O O O O O O O O\nO O O O O Y O O O O O O\n\nPAIR 3\nINPUT GRID:\nO G O O O O O O\nO O O A O O A O\nW O O O W O O O\nO O O O O O O B\nO R O X O F O O\nO O O O O O O O\nO G O O F O O G\nO O B O O A O O\nOUTPUT GRID:\nO G O O O O O O\nO O O O O O A O\nW O O O W O O O\nO O O A O O O B\nO O R X F O O O\nO O O O O O O O\nO G O O F O O G\nO O B O O A O O\n\n### EXPECTED OUTPUT\n{\n    \"nl_description\": \"Move all objects of color different than X, toward the object of color X, if they are neighbors of it.\",\n    \"code\": \"(do\\n    (rule\\n        (vars (this other))\\n        (filter\\n            (and\\n                (not (color_equals (color_of this) X))\\n                (and\\n                    (neighbor_of this other)\\n                    (color_equals (color_of other) X)\\n                )\\n            )\\n        )\\n        (apply\\n            (move_node_max (direction_of other))\\n        )\\n    )\\n)\"\n}\n\n\nNow follows task you will be evaluated on.\nOutput the solution as a JSON object, which should contain both a natural language description of the solution and the solution written in the DSL.\nThe code should be parseable by the DSL grammar.\nThe JSON must have the following structure:\n\n{\n    \"nl_description\": \"TO_BE_FILLED\",\n    \"code\": \"TO_BE_FILLED\"\n}\n\n## TEST TASK\n\nPAIR 1\nINPUT GRID:\nO O O O O O O O O\nO O O O O O O O O\nO O O O O O O O O\nO O R O O O O O O\nO O O O O O O O O\nO O O O O O O O O\nO O O O O O B O O\nO O O O O O O O O\nO O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O O\nO O O O O O O O O\nO Y O Y O O O O O\nO O R O O O O O O\nO Y O Y O O O O O\nO O O O O O A O O\nO O O O O A B A O\nO O O O O O A O O\nO O O O O O O O O\n\nPAIR 2\nINPUT GRID:\nO O O C O O O O O\nO O O O O O O O O\nO O O O O O R O O\nO O B O O O O O O\nO O O O O O O O O\nO O O O O O O O O\nO O O O O O B O O\nO R O O O O O O O\nO O O O O O O O O\nOUTPUT GRID:\nO O O C O O O O O\nO O O O O Y O Y O\nO O A O O O R O O\nO A B A O Y O Y O\nO O A O O O O O O\nO O O O O O A O O\nY O Y O O A B A O\nO R O O O O A O O\nY O Y O O O O O O\n\nPAIR 3\nINPUT GRID:\nO O O O O O O O O\nO O O O O O O O O\nO O R O O O O O O\nO O O O O O O O O\nO O O O O O O O O\nO O O O O O F O O\nO O O O O O O O O\nO O O B O O O O O\nO O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O O\nO Y O Y O O O O O\nO O R O O O O O O\nO Y O Y O O O O O\nO O O O O O O O O\nO O O O O O F O O\nO O O A O O O O O\nO O A B A O O O O\nO O O A O O O O O\n"
        }
    ],
    "n_valid_json": 100,
    "n_can_parse": 55,
    "completions": [
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert objects of color A in all 8 surrounding positions of neighbor objects of color different from the rest of object colors.",
            "code": "(do (rule (vars (this other)) (filter (neighbor_of this other)) (apply (insert this top_left source) (insert this top source) (insert this top_right source) (insert this left source) (insert this right source) (insert this bottom_left source) (insert this bottom source) (insert this bottom_right source))))",
            "can_parse": false,
            "parse_error_message": "No terminal matches 't' in the current parser context, at line 1 col 80\n\nneighbor_of this other)) (apply (insert this top_left source) (insert this top s\n                                        ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of size 1 toward the nearest neighboring same color objects, without overlapping, and then recolor them to color A.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (size_equals (size_of other) 1)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n            (update_color A)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (neighbor_of this other)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert objects of color A around all objects of size 1, recoloring inserted objects with interior neighbors of size 1 to Y.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (move_node up_right)\n            (insert 0 top_left)\n            (move_node down_left)\n            (insert 0 bottom_left)\n            (move_node down_right)\n            (insert 0 down_right)\n            (update_color A)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) A)\n                (and\n                    (neighbor_of this other)\n                    (size_equals (size_of other) 1)\n                )\n            )\n        )\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches ')' in the current parser context, at line 9 col 31\n\n            (insert 0 top_left)\n                              ^\nExpected one of: \n\t* RELATIVE_POSITION\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add a border with color 'A' to all objects and all cells of grid part of a cross-shape pattern will be colored in Yellow",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n            (apply\n                (add_border A)\n            )\n    )\n    (rule\n        (vars (this))\n        (filter)\n            (apply\n                (update_color Y)\n            )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert new objects to form an `A` pattern around each object.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (insert 1 top)\n            (insert 1 bottom)\n            (insert 1 left)\n            (insert 1 right)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches ')' in the current parser context, at line 6 col 26\n\n            (insert 1 top)\n                         ^\nExpected one of: \n\t* RELATIVE_POSITION\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add an object of color A next to objects of color B, then add objects of color Y surrounding any objects of color R.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) Y)\n                (color_equals (color_of other) R)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) A)\n                (color_equals (color_of other) B)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (neighbor_of this other)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Surround all objects of size 1 with color A.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (extend_node (direction_of this) false)\n            (update_color A)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Recolor all neighboring cells of any object to color Y, then recolor objects of size 1 to color A.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (update_color Y)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (update_color A)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an object of color A at the adjacent positions of objects of color different than O.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (not (color_equals (color_of other) O))\n        )\n        (apply\n            (insert A (img_pts_of this) adjacent)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'A' in the current parser context, at line 8 col 21\n\n            (insert A (img_pts_of this) adjacent)\n                    ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add the color Y around objects of certain non-specified colors and shapes.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (or\n                (color_equals (color_of this) R)\n                (and\n                    (color_equals (color_of this) B)\n                    (neighbor_of this this)\n                )\n            )\n        )\n        (apply\n            (add_border Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add 'A' borders on all objects and add 'Y' color diagonal lines around them.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (add_border A)\n            (mirror (mirror_axis_of this))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of size 1 toward the object closest to the center, without overlapping, and recolor each step to A.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (move_node up_right)\n            (update_color A)\n            (move_node down_left)\n            (update_color A)\n            (move_node up_left)\n            (update_color A)\n            (move_node down_right)\n            (update_color A)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an object of color A, diagonally adjacent to all objects of color A.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) A)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (insert (this other) (img_pts_of this) diag_right)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 11 col 21\n\n            (insert (this other) (img_pts_of this) diag_righ\n                    ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects in horizontal and vertical directions.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (extend_node left false)\n            (extend_node right false)\n            (extend_node up false)\n            (extend_node down false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert object A to all objects excluding R and B at the horizontal and vertical positions adjacent to the object.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (and\n                (not (color_equals (color_of this) R))\n                (not (color_equals (color_of this) B))\n            )\n        )\n        (apply\n            (insert 0 top true)\n            (insert 0 bottom true)\n            (insert 0 left true)\n            (insert 0 right true)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 't' in the current parser context, at line 11 col 27\n\n            (insert 0 top true)\n                          ^\nExpected one of: \n\t* RELATIVE_POSITION\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of size 1 towards the opposite corners, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (extend_node (down_right) false)\n            (extend_node (up_right) false)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'd' in the current parser context, at line 8 col 27\n\n            (extend_node (down_right) false)\n                          ^\nExpected one of: \n\t* DIRECTION_OF\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add a border of color Y to each grid cell of size 1 and update their color to A if their neighboring cells have a color.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (add_border Y)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n                (not (color_equals (color_of other) O))\n            )\n        )\n        (apply\n            (update_color A)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 17 col 17\n\n                (not (color_equals (color_of other) O))\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend the colored lines and recolor the intersected cells.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) O)\n                (or\n                    (neighbor_of this other)\n                    (not (color_equals (color_of other) O))\n                )\n            )\n        )\n        (apply\n            (add_border Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Surround all objects with a border of color A, except for the red objects on the upper side of the grid. Then, fill objects in the middle of the grid with color Y.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (or\n                (and\n                    (color_equals (color_of this) B)\n                    (column_equals (column_of this) 4)\n                )\n                (size_equals (size_of this) 1)\n            )\n        )\n        (apply\n            (add_border A)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (and\n                (not (color_equals (color_of this) R))\n                (not (color_equals (color_of this) A))\n            )\n        )\n        (apply\n            (fill_rectangle Y false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 to all adjacent cells, then change their color to A",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (move_node_max up)\n            (move_node_max down)\n            (move_node_max left)\n            (move_node_max right)\n            (update_color A)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Recolor all objects of size 1 to color A, and insert them in the middle of neighbors if applicable.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (update_color A)\n            (insert 0 (img_pts_of this) middle)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "For any object of size 1, surround it with objects of color Y in the four orthogonal directions (up, down, left, right).",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (insert 1 top \"Y\")\n            (insert 1 bottom \"Y\")\n            (insert 1 left \"Y\")\n            (insert 1 right \"Y\")\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '\"' in the current parser context, at line 8 col 27\n\n            (insert 1 top \"Y\")\n                          ^\nExpected one of: \n\t* RELATIVE_POSITION\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an auxiliary object of color A near objects that are not of color O.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (not (color_equals (color_of this) O))\n        )\n        (apply\n            (insert 1 top_left source)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert object A at the edges of objects not of color R or B, resulting in a cross patterned insertion around them.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) R))\n                (not (color_equals (color_of this) B))\n            )\n        )\n        (apply\n            (insert A (img_pts_of this) target)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'A' in the current parser context, at line 11 col 21\n\n            (insert A (img_pts_of this) target)\n                    ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of size 1 towards their neighbors, without overlapping. Then, recolor all non-overlapping extended nodes to color Y.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Surround all objects with color 'A' in the output",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (add_border A)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert a new object of color A at relative positions around objects that are neither R nor B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) R))\n                (not (color_equals (color_of this) B))\n            )\n        )\n        (apply\n            (insert 0 top_left source)\n            (insert 0 top_right source)\n            (insert 0 bottom_left source)\n            (insert 0 bottom_right source)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend objects of size 1 by adding yellow cells around them, except the objects which have size greater than 1.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (not (degree_equals (degree_of this) max))\n            )\n        )\n        (apply\n            (extend_node up_left false)\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add green border around objects that are not of colors O, G, T, U, Z and Z.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (this this))\n                (and\n                    (color_equals (other this))\n                    (size_equals (this this))\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )    \n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 't' in the current parser context, at line 6 col 31\n\n                (size_equals (this this))\n                              ^\nExpected one of: \n\t* SIZE_OF\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert objects of color A adjacent to non-black objects",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) O))\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (insert 1 (img_pts_of other) source)\n        )    \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert objects of color A all around the objects of size 1 that are neighbors to objects of maximum size.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (size_equals (size_of other) max)\n                )\n            )\n        )\n        (apply\n            (insert (this) (bottom_left) target)\n            (insert (this) (bottom_right) target)\n            (insert (this) (top_left) target)\n            (insert (this) (top_right) target)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 14 col 21\n\n            (insert (this) (bottom_left) target)\n                    ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an object of color A and size 2 diagonally adjacent to each existing object. If the target position is occupied, move the object to the nearest empty cell.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter)\n        (apply\n            (insert 1 (img_pts_of this) target)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert objects of size 1 in each gap in the grid, and recolor these inserted objects to color A.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (insert (size_of this) source)\n            (update_color A)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 21\n\n            (insert (size_of this) source)\n                    ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Surround the '+' intersection neighbors of each object with color Y, and insert object A in those neighbors.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (not (color_equals (color_of this) O))\n        )\n        (apply\n            (insert 1 (img_pts_of this) source)\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add neighbors colored A next to each non-background object, and switch the positions of the neighbors with objects located at even row coordinates.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (not (color_equals (color_of this) O))\n        )\n        (apply\n            (insert this top_left target)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (not (color_equals (color_of this) O))\n        )\n        (apply\n            (move_node this (direction_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 't' in the current parser context, at line 8 col 21\n\n            (insert this top_left target)\n                    ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert A at every empty cell that is a neighbor to a non-empty cell, and update color of non-empty nodes to Y if they are neighbors to another non-empty node.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) O)\n                (neighbor_of this other)\n                (not (color_equals (color_of other) O))\n            )\n        )\n        (apply\n            (insert 0 source middle)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) O))\n                (neighbor_of this other)\n                (not (color_equals (color_of other) O))\n            )\n        )\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (not (color_equals (color_of other) O))\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add color Y horizontally and vertically around all objects of color different than O, then replace color O with color A in remaining positions.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (not (color_equals (color_of this) O))\n        )\n        (apply\n            (extend_node up false)\n            (extend_node down false)\n            (extend_node left false)\n            (extend_node right false)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (update_color A)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 toward larger objects, then recount color to A, and fill empty spaces around to color Y.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n            (update_color A)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an object of color A to each corner of every object of size 1.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (insert 0 top_left source)\n            (insert 0 top_right source)\n            (insert 0 bottom_left source)\n            (insert 0 bottom_right source)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add a border of color A to all objects of color B, and then move all objects of size 1 to a neighboring position of the closest object of color R.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) B)\n        )\n        (apply\n            (add_border A)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n                (color_equals (color_of other) R)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 17 col 17\n\n                (color_equals (color_of other) R)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add objects of color Y adjacent to intersections without overlapping",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) O))\n                (not (color_equals (color_of other) O))\n            )\n        )\n        (apply\n            (insert 1 top_left source)\n            (insert 1 top_right source)\n            (insert 1 bottom_left source)\n            (insert 1 bottom_right source)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert objects of color Y around every object, except those of color R.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (not (color_equals (color_of this) R))\n        )\n        (apply\n            (insert 0 top source)\n            (insert 0 bottom source)\n            (insert 0 left source)\n            (insert 0 right source)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an object of color A around each B and then recolor the surrounding objects to yellow.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (color_equals (color_of this) B)\n        )\n        (apply\n            (insert 0 top_left source)\n            (insert 0 top source)\n            (insert 0 top_right source)\n            (insert 0 left source)\n            (insert 0 right source)\n            (insert 0 bottom_left source)\n            (insert 0 bottom source)\n            (insert 0 bottom_right source)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (color_equals (color_of other) A)\n        )\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color different than O, toward the direction of the object of color different than O, if they are neighbors of them; then recolor the cells along the way to color Y.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) O))\n                (and\n                    (neighbor_of this other)\n                    (not (color_equals (color_of other) O))\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Recolor all cells adjacent to any object to color Y, and then extend any cell with the new color Y outward without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter)\n        (apply\n            (update_color Y)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) Y)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 toward objects of size greater than 1, then recolor all objects of size 1 to color A.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (not (size_equals (size_of other) 1))\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (update_color A)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add objects of color A one step left and up around every object of size 1, and then recolor all objects to color Y.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n            )\n        )\n        (apply\n            (insert 1 (img_pts_of this) source)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches ')' in the current parser context, at line 7 col 13\n\n            )\n            ^\nExpected one of: \n\t* LPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add an orange border to all objects of color B, and add a yellow cross pattern around objects of color R.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) B)\n        )\n        (apply\n            (add_border A)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) R)\n        )\n        (apply\n            (insert 1 top_left source)\n            (insert 1 top_right source)\n            (insert 1 bottom_left source)\n            (insert 1 bottom_right source)\n            (insert 1 left source)\n            (insert 1 right source)\n            (insert 1 top source)\n            (insert 1 bottom source)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert object of color A at all four corners of objects of color B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (color_equals (color_of this) B)\n        )\n        (apply\n            (insert 0 top_left source)\n            (insert 0 top_right source)\n            (insert 0 bottom_left source)\n            (insert 0 bottom_right source)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert orange objects at the corners of all objects in the grid.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (insert 4 top_left source)\n            (insert 4 top_right source)\n            (insert 4 bottom_left source)\n            (insert 4 bottom_right source)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Highlight all neighbors of objects of size 1 except those of color X with color Y, and add 'A' objects at all their cross points.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (neighbor_of this other)\n        )\n        (apply\n            (update_color Y)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (insert 1 top_left source)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Surround all objects except the object with color R with objects of color Y, and surround the surroundings of these objects with object A.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n\t\t(and\n                (not (color_equals (color_of this) R))\n            )\n        )\n        (apply\n            (insert 1 here source)\n\t\t\t(insert 2 here source)\n\t\t\t(insert 3 here source)\n\t\t\t(insert 4 here source)\n\t\t\t(add_border Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches ')' in the current parser context, at line 7 col 13\n\n            )\n            ^\nExpected one of: \n\t* LPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add a border of color Y to each object of size 1. Replace instances of R with F.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter (size_equals (size_of this) 1))\n        (apply\n            (add_border Y)\n            (move_node (direction_of other))\n        )\n    )\n    (rule\n        (vars (this))\n        (filter (color_equals (color_of this) R))\n        (apply\n            (update_color F)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert yellow cells at L-shaped corners.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (height_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (size_equals (width_of other) 1)\n                )\n            )\n        )\n        (apply\n            (insert 0 left target)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'h' in the current parser context, at line 6 col 31\n\n                (size_equals (height_of this) 1)\n                              ^\nExpected one of: \n\t* SIZE_OF\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an A at the pixels around every B pixel. Insert a Y at the pixels in the same row as a B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of other) B)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (insert 5 (img_pts_of other) relative)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of other) B)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (insert 1 (img_pts_of other) relative)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'r' in the current parser context, at line 11 col 42\n\n           (insert 5 (img_pts_of other) relative)\n                                        ^\nExpected one of: \n\t* RELATIVE_POSITION\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add border to all objects with color not equal to O.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (not (color_equals (color_of this) O))\n        )\n        (apply\n            (add_border A)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add an outline of color A to the objects except for the ones having color R, B, or F, and then color the outline with color Y.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (and\n                (not (color_equals (color_of this) R))\n                (and\n                    (not (color_equals (color_of this) B))\n                    (not (color_equals (color_of this) F))\n                )\n            )\n        )\n        (apply\n            (add_border A)\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an object of color A at a specific position around every object of either color B, C, or F.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (or\n                (color_equals (color_of this) B)\n                (or\n                    (color_equals (color_of this) C)\n                    (color_equals (color_of this) F)\n                )\n            )\n        )\n        (apply\n            (insert 0 top_left middle)\n            (insert 0 top_right middle)\n            (insert 0 bottom_left middle)\n            (insert 0 bottom_right middle)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Recolor all cells neighboring cells of color R to color Y, except those already of color R or color B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of other) R)\n                (and\n                    (not (color_equals (color_of this) R))\n                    (not (color_equals (color_of this) B))\n                )\n            )\n        )\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (and\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Recolor all objects of size 1 and shape enclosed to color A, and then insert color Y in every white space adjacent to those objects.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (shape_equals (shape_of this) enclosed)\n            )\n        )\n        (apply\n            (update_color A)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of other) O)\n            )\n        )\n        (apply\n            (insert 0 top)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches ')' in the current parser context, at line 23 col 26\n\n            (insert 0 top)\n                         ^\nExpected one of: \n\t* RELATIVE_POSITION\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an object of color A of size 1 at all even row and column positions next to existing objects.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (or\n                    (column_equals (column_of this) even)\n                    (column_equals (column_of other) even)\n                )\n            )\n        )\n        (apply\n            (insert 1 bottom_right source)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert new objects and recolor them to Y surrounding all existing objects.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (or\n                (neighbor_of this other)\n                (not (color_equals (color_of this) O))\n            )\n        )\n        (apply\n            (insert 0 (img_pts_of this) source)\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert objects of color A diagonally adjacent to each object, and objects of color Y to the sides of each object, except if the object is B.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter (not (color_equals (color_of this) B)))\n        (apply\n            (insert 1 top_left)\n            (insert 1 top_right)\n            (insert 1 bottom_left)\n            (insert 1 bottom_right)\n            (insert 2 left)\n            (insert 2 right)\n            (insert 2 up)\n            (insert 2 down)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches ')' in the current parser context, at line 6 col 31\n\n            (insert 1 top_left)\n                              ^\nExpected one of: \n\t* RELATIVE_POSITION\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add alternating 'A' and 'Y' color toward empty spaces around objects, excluding objects of color 'R', 'B', 'C' and 'F'.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter \n            (and\n                (not (color_equals (color_of this) R))\n                (not (color_equals (color_of this) B))\n                (not (color_equals (color_of this) C))\n                (not (color_equals (color_of this) F))\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (update_color Y)\n            (move_node up)\n            (update_color A)\n            (move_node down)\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (not (color_equals (color_of this) C))\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add border of color Y to all objects, then recolor all size 1 objects to color A.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (add_border Y)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (update_color A)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add yellow `A` around each object that has exactly 1 neighbor. Add a grid pattern of `Y` around the existing grid.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter)\n        (apply\n            (and (extend_node right false) (update_color Y))\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (neighbor_of this other)\n        )\n        (apply\n            (insert 1 (img_pts_of other) source)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'a' in the current parser context, at line 6 col 14\n\n            (and (extend_node right false) (update_co\n             ^\nExpected one of: \n\t* TR_MIRROR\n\t* TR_MOVE_NODE\n\t* TR_NOOP\n\t* TR_MOVE_NODE_MAX\n\t* TR_HOLLOW_RECTANGLE\n\t* TR_FILL_RECTANGLE\n\t* TR_ROTATE_NODE\n\t* TR_EXTEND_NODE\n\t* TR_ADD_BORDER\n\t* TR_FLIP\n\t* TR_INSERT\n\t* TR_UPDATE_COLOR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert a yellow colored object at all the intersections of the objects on the grid",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter)\n        (apply\n            (insert this top_left source)\n            (insert this top_right source)\n            (insert this bottom_left source)\n            (insert this bottom_right source)\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 't' in the current parser context, at line 6 col 21\n\n            (insert this top_left source)\n                    ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Fill empty cells around a single-colored object with alternating Y and A colors.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (or\n                    (color_equals (color_of other) R)\n                    (or\n                        (color_equals (color_of other) B)\n                        (or\n                            (color_equals (color_of other) C)\n                            (color_equals (color_of other) F)\n                        )\n                    )\n                )\n            )\n        )\n        (apply\n            (extend_node down_left false)\n            (extend_node down_right false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an object of color A in all points that are both to the left, right, above, and below to any object of color R.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and (and (or (neighbor_of this other) (neighbor_of other this)) (color_equals (color_of other) R)) (color_equals (color_of this) O))\n        )\n        (apply\n            (insert A (img_pts_of this) source)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'A' in the current parser context, at line 8 col 21\n\n            (insert A (img_pts_of this) source)\n                    ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 toward the object of size 3, if they are neighbors of it, and then recolor them to color A if they end up being neighbors of the object with color R.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n                (size_equals (size_of other) 3)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of other) R)\n            )\n        )\n        (apply\n            (update_color A)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (size_equals (size_of other) 3)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add A in all cells that are neighbors of an object which is not of color O, and add Y alternately in cells which are two steps left or right from the object not of color O.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (not (color_equals (color_of this) O))\n        )\n        (apply\n            (move_node left)\n            (move_node left)\n            (update_color Y)\n            (move_node right)\n            (move_node right)\n            (update_color Y)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of other) O))\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (update_color A)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert a yellow object at the cardinal points adjacent to each object in the grid",
            "code": "(do\n(rule\n(vars (this))\n(filter (not (color_equals (color_of this) O)))\n(apply\n(insert (this this left) Y)\n(insert (this this right) Y)\n(insert (this this up) Y)\n(insert (this this down) Y)\n)))",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 6 col 9\n\n(insert (this this left) Y)\n        ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add a border to all objects of size 1 with color A or Y, then add a border to all objects of size 1 with color A.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (add_border A)\n            (add_border Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 up, and then recolor them to color A.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (move_node up)\n            (update_color A)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 to the surrounding empty cells and recolor them to color A. Recolor the empty cells to color Y.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (move_node (left))\n            (move_node (right))\n            (move_node (up))\n            (move_node (down))\n            (update_color A)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'l' in the current parser context, at line 8 col 25\n\n            (move_node (left))\n                        ^\nExpected one of: \n\t* DIRECTION_OF\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert objects of color A at one step diagonal from each non-center object in each row where there are two objects of different colors at the borders, then add yellow borders.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (or\n                (row_equals (row_of this) (row_of (other_of this))) true\n            )\n        )\n        (apply\n            (insert A source bottom_right)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (add_border Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'r' in the current parser context, at line 6 col 18\n\n                (row_equals (row_of this) (row_of (other_\n                 ^\nExpected one of: \n\t* SHAPE_EQ\n\t* OP_NOT\n\t* OP_AND\n\t* WIDTH_EQ\n\t* DEGREE_EQ\n\t* SIZE_EQ\n\t* COLUMN_EQ\n\t* COLOR_EQ\n\t* NEIGHBOR_OF\n\t* HEIGHT_EQ\n\t* OP_OR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "For each row, insert an object of color A in the middle and extend it horizontally as necessary. Then, for each column, insert an object of color Y in the middle and extend it vertically as necessary.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) B)\n                )\n            )\n        )\n        (apply\n            (insert A middle)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (color_equals (color_of this) A)\n        )\n        (apply\n            (extend_node right false)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n        )\n        (apply\n            (insert Y middle)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) Y)\n        )\n        (apply\n            (extend_node down false)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'A' in the current parser context, at line 14 col 21\n\n            (insert A middle)\n                    ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move objects of size 1 towards each other until they are adjacent, and recolor certain columns to yellow.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (not (neighbor_of this other))\n                    (exists (and\n                        (size_equals (size_of other) 1)\n                        (neighbor_of this other)\n                    ))\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (or\n                (column_equals (column_of this) 1)\n                (column_equals (column_of this) 3)\n                (column_equals (column_of this) 2)\n            )\n        )\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'e' in the current parser context, at line 9 col 22\n\n                    (exists (and\n                     ^\nExpected one of: \n\t* SHAPE_EQ\n\t* OP_NOT\n\t* OP_AND\n\t* WIDTH_EQ\n\t* DEGREE_EQ\n\t* SIZE_EQ\n\t* COLUMN_EQ\n\t* COLOR_EQ\n\t* NEIGHBOR_OF\n\t* HEIGHT_EQ\n\t* OP_OR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an object with color Y, in all empty spaces adjacent to an existing object, then recolor the new objects to color A.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) O)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (update_color Y)\n            (move_node (direction_of other))\n            (update_color A)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Surround all objects of size 1 with objects of size 2 with color Y.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (size_equals (size_of other) 2)\n                )\n            )\n        )\n        (apply\n            (insert 2 (img_pts_of this) source)\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an object of color A in the diagonal cells neighboring objects of color B and R, and recolor cells in the second and eighth columns with color Y.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (or\n                (color_equals (color_of this) R)\n                (color_equals (color_of this) B)\n            )\n        )\n        (apply\n            (insert 1 bottom_right source)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert a new object of size 1 in a different color next to objects of size 1 and then recolor the newly inserted objects.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (insert 1 (img_pts_of this) target)\n            (update_color A)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an object of size 1 A at every other object and recolor to Y.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (insert other (img_pts_of this) source)\n            (update_color Y)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (insert this (direction_of this) middle)\n            (update_color A)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'o' in the current parser context, at line 8 col 21\n\n            (insert other (img_pts_of this) source)\n                    ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert a horizontal pattern of color Y in all empty cells which are neighbors of other objects, then recolor all objects of size 1 to color A.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) O)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (update_color Y)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (update_color A)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert objects A and change color of cells adjacent horizontally and vertically to red objects to yellow",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (color_equals (color_of this) R)\n        )\n        (apply\n            (insert 1 (color_of other) target)\n            (update_color (neighbor_of this other) Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'c' in the current parser context, at line 8 col 24\n\n            (insert 1 (color_of other) target)\n                       ^\nExpected one of: \n\t* IMAGE_POINTS_OF\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add the color A around all objects and add the color Y around empty cells in certain conditions.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (add_border A)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) O)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 to their surrounding cells and recolor them to color A. If a row is full, recolor the next row to Y.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (move_node up_left)\n            (update_color A)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (or\n                (color_equals (color_of this) R)\n                (color_equals (color_of this) B)\n            )\n        )\n        (apply\n            (move_node up_left)\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an object of color A at the neighboring positions around objects of color B and C, and recolor the neighbors to Y.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter (or (color_equals (color_of this) B) (color_equals (color_of this) C)))\n        (apply\n            (insert 42 top_left source)\n            (insert 42 top_right source)\n            (insert 42 bottom_left source)\n            (insert 42 bottom_right source)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter (neighbor_of this other))\n        (apply (update_color Y))\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert instances of color A in the neighboring cells of the objects R, G, B, C, F and recolor the surrounding cells to color Y.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) R)\n        )\n        (apply\n            (insert A left neighbor)\n            (insert A right neighbor)\n            (update_color Y)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) B)\n        )\n        (apply\n            (insert A left neighbor)\n            (insert A right neighbor)\n            (update_color Y)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) C)\n        )\n        (apply\n            (insert A left neighbor)\n            (insert A right neighbor)\n            (update_color Y)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) F)\n        )\n        (apply\n            (insert A left neighbor)\n            (insert A right neighbor)\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'A' in the current parser context, at line 8 col 21\n\n            (insert A left neighbor)\n                    ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert objects with a three pixel border middle to the objects of size 3.",
            "code": "(do (rule (vars (this other)) (filter (size_equals (size_of this) 3)) (apply (insert (this) middle))) )",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 1 col 86\n\nquals (size_of this) 3)) (apply (insert (this) middle))) )\n                                        ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert object A at the middle points around other objects, coloring them Y.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (insert 1 middle)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'm' in the current parser context, at line 6 col 23\n\n            (insert 1 middle)\n                      ^\nExpected one of: \n\t* LPAR\n\t* IMAGE_POINTS\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert small cross objects of color A around every object in the grid, aligning its center to be a neighbor cell.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (insert 1 bottom_left middle)\n            (insert 1 bottom_right middle)\n            (insert 1 top_left middle)\n            (insert 1 top_right middle)\n            (insert 1 top middle)\n            (insert 1 bottom middle)\n            (insert 1 left middle)\n            (insert 1 right middle)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move every object of size 1 toward objects of size 3, recolor involved objects to color A, then Y if no connection exists.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (size_equals (size_of other) 3)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n            (update_color A)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (neighbor_of this other)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add objects of color A with a border of color Y to grid cells not occupied by existing objects.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter (size_equals (size_of this) 1))\n        (apply\n            (insert 0 top)\n            (update_color A)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter (size_equals (size_of this) 0))\n        (apply\n            (insert 0 top)\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches ')' in the current parser context, at line 6 col 26\n\n            (insert 0 top)\n                         ^\nExpected one of: \n\t* RELATIVE_POSITION\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert the color 'A' at each point adjacent to each object, then change all objects of color 'A' and 'Y'.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (add_border A)\n            (add_border Y)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert objects of size 1 around all objects.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (size_equals (size_of other) 1)\n        )\n        (apply\n            (insert (size_of this) (img_pts_of this) relative_position)\n        )    \n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 21\n\n            (insert (size_of this) (img_pts_of this) relativ\n                    ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an object of color A and size 1 diagonally next to all objects of size 1 and color other than R.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (not (color_equals (color_of this) R))\n            )\n        )\n        (apply\n            (insert (0) (img_pts_of this) source)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 11 col 21\n\n            (insert (0) (img_pts_of this) source)\n                    ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Add a border of color A to each object, then add Ys into all gaps between object columns.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (add_border A)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (insert X top center)\n            (update_color Y)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'X' in the current parser context, at line 13 col 21\n\n            (insert X top center)\n                    ^\nExpected one of: \n\t* OBJECT_ID\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert objects with color A around all objects of color B",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (color_equals (color_of other) B)\n        )\n        (apply\n            (insert 1 bottom_left source)\n            (insert 1 bottom_right source)\n            (insert 1 top_left source)\n            (insert 1 top_right source)\n            (insert 1 top source)\n            (insert 1 bottom source)\n            (insert 1 left source)\n            (insert 1 right source)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert an object of color A at positions diagonally adjacent to all objects of size 1, except at boundaries.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (insert 1 top_left source)\n            (insert 1 top_right source)\n            (insert 1 bottom_left source)\n            (insert 1 bottom_right source)\n        )\n    )\n)",
            "can_parse": true
        }
    ],
    "task_id": "0ca9ddb6"
}