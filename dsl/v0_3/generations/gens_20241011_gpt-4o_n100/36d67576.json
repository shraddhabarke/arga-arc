{
    "model": "gpt-4o-2024-05-13",
    "usage": {
        "completion_tokens": 13192,
        "prompt_tokens": 6206,
        "total_tokens": 19398,
        "prompt_tokens_details": {
            "cached_tokens": 0
        },
        "completion_tokens_details": {
            "reasoning_tokens": 0
        }
    },
    "request_time": 15.66913390159607,
    "n_requested": 100,
    "prompt_messages": [
        {
            "role": "system",
            "content": "You are an assistant chatbot with human-like perception, reasoning and learning capabilities.\nYou can solve tasks concisely, efficiently, and moreover, correctly.\nLet's engage in perception- and logic-based tasks.\nYou only output source code.\nNo explanations or any other text.\nOnly code."
        },
        {
            "role": "user",
            "content": "You are an efficient assistant for logical reasoning and code generation.\nYou will help me solve a visual perception and reasoning task.\nI will first provide you with the definition of a Domain Specific Language you will use for writing a solution for the task.\nI will then present you with the description of the task that you will be tested in.\nYou will then respond the queries I make regarding the solution of the task.\n\n\nThis is the definition of the DSL you will use to solve the task.\nIt is given as a context-free grammar in the EBNF format used by the Lark parser generator, with some informative comments about the semantics.\nYou will return a string that is parseable by the `program` non-terminal of the grammar.\n\n```\nlibrary: \"(\" program* \")\"\n\n// Rules are executed one after another, in the order they appear.\n// There could be no rules, in which case the program does nothing.\nprogram: \"(\" \"do\" rule* \")\"\n\n// First, it declares the variables that will be used in the filter and transform expressions.\n// Second, it defines a filter expression that an object must satisfy in order to be transformed.\n// Then, it defines a list of transforms that will be applied objects that satisfy the filter expression.\nrule: \"(\" \"rule\" decl filter xform_list \")\"\n\n// The `vars` declaration specifies the names of the variables that will be used in the filter and transform expressions.\n// The `this` variable is always declared, and it refers to the object that is being transformed.\n// There could also be an additional optional variable `other` that refers to another object in the grid,\n// which is not being transformed, but is used in the filter expression.\ndecl: \"(\" \"vars\" \"(\" VAR_THIS VAR_OTHER? \")\" \")\"\n\n// A filter is a predicate over the objects in the grid.\n// If no filter is given, then all the objects are selected.\nfilter: \"(\" \"filter\" filter_expr? \")\"\n\n// It can be a primitive filter operation, or a boolean expression using the `and`, `or`, and `not` connectives.\n// IMPORTANT: The `and` and `or` connectives are strictly binary, so to take the conjunction or disjunction \n// of more than two expressions, the binary connectives must be nested.\n// AGAIN, the `and` and `or` connectives are not variadic, so the following is not allowed:\n// (and true true false)\n// Instead, the following must be used:\n// (and true (and true false))\n// The `not` connective is unary as expected.\n// The objects that are transformed are the ones that satisfy the filter expression.\nfilter_expr: filter_prim\n           | \"(\" OP_AND filter_expr filter_expr \")\"   \n           | \"(\" OP_OR filter_expr filter_expr \")\"\n           | \"(\" OP_NOT filter_expr \")\"\n\nfilter_prim: \"(\" COLOR_EQ fcolor_expr fcolor_expr \")\"           \n           | \"(\" SIZE_EQ size_expr size_expr \")\"                \n           | \"(\" HEIGHT_EQ height_expr height_expr \")\"          \n           | \"(\" WIDTH_EQ width_expr width_expr \")\"             \n           | \"(\" DEGREE_EQ degree_expr degree_expr \")\"          \n           | \"(\" SHAPE_EQ shape_expr shape_expr \")\"             \n           | \"(\" COLUMN_EQ column_expr column_expr \")\"         \n           | \"(\" NEIGHBOR_OF VAR VAR \")\"      // true if the two objects are neighbors\n\n\n// Transforms are applied one after another, in the order they appear.\nxform_list: \"(\" \"apply\" xform+ \")\"\n\n// A single transform is applied to all the objects that are bound to the `this` variable. \n// The transform is applied to each such object independently and simultaneously.\nxform:     \"(\" TR_UPDATE_COLOR color_expr \")\"                          // change this object color to the given color \n         | \"(\" TR_MOVE_NODE direction_expr \")\"                         // move this object in the given direction\n         | \"(\" TR_EXTEND_NODE direction_expr OVERLAP \")\"               // extend (move while leaving a trail) this object in the given direction\n                                                                  // if overlap is false, then the object is extended until it hits another object,\n                                                                  // otherwise it is extended until the edge of the grid.\n         | \"(\" TR_MOVE_NODE_MAX direction_expr \")\"                     // move this object until it hits another object, in the given direction\n         | \"(\" TR_ROTATE_NODE ROT_ANGLE \")\"                       // rotate this object by the given angle\n         | \"(\" TR_ADD_BORDER color_expr \")\"                            // color this exterior pixels of the object with the given color\n         | \"(\" TR_FILL_RECTANGLE color_expr OVERLAP \")\"                // color this interior of a hollow rectangle with the given color\n         | \"(\" TR_HOLLOW_RECTANGLE color_expr \")\"                      // color this interior of a solid rectangle with the given color\n         | \"(\" TR_MIRROR mirror_expr \")\"\n         | \"(\" TR_FLIP SYMMETRY_AXIS \")\"                          // flip this object with respect to the given axis\n         | \"(\" TR_INSERT OBJECT_ID img_pts_expr RELATIVE_POSITION \")\" // insert a copy of this object at the position of the given object\n         | \"(\" TR_NOOP \")\"                                        // do nothing\n\nfcolor_expr: FCOLOR\n           | \"(\" COLOR_OF VAR \")\"\n\ncolor_expr: COLOR\n          | \"(\" COLOR_OF VAR \")\"\n\nsize_expr: SIZE\n         | \"(\" SIZE_OF VAR \")\"\n\nheight_expr: HEIGHT\n           | \"(\" HEIGHT_OF VAR \")\"\n\nwidth_expr: WIDTH\n          | \"(\" WIDTH_OF VAR \")\"\n\ndegree_expr: DEGREE\n           | \"(\" DEGREE_OF VAR \")\" \n\nshape_expr: SHAPE\n          | \"(\" SHAPE_OF VAR \")\"\n\ncolumn_expr: COLUMN\n           | \"(\" COLUMN_OF VAR \")\"\n\ndirection_expr: DIRECTION\n              | \"(\" DIRECTION_OF VAR \")\"\n\nimg_pts_expr: IMAGE_POINTS\n            | \"(\" IMAGE_POINTS_OF VAR \")\"\n\nmirror_expr: \"(\" MIRROR_AXIS_OF VAR \")\"\n\nOBJECT_ID: /[0-9]+/\nFCOLOR: \"O\" // black\n      | \"B\" // blue\n      | \"R\" // red\n      | \"G\" // green\n      | \"Y\" // yellow\n      | \"X\" // grey\n      | \"F\" // fuchsia\n      | \"A\" // orange\n      | \"C\" // cyan  \n      | \"W\" // brown\n\nSIZE: \"min\" | \"max\" | \"even\" | \"odd\" | /[0-9]+/  // size of objects\nDEGREE: \"min\" | \"max\" | \"even\" | \"odd\" | /[0-9]+/  // degree of objects\nHEIGHT: \"min\" | \"max\" | \"even\" | \"odd\" | /[0-9]+/  // height of objects\nWIDTH: \"min\" | \"max\" | \"even\" | \"odd\" | /[0-9]+/  // width of objects\nCOLUMN: \"center\" | \"even\" | \"odd\" | /[0-9]+/  // column of objects\nSHAPE: \"square\" | \"enclosed\"  // shape of objects\n\nDIRECTION: \"up\"\n         | \"down\"\n         | \"left\"\n         | \"right\"\n         | \"up_left\"\n         | \"up_right\"\n         | \"down_left\"\n         | \"down_right\"\n\nSYMMETRY_AXIS: \"vertical\" | \"horizontal\" | \"diagonal_left\" | \"diagonal_right\"\n\n// The angle of clockwise rotation, in degrees.\nROT_ANGLE: \"0\" \n         | \"90\" \n         | \"180\" \n         | \"270\"\n\nCOLOR: \"O\" // black\n      | \"B\" // blue\n      | \"R\" // red\n      | \"G\" // green\n      | \"Y\" // yellow\n      | \"X\" // grey\n      | \"F\" // fuchsia\n      | \"A\" // orange\n      | \"C\" // cyan  \n      | \"W\" // brown\n\nOVERLAP: BOOL\n\nBOOL: \"true\" | \"false\"\n\nIMAGE_POINTS: \"top\" | \"bottom\" | \"left\" | \"right\" | \"top_left\" | \"top_right\" | \"bottom_left\" | \"bottom_right\" \n\nRELATIVE_POSITION: \"source\"\n                 | \"target\"\n                 | \"middle\"\n\nVAR: VAR_THIS | VAR_OTHER\nVAR_THIS: \"this\"\nVAR_OTHER: \"other\"\n\nOP_AND: \"and\"\nOP_OR: \"or\"\nOP_NOT: \"not\"\n\nCOLOR_OF: \"color_of\"\nSIZE_OF: \"size_of\"\nHEIGHT_OF: \"height_of\"\nWIDTH_OF: \"width_of\"\nDEGREE_OF: \"degree_of\"\nSHAPE_OF: \"shape_of\"\nCOLUMN_OF: \"column_of\"\nDIRECTION_OF: \"direction_of\"\nIMAGE_POINTS_OF: \"img_pts_of\"\nMIRROR_AXIS_OF: \"mirror_axis_of\"\n\nCOLOR_EQ: \"color_equals\"\nSIZE_EQ: \"size_equals\"\nDEGREE_EQ: \"degree_equals\"\nHEIGHT_EQ: \"height_equals\"\nWIDTH_EQ: \"width_equals\"\nSHAPE_EQ: \"shape_equals\"\nCOLUMN_EQ: \"column_equals\"\nNEIGHBOR_OF: \"neighbor_of\"\n\nTR_UPDATE_COLOR: \"update_color\"\nTR_MOVE_NODE: \"move_node\"\nTR_EXTEND_NODE: \"extend_node\"\nTR_MOVE_NODE_MAX: \"move_node_max\"\nTR_ROTATE_NODE: \"rotate_node\"\nTR_ADD_BORDER: \"add_border\"\nTR_FILL_RECTANGLE: \"fill_rectangle\"\nTR_HOLLOW_RECTANGLE: \"hollow_rectangle\"\nTR_MIRROR: \"mirror\"\nTR_FLIP: \"flip\"\nTR_INSERT: \"insert\"\nTR_NOOP: \"noop\"\n\nCOMMENT: /\\s*/ \";;\" /[^\\n]/*\n\n%import common.WS\n%import common.LCASE_LETTER\n%import common.INT\n%ignore WS\n%ignore COMMENT\n```\n\n\nNow we continue with the visual perception and reasoning task.\nThe input for the task is a small number of pairs of grids of characters.\nThe value of each of the cells of the grids are the colors defined in the DSL, so we can think of grids as images.\nEach pair of images correspond to an input-output example for an unknown program P.\nFor each pair, the program P is evaluated on the image grid and operates on the objects that appear in it.\nThe output of the program is then the output image.\nThe objects in the images are easy and natural to identify for humans, so there is no need to define them explicitly.\nHowever you are able to abstract them correctly, and the DSL is interpreted with the same correct abstraction.\n\n\nNow I will show you some demonstration tasks along with the output you would be expected to produce for each of them.\n\n## DEMONSTRATION TASK 1\n\n### INPUT\nPAIR 1\nINPUT GRID:\nO O O O O O O O\nO O O O O R O O\nO R O O O R O R\nO R R O O R O O\nO O O O O O O O\nO R R O O O O O\nO R R O R R O O\nO O O O O O O O\nOUTPUT GRID:\nO O O O O O O O\nO O O O O Y O O\nO Y O O O Y O Y\nO Y Y O O Y O O\nO O O O O O O O\nO Y Y O O O O O\nO Y Y O Y Y O O\nO O O O O O O O\n\nPAIR 2\nINPUT GRID:\nO O O O O O O O O O\nO O O O R O O O O O\nO G O O R O O W O O\nO O G O O O W W O O\nO O G O O O O O O O\nO O O O X O O O O O\nO O O O O O F F F O\nO B O O O O O O O O\nO B B B B O O C C O\nO O O O O O O C O O\nOUTPUT GRID:\nO O O O O O O O O O\nO O O O Y O O O O O\nO Y O O Y O O Y O O\nO O Y O O O Y Y O O\nO O Y O O O O O O O\nO O O O Y O O O O O\nO O O O O O Y Y Y O\nO Y O O O O O O O O\nO Y Y Y Y O O Y Y O\nO O O O O O O Y O O\n\n### EXPECTED OUTPUT\n{\n    \"nl_description\": \"Recolor all objects to color Y\",\n    \"code\": \"(do\\n    (rule\\n        (vars (this))\\n        (filter)\\n        (apply\\n            (update_color Y)\\n        )\\n    )\\n)\"\n}\n\n\n## DEMONSTRATION TASK 2\n\n### INPUT\nPAIR 1\nINPUT GRID:\nO O O O O O O O\nO F F O O O R O\nO F F O O O O O\nO O O O O O O O\nO O O O O O O O\nO O O O O O O O\nO O A O O X X O\nO O O O O O O O\nOUTPUT GRID:\nO O O O O O O O\nO F F R R R R O\nO F F O O O O O\nO O A O O O O O\nO O A O O O O O\nO O A O O O O O\nO O A O O X X O\nO O O O O O O O\n\nPAIR 2\nINPUT GRID:\nO O O O O O O O O O\nO O O Y O G G G G O\nO O F O O G G G G O\nO O O O O O O O O O\nO O O O O O O O O O\nO O O O O O O O O O\nO C C C O O O O O O\nO C C C O O O O A O\nO C C C O O O X O O\nO O O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O O O\nO O O Y O G G G G O\nO O F Y O G G G G O\nO O F Y O O O O O O\nO O F Y O O O O O O\nO O F Y O O O O O O\nO C C C O O O O O O\nO C C C A A A A A O\nO C C C X X X X O O\nO O O O O O O O O O\n\n### EXPECTED OUTPUT\n{\n    \"nl_description\": \"Extend all the objects of size 1 toward the object of maximum size, without overlapping.\",\n    \"code\": \"(do\\n    (rule\\n        (vars (this other))\\n        (filter\\n            (and\\n                (size_equals (size_of this) 1)\\n                (and\\n                    (neighbor_of this other)\\n                    (size_equals (size_of other) max)\\n                )\\n            )\\n        )\\n        (apply\\n            (extend_node (direction_of other) false)\\n        )    \\n    )\\n)\"\n}\n\n\n## DEMONSTRATION TASK 3\n\n### INPUT\nPAIR 1\nINPUT GRID:\nO O O O O O O O O O\nO O O O O O O G O O\nO O G O O O O G O O\nO O G G O O O G G O\nO O O O O O O O O O\nO G G O O O O O O O\nO G G O O G G G O O\nO O O O O O O O O O\nO O G G O O O G O O\nO O O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O O O\nO O B O O O O G O O\nO O B B O O O G O O\nO O O O O O O G G O\nO O O O O O O O O O\nO G G O O B B B O O\nO G G O O O O O O O\nO O O O O O O O O O\nO O G G O O O G O O\nO O O O O O O O O O\n\nPAIR 2\nINPUT GRID:\nO O O O O O O O O O O O O O O O\nO O O O O O O O O O O O O G O O\nO B B O O O O O O C C C O G G O\nO O O O O F O O O O O O O O O O\nO O O O O F O O O O R R O O O O\nO O O O O F O O O O R R O O O O\nO O O O O O O O W O O O O O O O\nO O O A O O O W W O O O X O O O\nO O O A A O O W W O O O X X X O\nO O O O O O O O O O O O O O O O\nO O O O O O O O O O Y Y O O O O\nO O O O B O O O O O O O O O O O\nO Y O O B O O O G O O O O F F O\nO Y O O O O O O G O O O O F F O\nO Y Y Y O O O O G O O O O O O O\nO O O O O O O O O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O O O O O O B O O\nO O O O O O O O O B B B O B B O\nO B B O O B O O O O O O O O O O\nO O O O O B O O O O O O O O O O\nO O O O O B O O O O R R O O O O\nO O O O O O O O O O R R O O O O\nO O O B O O O O W O O O O O O O\nO O O B B O O W W O O O X O O O\nO O O O O O O W W O O O X X X O\nO O O O O O O O O O O O O O O O\nO O O O O O O O O O Y Y O O O O\nO O O O B O O O B O O O O O O O\nO Y O O B O O O B O O O O F F O\nO Y O O O O O O B O O O O F F O\nO Y Y Y O O O O O O O O O O O O\nO O O O O O O O O O O O O O O O\n\n### EXPECTED OUTPUT\n{\n    \"nl_description\": \"Move all objects of size 3 one step up, and then recolor them to color B.\",\n    \"code\": \"(do\\n    (rule\\n        (vars (this))\\n        (filter\\n            (size_equals (size_of this) 3)\\n        )\\n        (apply\\n            (move_node up)\\n            (update_color B)\\n        )\\n    )\\n)\"\n}\n\n\n## DEMONSTRATION TASK 4\n\n### INPUT\nPAIR 1\nINPUT GRID:\nO O O O R O O O A O\nO B O O O O B O O O\nO O O O O O O O O O\nO O O O X X X O O O\nO O O O X X X O O F\nW O O O O O O O O O\nO O F O O O Y O O O\nO O O O O O O O O O\nO O O O G O O O W O\nO O O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O A O\nO B O O O O O O O O\nO O O O R O B O O O\nO O O O X X X O O O\nO O O O X X X F O O\nW O O O G O Y O O O\nO O F O O O O O O O\nO O O O O O O O O O\nO O O O O O O O W O\nO O O O O O O O O O\n\nPAIR 2\nINPUT GRID:\nO O O F O O O R O O O O\nO O O O O O O O O Y O O\nO O O O O B O O O O O O\nO O R O O O O O G O O O\nB O O O O G O O O O O A\nO O O O O O R O O O W O\nO O O O O O O O C O O O\nG O X X O O O O O O O R\nO O X X O O O O O O Y O\nO O X X O O A O O O O O\nO F X X O O O O O O O O\nO O O O O Y O O O O O O\nOUTPUT GRID:\nO O O O O O O R O O O O\nO O O O O O O O O Y O O\nO O O O O B O O O O O O\nO O O O O O O O G O O O\nB O O O O G O O O O O A\nO O O O O O R O O O W O\nO O R F O O O O C O O O\nO G X X R O O O O O O O\nO O X X Y O O O O O O O\nO O X X A O O O O O O O\nO F X X O O O O O O O O\nO O O O O Y O O O O O O\n\nPAIR 3\nINPUT GRID:\nO G O O O O O O\nO O O A O O A O\nW O O O W O O O\nO O O O O O O B\nO R O X O F O O\nO O O O O O O O\nO G O O F O O G\nO O B O O A O O\nOUTPUT GRID:\nO G O O O O O O\nO O O O O O A O\nW O O O W O O O\nO O O A O O O B\nO O R X F O O O\nO O O O O O O O\nO G O O F O O G\nO O B O O A O O\n\n### EXPECTED OUTPUT\n{\n    \"nl_description\": \"Move all objects of color different than X, toward the object of color X, if they are neighbors of it.\",\n    \"code\": \"(do\\n    (rule\\n        (vars (this other))\\n        (filter\\n            (and\\n                (not (color_equals (color_of this) X))\\n                (and\\n                    (neighbor_of this other)\\n                    (color_equals (color_of other) X)\\n                )\\n            )\\n        )\\n        (apply\\n            (move_node_max (direction_of other))\\n        )\\n    )\\n)\"\n}\n\n\nNow follows task you will be evaluated on.\nOutput the solution as a JSON object, which should contain both a natural language description of the solution and the solution written in the DSL.\nThe code should be parseable by the DSL grammar.\nThe JSON must have the following structure:\n\n{\n    \"nl_description\": \"TO_BE_FILLED\",\n    \"code\": \"TO_BE_FILLED\"\n}\n\n## TEST TASK\n\nPAIR 1\nINPUT GRID:\nO O O O O O O O O O O O O\nO O B O B R O O O O O O O\nO Y Y Y Y Y O O O O Y O O\nO G O G O G O O O O Y O O\nO O O O O O O O O O Y O O\nO O O O O O O O O O Y O O\nO O O O O O O O O O Y R O\nO O O O O O O O O O O O O\nO O O Y Y Y Y Y O O O O O\nO O O R O O O O O O O O O\nO O O O O O O O O O O O O\nO O O O O O O O O O O O O\nO O O O O O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O O O O O O\nO O B O B R O O O O O O O\nO Y Y Y Y Y O O O G Y O O\nO G O G O G O O O O Y B O\nO O O O O O O O O G Y O O\nO O O O O O O O O O Y B O\nO O O O O O O O O G Y R O\nO O O G O G O G O O O O O\nO O O Y Y Y Y Y O O O O O\nO O O R B O B O O O O O O\nO O O O O O O O O O O O O\nO O O O O O O O O O O O O\nO O O O O O O O O O O O O\n\nPAIR 2\nINPUT GRID:\nO O O O O O O O O O O O O\nO O O O R O O O O O O O O\nO O Y Y Y B O O O O O O O\nO O O O Y O O O O O O O O\nO O G G Y G O O O R O O O\nO O O O O O O O O Y Y Y O\nO O O O O O O O O Y O O O\nO O O O O O O O O Y O O O\nO O O O O O O O O O O O O\nO O O O O Y O O O O O O O\nO O O O O Y O O O O O O O\nO O O Y Y Y R O O O O O O\nO O O O O O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O O O O O O\nO O O O R O O O O O O O O\nO O Y Y Y B O O O O O O O\nO O O O Y O O O O O O O O\nO O G G Y G O O O R O O O\nO O O O O O O O B Y Y Y O\nO O O O O O O O O Y O O O\nO O O O O O O O G Y G G O\nO O O O O O O O O O O O O\nO O O G O Y O O O O O O O\nO O O G O Y O O O O O O O\nO O O Y Y Y R O O O O O O\nO O O G O B O O O O O O O\n\nPAIR 3\nINPUT GRID:\nO O O O O O O O O O O O O\nO O O Y R O O O O O O O O\nO B Y Y Y O O O O O O O O\nO O G Y O O O O O O O O O\nO O O B O O O O O O O O O\nO O O O O O O R Y O O O O\nO O O O O O O Y Y Y O O O\nO O O O O O O O Y O O O O\nO O O O O O O O O O O O O\nO O O O Y O O O O O O O O\nO O O Y Y Y O O O O O O O\nO O O R Y O O O O O O O O\nO O O O O O O O O O O O O\nOUTPUT GRID:\nO O O O O O O O O O O O O\nO O O Y R O O O O O O O O\nO B Y Y Y O O O O O O O O\nO O G Y O O O O O O O O O\nO O O B O O O O O O O O O\nO O O O O O O R Y O O O O\nO O O O O O O Y Y Y B O O\nO O O O O O O O Y G O O O\nO O O O B O O O B O O O O\nO O O O Y G O O O O O O O\nO O O Y Y Y B O O O O O O\nO O O R Y O O O O O O O O\nO O O O O O O O O O O O O\n"
        }
    ],
    "n_valid_json": 100,
    "n_can_parse": 78,
    "completions": [
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 toward the object of maximum size, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (size_equals (size_of other) max)\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )    \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 one step toward the nearest object, and recolor them to color B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move objects of size 1 toward objects of size greater than 1 if they are neighbors, and recolor them with B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (not (size_equals (size_of other) 1))\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects to their nearest neighbor's position if it has a different color, and add a border with color B to the objects.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) (color_of other)))\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n            (add_border B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move the trailing end of objects of size 6 and color Y to the nearest neighboring object of color G, B, or R.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 6)\n                (color_equals (color_of this) Y)\n                (and\n                    (neighbor_of this other)\n                    (or\n                        (color_equals (color_of other) G)\n                        (or\n                            (color_equals (color_of other) B)\n                            (color_equals (color_of other) R)\n                        )\n                    )\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (and\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Recolor all objects of size 1 to color B, move all objects of size 2 one step up, and move all objects of size 7 towards the rightmost column containing Y.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (update_color B)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 2)\n        )\n        (apply\n            (move_node up)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 7)\n                (column_equals (column_of this) (column_of other))\n                (color_equals (color_of other) Y)\n            )\n        )\n        (apply\n            (move_node right)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 26 col 17\n\n                (color_equals (color_of other) Y)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move nodes adjacent to the color Y diagonally towards Y",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of this) O)\n                (color_equals (color_of other) Y)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of other) Y)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all the green objects one step down, then recolor them to blue.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) G)\n        )\n        (apply\n            (move_node down)\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color R one step to the right, G one step to the left, B one step down, and Y one step up.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) R)\n        )\n        (apply\n            (move_node right)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) G)\n        )\n        (apply\n            (move_node left)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) B)\n        )\n        (apply\n            (move_node down)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) Y)\n        )\n        (apply\n            (move_node up)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Create green objects in the same shape and position as the existing green objects, and recolor the existing green objects to blue.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) G)\n        )\n        (apply\n            (insert 1 (img_pts_of this) target)\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move neighbors of object B in the direction of B and recolor moved objects to B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (neighbor_of this other)\n        )\n        (apply\n            (move_node (direction_of other))\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 3 towards the object of color R if they are neighbors of it.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 3)\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) R)\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 2 toward the nearest objects of color G, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 2)\n                (neighbor_of this other)\n                (color_equals (color_of other) G)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of other) G)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all the G objects to the left and color them with B and move all the B objects to the right and color them with G",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter (and (color_equals (color_of this) G) (neighbor_of this other)))\n        (apply\n            (move_node left)\n            (update_color B)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter (color_equals (color_of this) B))\n        (apply\n            (move_node right)\n            (update_color G)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects towards the bottom-most object while changing their colors.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (neighbor_of this other)\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n    (rule\n        (vars (this))\n        (filter)\n        (apply\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 toward the nearest cell to form the boundary of the maximum sized object, if they are neighbors of it. Then, recolor objects of size 4 to color G, objects of size 5 to color B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (size_equals (size_of other) max)\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 4)\n        )\n        (apply\n            (update_color G)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 5)\n        )\n        (apply\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert color B objects next to the existing objects in the grid.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter)\n            (apply\n                (insert 1 top right)\n            )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches 'r' in the current parser context, at line 6 col 31\n\n                (insert 1 top right)\n                              ^\nExpected one of: \n\t* RELATIVE_POSITION\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color B one step down and move all objects that are neighbors of the object of color G toward the object of color G.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) B)\n        )\n        (apply\n            (move_node down)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of other) G)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Fill all the interiors of the hollow rectangles with color B.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (shape_equals (shape_of this) enclosed)\n        )\n        (apply\n            (fill_rectangle B false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all single-pixel objects or adjacent pairs up or down, towards the nearest largest object of the grid.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (or\n                    (size_equals (size_of this) 1)\n                    (size_equals (size_of this) 2)\n                )\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 toward the object of maximum size, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (size_equals (size_of other) max)\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )    \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 2 in the up direction and recolor them to color B.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 2)\n        )\n        (apply\n            (move_node up)\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color G towards the neighboring object to their right, while maintaining the same color",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) G)\n                (neighbor_of this other)\n                (or\n                    (color_equals (color_of other) B)\n                    (color_equals (color_of other) R)\n                    (color_equals (color_of other) Y)\n                )\n            )\n        )\n        (apply\n            (move_node right)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (or\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move objects towards objects of color G if they are neighbors and then recolor moved objects to B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of other) G)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 toward the nearby object of color G, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) G)\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 towards objects of size 3 they are neighbors of, and then recolor the objects of size 3 to color B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (size_equals (size_of other) 3)\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 3)\n        )\n        (apply\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects toward the nearest green object if they are neighbors of it.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of other) G)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all B objects one step toward the pattern G-Y if they are neighbors of it.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) B)\n                (neighbor_of this other)\n                (or\n                    (color_equals (color_of other) G)\n                    (color_equals (color_of other) Y)\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (or\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "If there is a G object that has neighboring B objects, move the B objects toward the G object until they hit another object, and then recolor them to color B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) B)\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) G)\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move objects of size 1 and color R or B towards the nearest object of color G without overlapping, recoloring them to color B when they move.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (or\n                    (color_equals (color_of this) R)\n                    (color_equals (color_of this) B)\n                )\n                (neighbor_of this other)\n                (color_equals (color_of other) G)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n            (update_color B)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 11 col 17\n\n                (neighbor_of this other)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color different than Y, toward the object of color Y, if they are neighbors of it.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) Y))\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) Y)\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move the blue objects downwards while adding green objects with similar locations.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) B)\n        )\n        (apply\n            (move_node down)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) B)\n                (size_equals (size_of this) 1)\n                (color_equals (color_of other) O)\n            )\n        )\n        (apply\n            (insert this (img_pts_of this) source)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 17 col 17\n\n                (color_equals (color_of other) O)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all the objects of size 1 towards the closest neighbor, changing their color to B after moving.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects after the Y objects, maintaining their relative order. Then move them up to touch the Y objects.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (column_equals (column_of this) (column_of other))\n                (color_equals (color_of other) Y)\n            )\n        )\n        (apply\n            (move_node_max up)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all blue objects one step down.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) B)\n        )\n        (apply\n            (move_node down)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color that is not O, to the nearest object of color O.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) O))\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 toward the objects of the same color, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n                (color_equals (color_of this) (color_of other))\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of this) (color_of \n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 towards the object of size 6, without overlapping, and then move objects of size 2 towards objects of size 4, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (size_equals (size_of other) 6)\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 2)\n                (and\n                    (neighbor_of this other)\n                    (size_equals (size_of other) 4)\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 3 one step down, and then recolor them to color B.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 3)\n        )\n        (apply\n            (move_node down)\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Swap objects of color G with objects of color B.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) G)\n        )\n        (apply\n            (update_color B)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) B)\n        )\n        (apply\n            (update_color G)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color B one step down.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) B)\n        )\n        (apply\n            (move_node down)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move blue objects upward if they are neighbors of green objects.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) B)\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) G)\n                )\n            )\n        )\n        (apply\n            (move_node up)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color B to the nearest G in the grid.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) B)\n                (color_equals (color_of other) G)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move objects of color different than Y and size 1 towards the objects of color G, and objects of size 1 towards the objects of color B",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) G)\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) Y))\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) G)\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 toward the nearest neighboring object, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all blue objects towards green objects if they are neighbors, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) B)\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) G)\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )    \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 toward the nearest object of size even, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n                (size_equals (size_of other) even)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (size_equals (size_of other) even)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color B one step down and then recolor them to color B.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) B)\n        )\n        (apply\n            (move_node down)\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 2 toward the nearest object of size greater than 2, if they are neighbors.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 2)\n                (and\n                    (neighbor_of this other)\n                    (not (size_equals (size_of other) 2))\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects that are neighbors of objects of color Y towards them.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of other) Y)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color 'B' towards the object of maximum size if they are neighbors of it.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) B)\n                (and\n                    (neighbor_of this other)\n                    (size_equals (size_of other) max)\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color different than O, once step down, then if the moved object is Green, move it one step up or down until it reaches an object B.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (not (color_equals (color_of this) O))\n        )\n        (apply\n            (move_node down)\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and \n                (color_equals (color_of this) G)\n                (neighbor_of this other)\n                (color_equals (color_of other) B)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 17 col 17\n\n                (color_equals (color_of other) B)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move every 'G' object one step up",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) G)\n        )\n        (apply\n            (move_node up)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move next to green all the blue objects which are neighboring yellow ones.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) B)\n                (neighbor_of this other)\n                (color_equals (color_of other) Y)\n            )\n        )\n        (apply\n            (move_node_max right)\n            (move_node_max down)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of other) Y)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects to the nearest neighboring objects of color different from 'O', and recolor to 'B' if they are neighbors.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of other) O))\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 towards the nearest objects of size greater than 1",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 toward the closest green object if they are neighbors of it.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) G)\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )    \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 one step down, and then recolor them to color B.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (move_node down)\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of degree 1 to their neighbors of degree greater than 1.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (degree_equals (degree_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (not (degree_equals (degree_of other) 1))\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert objects of size 1 of the same color, around the largest objects in the grid.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n                (size_equals (size_of other) max)\n            )\n        )\n        (apply\n            (insert (color_of this) source true)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (size_equals (size_of other) max)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color B toward the nearest object of color G.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) B)\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) G)\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all the objects of color different than O, that are neighbors of object G, towards G.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (and\n                    (color_equals (color_of other) G)\n                    (not (color_equals (color_of this) O))\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move objects of size 1 towards the nearest object of size 6, and then recolor objects of color G to color B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (size_equals (size_of other) 6)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) G)\n        )\n        (apply\n            (update_color B)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (neighbor_of this other)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all square objects in the grid one step down, and recolor the smallest sized objects to color B.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (shape_equals (shape_of this) square)\n        )\n        (apply\n            (move_node down)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) min)\n        )\n        (apply\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move objects with neighbor of color G towards G and change moved object's color to B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (color_equals (color_of other) G)\n        )\n        (apply\n            (move_node (direction_of other))\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 to their right until they hit another object.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (move_node_max right)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 in the direction of the neighboring object, then recolor to B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color different than O and B down if their neighbors below are objects of color O, and recolor them with object B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) O))\n                (and\n                    (not (color_equals (color_of this) B))\n                    (neighbor_of this other)\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 toward other neighboring objects, and recolor them to color B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move objects of size 1 toward the objects of size greater than 1 that are their neighbors.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n                (not (size_equals (size_of other) 1))\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (not (size_equals (size_of other) 1))\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color different than O towards the nearest object of color O if they are neighbors of it, then move all B-colored objects in random directions.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) O))\n                (neighbor_of this other)\n                (color_equals (color_of other) O)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) B)\n        )\n        (apply\n            (move_node left)\n            (move_node right)\n            (move_node up)\n            (move_node down)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of other) O)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 toward the object of size 3, if they are neighbors of it",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (size_equals (size_of other) 3)\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Recolor the border neighbors of green objects to the color of their neighboring green object.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of other) G)\n            )\n        )\n        (apply\n            (update_color (color_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 towards the nearest blue object, and then shift them down or left if needed to avoid overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (neighbor_of this other)\n                (color_equals (color_of other) B)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (color_equals (color_of this) B)\n                (neighbor_of this other)\n                (color_equals (color_of other) Y)\n            )\n        )\n        (apply\n            (move_node down)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of other) B)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all isolated objects (objects that are not neighbours of any other object) of any size to the bottom-most unoccupied cell of their respective columns, and colours all objects to their original colours.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (not (neighbor_of this other))\n        )\n        (apply\n            (move_node_max down)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move the objects colored G or B to the cells adjacent to them.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (or (color_equals (color_of this) G)\n                (color_equals (color_of this) B))\n        )\n        (apply\n            (move_node (direction_of this))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color G toward the objects of color B, if they are neighbors of it.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) G)\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) B)\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert B objects at the position of G objects.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (color_equals (color_of this) G)\n        )\n        (apply\n            (insert 1 (img_pts_of this) target)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 in the direction of the object of color X.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (size_equals (size_of this) 1)\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move green (G) objects towards neighboring yellow (Y) objects.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) G)\n                (neighbor_of this other)\n                (color_equals (color_of other) Y)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of other) Y)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color G one step down, and then recolor them to color B.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) G)\n        )\n        (apply\n            (move_node down)\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move objects toward nearest G, recolor moving objects to B and recolor G to remaining object's color.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of other) G)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n            (update_color B)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) G)\n        )\n        (apply\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects towards the object of color G, if they are neighbors of it.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (neighbor_of this other)\n                (color_equals (color_of other) G)\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects with size greater than 1 towards the nearest object of color G",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 2)\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) G)\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 3)\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) G)\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move the isolated blue objects to the top row and retain their positions.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) B)\n                (not (neighbor_of this other))\n            )\n        )\n        (apply\n            (move_node up)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color different than G, toward the nearest object of color G, if they are neighbors of it, and then recolor them to color B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) G))\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) G)\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n            (update_color B)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 toward the object of size 3, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (size_equals (size_of other) 3)\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )    \n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 and 2 towards the nearest neighbor object of size greater than them, without overlapping, and change their position in the grid accordingly.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (or\n                    (size_equals (size_of this) 1)\n                    (size_equals (size_of this) 2)\n                )\n                (and\n                    (neighbor_of this other)\n                    (or\n                        (size_equals (size_of other) 3)\n                        (size_equals (size_of other) 6)\n                    )\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color different than O downward whenever they have a neighbor of color O.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) O))\n                (neighbor_of this other)\n                (color_equals (color_of other) O)\n            )\n        )\n        (apply\n            (move_node down)\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of other) O)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color different than O toward the nearest neighbors of color O until they hit objects of color O.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) O))\n                (neighbor_of this other)\n                (color_equals (color_of other) O)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of other) O)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of size 1 to the nearest object of size greater than 1, if they are neighbors.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (size_equals (size_of this) 1)\n                (and\n                    (neighbor_of this other)\n                    (not (size_equals (size_of other) 1))\n                )\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all cyan (Y) and orange (A) objects one step down, and then recolor them to corresponding colors B and G.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (or\n                (color_equals (color_of this) Y)\n                (color_equals (color_of this) A)\n            )\n        )\n        (apply\n            (move_node down)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) Y)\n        )\n        (apply\n            (update_color B)\n        )\n    )\n    (rule\n        (vars (this))\n        (filter\n            (color_equals (color_of this) A)\n        )\n        (apply\n            (update_color G)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color different than G toward the objects of color G, if they are neighbors of it.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) G))\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) G)\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color different than O toward the left or bottom side of the grid.",
            "code": "(do\n    (rule\n        (vars (this))\n        (filter\n            (not (color_equals (color_of this) O))\n        )\n        (apply\n            (move_node left)\n            (move_node down)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects of color B toward the nearest object of color G.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) B)\n                (neighbor_of this other)\n                (color_equals (color_of other) G)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": false,
            "parse_error_message": "No terminal matches '(' in the current parser context, at line 8 col 17\n\n                (color_equals (color_of other) G)\n                ^\nExpected one of: \n\t* RPAR\n"
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move objects of color G towards down or right direction based on matching Y's column in the same row.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (color_equals (color_of this) G)\n                (neighbor_of this other)\n            )\n        )\n        (apply\n            (move_node_max (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all the objects of shape enclosed toward the nearest neighboring blue object, without overlapping.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (shape_equals (shape_of this) enclosed)\n                (and\n                    (neighbor_of this other)\n                    (color_equals (color_of other) B)\n                )\n            )\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Extend all objects of color different than O, towards the nearest neighboring object, if they are not already touching.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (and\n                (not (color_equals (color_of this) O))\n                (and\n                    (neighbor_of this other)\n                    (not (neighbor_of this this))\n                )\n            )\n        )\n        (apply\n            (extend_node (direction_of other) false)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Insert new objects of different colors so that all rows with objects of color Y are balanced by color insertion.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (color_equals (color_of this) Y)\n        )\n        (apply\n            (insert 1 top_right source)\n            (insert 2 top_left source)\n            (insert 3 bottom_left source)\n            (insert 4 bottom_right source)\n        )\n    )\n)",
            "can_parse": true
        },
        {
            "finish_reason": "stop",
            "valid_json": true,
            "nl_description": "Move all objects towards the nearest neighboring object of color B.",
            "code": "(do\n    (rule\n        (vars (this other))\n        (filter\n            (neighbor_of this other)\n        )\n        (apply\n            (move_node (direction_of other))\n        )\n    )\n)",
            "can_parse": true
        }
    ],
    "task_id": "36d67576"
}