[
    {
        "task_id": "google_01",
        "completions": [
            "\ndef convert_index_tensor(input_tensor):\n    unique, idx, counts = tf.unique_with_counts(input_tensor)\n    repeated_indices = tf.repeat(unique, counts)\n    reshaped_indices = tf.reshape(repeated_indices, (-1, 2))\n    return reshaped_indices\n\ninput_tensor = tf.constant([0, 0, 0, 1, 3, 3])\noutput_tensor = convert_index_tensor(input_tensor)\n",
            "\ndef index_to_pairs(indices):\n    unique_elements, _, counts = tf.unique_with_counts(indices)\n    indices_range = tf.range(tf.reduce_sum(counts))\n    counts_range = tf.repeat(tf.range(tf.size(counts)), counts)\n    return tf.stack([tf.gather(unique_elements, counts_range), indices_range], axis=-1)\n",
            "\ndef index_to_pairs(index):\n    y, idx, count = tf.unique_with_counts(index)\n    return tf.stack([tf.repeat(y, count), tf.concat([tf.range(c) for c in count], axis=0)], axis=1)\n\nindex = tf.constant([0, 0, 0, 1, 3, 3])\n",
            "\ndef index_to_pairs(index_tensor):\n    unique_elements, _, counts = tf.unique_with_counts(index_tensor)\n    ranges = tf.map_fn(tf.range, counts, dtype=tf.int32)\n    pairs = tf.stack([tf.repeat(unique_elements, counts), tf.concat(ranges, axis=0)], axis=1)\n    return pairs\n",
            "\ndef convert_indices_to_pairs(indices):\n    unique_indices, _, counts = tf.unique_with_counts(indices)\n    pairs = tf.stack([unique_indices, counts], axis=1)\n    return pairs\n\nindices = tf.constant([0, 0, 0, 1, 3, 3])\npairs = convert_indices_to_pairs(indices)\n",
            "\ndef generate_pairs(indices):\n    unique, counts = tf.unique_with_counts(indices)\n    pairs = tf.stack([tf.repeat(unique, counts), tf.range(tf.reduce_sum(counts))], axis=1)\n    return pairs\n\nindices = tf.constant([0, 0, 0, 1, 3, 3])\n",
            "\nindices = [0, 0, 0, 1, 3, 3]\nindices_tensor = tf.constant(indices, dtype=tf.int64)\nsequence_tensor = tf.range(tf.shape(indices_tensor)[0], dtype=tf.int64)\npairs = tf.stack([sequence_tensor, indices_tensor], axis=1)\n",
            "\ndef convert_indices(input_tensor):\n    range_tensor = tf.range(tf.shape(input_tensor)[0])\n    return tf.stack([input_tensor, range_tensor], axis=1)\n",
            "\ndef index_to_pairs(indices):\n    unique_elements, _, counts = tf.unique_with_counts(indices)\n    sequence_tensors = [tf.range(count) for count in counts]\n    pairs = tf.stack([tf.repeat(element, count) for element, count in zip(unique_elements, counts)], axis=1)\n    return tf.transpose(pairs)\n",
            "\ndef index_to_pairs(indices):\n    y, idx, count = tf.unique_with_counts(indices)\n    pairs = tf.transpose(tf.stack([y, count - 1]))\n    return pairs\n\nindices = tf.constant([0, 0, 0, 1, 3, 3], dtype=tf.int32)\noutput = index_to_pairs(indices)\n"
        ],
        "target-program": "tf.cast(tf.where(tf.sequence_mask(tf.math.bincount(in1))), tf.int32)",
        "description": "Convert index tensor into pairs for SparseTensor indexing",
        "tf_operators": {
            "tf.repeat": 6,
            "tf.reshape": 1,
            "tf.unique_with_counts": 8,
            "tf.constant": 6,
            "tf.stack": 9,
            "tf.gather": 1,
            "tf.reduce_sum": 2,
            "tf.size": 1,
            "tf.range": 7,
            "tf.concat": 2,
            "tf.map_fn": 1,
            "tf.int32": 2,
            "tf.int64": 1,
            "tf.shape": 2,
            "tf.transpose": 2
        },
        "coverage_percentage": 20.0,
        "total_in_target": 5,
        "total_covered": 1
    },
    {
        "task_id": "google_02",
        "completions": [
            "\ndata = [[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]]\n\ndata_tensor = tf.constant(data)\n\nrow_sums = tf.reduce_sum(data_tensor, axis=1)\n\nrow_sums_expanded = tf.expand_dims(row_sums, 1)\n\noutput = tf.divide(data_tensor, row_sums_expanded)\n\n",
            "\ndata = [[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]]\n\ndata_tensor = tf.convert_to_tensor(data)\n\nsums = tf.reduce_sum(data_tensor, axis=1)\n\nsums_expanded = tf.expand_dims(sums, -1)\n\noutput = tf.divide(data_tensor, sums_expanded)\n\n",
            "\ndata = [[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]]\n\ntensor = tf.constant(data)\n\nrow_sums = tf.reduce_sum(tensor, axis=1, keepdims=True)\n\nresult = tf.divide(tensor, row_sums)\n\n",
            "\ndata = [[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]]\n\ntensor = tf.constant(data)\n\nrow_sums = tf.reduce_sum(tensor, axis=1)\n\nrow_sums = tf.reshape(row_sums, [-1, 1])\n\noutput = tf.divide(tensor, row_sums)\n\n",
            "\ndata = tf.constant([[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]])\n\nrow_sum = tf.reduce_sum(data, axis=1, keepdims=True)\n\noutput = tf.divide(data, row_sum)\n\n",
            "\ndata = [[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]]\n\ndata_tensor = tf.constant(data)\n\nrow_sum = tf.reduce_sum(data_tensor, axis=1)\n\nrow_sum_reshaped = tf.reshape(row_sum, (-1, 1))\n\noutput = tf.divide(data_tensor, row_sum_reshaped)\n\n",
            "\ndata = [[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]]\n\ntensor_data = tf.constant(data)\n\nrow_sum = tf.reduce_sum(tensor_data, axis=1, keepdims=True)\n\noutput = tf.divide(tensor_data, row_sum)\n\n",
            "\ndata = [[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]]\n\ntensor = tf.convert_to_tensor(data)\n\nrow_sums = tf.reduce_sum(tensor, axis=1)\n\nrow_sums = tf.reshape(row_sums, [-1, 1])\n\noutput = tf.divide(tensor, row_sums)\n\n",
            "\ndef normalize_rows(input_data):\n    tensor_data = tf.constant(input_data, dtype=tf.float32)\n    row_sums = tf.reduce_sum(tensor_data, axis=1, keepdims=True)\n    normalized_data = tf.divide(tensor_data, row_sums)\n    return normalized_data.numpy()\n",
            "\ndata = [[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]]\n\ndata_tensor = tf.constant(data)\n\nrow_sum = tf.reduce_sum(data_tensor, axis=1)\n\nrow_sum_reshaped = tf.reshape(row_sum, [-1, 1])\n\noutput = tf.divide(data_tensor, row_sum_reshaped)\n\n"
        ],
        "target-program": "tf.divide(in1, tf.expand_dims(tf.reduce_sum(in1, axis=1), 1))",
        "description": "Divide each row by the sum of that row",
        "tf_operators": {
            "tf.constant": 8,
            "tf.reduce_sum": 10,
            "tf.divide": 10,
            "tf.expand_dims": 2,
            "tf.convert_to_tensor": 2,
            "tf.reshape": 4,
            "tf.float32": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 3,
        "total_covered": 3
    },
    {
        "task_id": "google_04",
        "completions": [
            "\narray = tf.constant([111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432])\n\ntensor = tf.reshape(array, (3, 4, 2))\n\n",
            "\nflat_array = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\n\ntensor = tf.constant(flat_array)\n\nreshaped_tensor = tf.reshape(tensor, [4, 3, 2])\n\n",
            "\ndata = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\n\ndata_tensor = tf.constant(data)\n\nreshaped_tensor = tf.reshape(data_tensor, [4, 3, 2])\n\n",
            "\ndata = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\n\ndata_tensor = tf.constant(data)\n\nreshaped_tensor = tf.reshape(data_tensor, (-1, 3, 2))\n\n",
            "\ndata = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\n\ntensor = tf.constant(data)\n\nreshaped_tensor = tf.reshape(tensor, [3, 2, 4])\n\n",
            "\ntensor = tf.constant([111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432])\n\nreshaped_tensor = tf.reshape(tensor, (3, 4, 2))\n\n",
            "\narr = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\n\ntensor = tf.constant(arr)\n\nreshaped_tensor = tf.reshape(tensor, (3, 4, 2))\n\n",
            "\ntensor = tf.constant([111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432])\n\nreshaped_tensor = tf.reshape(tensor, (3, 4, 2))\n\n",
            "\ndata = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\n\ntensor = tf.constant(data)\n\nreshaped_tensor = tf.reshape(tensor, [4, 3, 2])\n\n",
            "\ndef reshape_array(array):\n    tensor = tf.constant(array)\n    tensor_reshaped = tf.reshape(tensor, (-1, 3, 2))\n    return tensor_reshaped.numpy().tolist()\n\narray = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\n"
        ],
        "target-program": "tf.reshape(in1, shape=(4, 3, 2))",
        "description": "Reshape a flat array into a rank 3 tensor",
        "tf_operators": {
            "tf.constant": 10,
            "tf.reshape": 10
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "google_05",
        "completions": [
            "\ndef repeat_elements(input_list):\n    input_tensor = tf.convert_to_tensor(input_list)\n    repeated_tensor = tf.repeat(input_tensor, repeats=[6], axis=0)\n    reshaped_tensor = tf.reshape(repeated_tensor, [-1, tf.shape(input_tensor)[1]])\n    return reshaped_tensor.numpy().tolist()\n\ninput_list = [[1, 2, 3, 4], [5, 6, 7, 8]]\noutput_list = repeat_elements(input_list)\n",
            "\ninput_tensor = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\n\noutput_tensor = tf.repeat(input_tensor, repeats=6, axis=0)\n\n",
            "\ndef repeat_elements(input):\n    return tf.repeat(input, repeats=[6], axis=0)\n\ninput = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\noutput = repeat_elements(input)\n",
            "\ndef repeat_entries(input_tensor):\n    repeated_tensor = tf.repeat(input_tensor, repeats=6, axis=0)\n    return repeated_tensor\n\ninput_tensor = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\noutput_tensor = repeat_entries(input_tensor)\n",
            "\ninput_tensor = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\n\noutput_tensor = tf.repeat(input_tensor, repeats=6, axis=0)\n\n",
            "\ninput_tensor = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\n\noutput_tensor = tf.tile(input_tensor, [6, 1])\n\n",
            "\ndata = [[1, 2, 3, 4], [5, 6, 7, 8]]\n\ntensor_data = tf.constant(data)\n\ntensor_data = tf.expand_dims(tensor_data, 0)\n\noutput = tf.tile(tensor_data, [6, 1, 1])\n\n",
            "\ndata = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\n\noutput = tf.repeat(data, repeats=6, axis=0)\n\n",
            "\ndef repeat_entries(input_tensor):\n    return tf.tile(input_tensor, [6, 1])\n",
            "\ninput_tensor = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\n\noutput_tensor = tf.tile(input_tensor, [6, 1])\n\n"
        ],
        "target-program": "tf.tile(tf.expand_dims(in1, 1), (1, 6, 1))",
        "description": "Repeat each input entry 6 times",
        "tf_operators": {
            "tf.repeat": 6,
            "tf.convert_to_tensor": 1,
            "tf.reshape": 1,
            "tf.shape": 1,
            "tf.constant": 8,
            "tf.tile": 4,
            "tf.expand_dims": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 2,
        "total_covered": 2
    },
    {
        "task_id": "google_06",
        "completions": [
            "\ndef max_in_list(lst):\n    tensor = tf.constant(lst, dtype=tf.int32)\n    max_value = tf.reduce_max(tensor)\n    return max_value.numpy()\n\n",
            "from itertools import groupby\n\ndef max_group_size(lst):\n    return max(len(list(group)) for key, group in groupby(lst))\n",
            "\ndef max_occurrence(input):\n    unique, _, count = tf.unique_with_counts(input)\n    max_index = tf.argmax(count)\n    return unique[max_index]\n\ninput = tf.constant([0, 1, 1, 2, 3, 3, 3, 3], dtype=tf.int32)\n\ninput = tf.constant([1, 3, 4, 5, 10, 8, 9, 4], dtype=tf.int32)\n",
            "\ndef max_count(arr):\n    _, _, count = tf.unique_with_counts(arr)\n    return tf.reduce_max(count)\n\n",
            "\ndef max_frequency(arr):\n    _, _, count = tf.unique_with_counts(arr)\n    max_freq = tf.reduce_max(count)\n    return max_freq\n\narr = tf.constant([0, 1, 1, 2, 3, 3, 3, 3])\n\narr = tf.constant([1, 3, 4, 5, 10, 8, 9, 4])\n",
            "\ndef max_frequency_count(lst):\n    tensor_lst = tf.constant(lst)\n    frequencies = [lst.count(i) for i in tensor_lst]\n    tensor_frequencies = tf.constant(frequencies)\n    max_frequency = tf.reduce_max(tensor_frequencies)\n    return max_frequency.numpy()\n",
            "\ndef max_frequency(lst):\n    _, _, counts = tf.unique_with_counts(lst)\n    max_freq = tf.reduce_max(counts)\n    return max_freq\n\nlst = tf.constant([0, 1, 1, 2, 3, 3, 3, 3], tf.int32)\n\nlst = tf.constant([1, 3, 4, 5, 10, 8, 9, 4], tf.int32)\n",
            "import numpy as np\n\ndef max_frequency(nums):\n    nums_tf = tf.constant(nums, dtype=tf.int32)\n    nums_np = nums_tf.numpy()\n    counts_np = np.bincount(nums_np)\n    counts_tf = tf.constant(counts_np, dtype=tf.int32)\n    max_freq = tf.reduce_max(counts_tf)\n    return max_freq.numpy()\n",
            "\ndef max_frequency(lst):\n    tensor = tf.constant(lst)\n    _, _, counts = tf.unique_with_counts(tensor)\n    return tf.reduce_max(counts).numpy()\n",
            "import numpy as np\n\ndef max_frequency(nums):\n    unique, counts = np.unique(nums, return_counts=True)\n    max_freq = tf.reduce_max(counts)\n    return max_freq.numpy()\n\n"
        ],
        "target-program": "tf.math.segment_max(in2, in1)",
        "description": "Take the max from each group of elements",
        "tf_operators": {
            "tf.constant": 7,
            "tf.reduce_max": 8,
            "tf.int32": 4,
            "tf.argmax": 1,
            "tf.unique_with_counts": 5,
            "tf.numpy": 1
        },
        "coverage_percentage": 0.0,
        "total_in_target": 1,
        "total_covered": 0
    },
    {
        "task_id": "google_07",
        "completions": [
            "\ndef argmax_of_elements(input_list):\n    tensor = tf.convert_to_tensor(input_list)\n    return tf.argmax(tensor).numpy()\n\n",
            "\ndef get_argmax(input):\n    input_tensor = tf.convert_to_tensor(input)\n    return tf.argmax(input_tensor).numpy()\n\n",
            "\ndef get_argmax(input_list):\n    tensor = tf.constant(input_list)\n    argmax_index = tf.math.argmax(tensor)\n    return argmax_index.numpy()\n",
            "\ndef argmax_of_elements(input_list):\n    tensor = tf.convert_to_tensor(input_list)\n    return tf.argmax(tensor).numpy()\n\ninput_list = [0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 4, 4, 5, 5]\n\ninput_list = [4, 1, 8, 2, 5, 7, 9, 3, 7, 3, 1, 42, 1, 2, 4, 0]\n",
            "\ndef find_argmax(input):\n    tensor = tf.convert_to_tensor(input)\n    return tf.argmax(tensor).numpy()\n",
            "\ndef find_argmax(input_list):\n    tensor = tf.convert_to_tensor(input_list)\n    return tf.argmax(tensor).numpy()\n",
            "\ndef find_argmax(input):\n  tensor = tf.convert_to_tensor(input)\n  return tf.argmax(tensor).numpy()\n",
            "\ndef argmax_of_elements(input_list):\n    tensor = tf.convert_to_tensor(input_list)\n    return tf.argmax(tensor).numpy()\n\n",
            "\ndef find_argmax(input_list):\n    tensor = tf.convert_to_tensor(input_list)\n    argmax = tf.argmax(tensor)\n    return argmax.numpy()\n",
            "\ndef argmax_index(input):\n    tensor = tf.convert_to_tensor(input)\n    return tf.argmax(tensor).numpy()\n"
        ],
        "target-program": "tf.cast(tf.argmax((tf.sequence_mask(tf.cumsum(tf.math.bincount(in1)), dtype=tf.int32) - tf.sequence_mask(tf.cumsum(tf.math.bincount(in1), exclusive=True), dtype=tf.int32, maxlen=in1.shape[0])) * in2, axis=1), tf.int32) - tf.cumsum(tf.math.bincount(in1), exclusive=True)",
        "description": "Take the argmax of each group of elements",
        "tf_operators": {
            "tf.convert_to_tensor": 9,
            "tf.argmax": 9,
            "tf.constant": 1,
            "tf.math.argmax": 1
        },
        "coverage_percentage": 16.666666666666664,
        "total_in_target": 6,
        "total_covered": 1
    },
    {
        "task_id": "google_08",
        "completions": [
            "\ndef create_mask(lengths):\n    mask = tf.sequence_mask(lengths)\n    mask = tf.cast(mask, tf.int32)\n    return mask\n\nlengths = tf.constant([3, 4, 2, 1])\nmask = create_mask(lengths)\n",
            "\ndef create_mask(lengths):\n    max_length = max(lengths)\n    mask = tf.sequence_mask(lengths, max_length)\n    return mask.numpy().astype(int).tolist()\n",
            "\ndef create_mask(sequence_lengths):\n    sequence_lengths = tf.constant(sequence_lengths, dtype=tf.int32)\n    max_length = tf.reduce_max(sequence_lengths)\n    range_tensor = tf.range(max_length)\n    mask = tf.reduce_any(tf.less(range_tensor, tf.expand_dims(sequence_lengths, 1)), 0)\n    return tf.cast(mask, dtype=tf.int32)\n\nsequence_lengths = [3, 4, 2, 1]\nmask = create_mask(sequence_lengths)\n",
            "\nlengths = [3, 4, 2, 1]\nmask = tf.sequence_mask(lengths)\nint_mask = tf.cast(mask, tf.int32)\n",
            "\nlengths = tf.constant([3, 4, 2, 1])\nmaxlen = tf.reduce_max(lengths)\nmask = tf.sequence_mask(lengths, maxlen)\nmask = tf.reshape(mask, [-1])\n\nwith tf.Session() as sess:\n    print(sess.run(mask))\n",
            "\ndef create_mask(lengths):\n    return tf.keras.preprocessing.sequence.pad_sequences(tf.sequence_mask(lengths), padding='post')\n",
            "\nlengths = [3, 4, 2, 1]\nmaxlen = max(lengths)\n\nmask = tf.sequence_mask(lengths, maxlen)\nmask = tf.cast(mask, dtype=tf.int32)\n\n",
            "\ndef sequence_mask(lengths):\n    mask = tf.sequence_mask(lengths)\n    mask = tf.reshape(mask, [-1])\n    return mask.numpy().astype(int)\n\nlengths = [3, 4, 2, 1]\n",
            "\ndef create_mask(lengths):\n    mask = tf.sequence_mask(lengths)\n    mask = tf.cast(mask, dtype=tf.int32)\n    return mask\n\nlengths = tf.constant([3, 4, 2, 1])\nmask = create_mask(lengths)\n",
            "\ndef create_mask(lengths):\n    max_length = tf.reduce_max(lengths)\n    mask = tf.sequence_mask(lengths, maxlen=max_length)\n    mask = tf.cast(mask, tf.int32)\n    mask = tf.reshape(mask, [-1])\n    return mask\n\nlengths = tf.constant([3, 4, 2, 1])\nmask = create_mask(lengths)\n"
        ],
        "target-program": "tf.cast(tf.greater(tf.expand_dims(in1, 1), tf.range(5)), tf.int32)",
        "description": "create a mask for sequences of the given lengths",
        "tf_operators": {
            "tf.sequence_mask": 9,
            "tf.cast": 6,
            "tf.constant": 5,
            "tf.int32": 6,
            "tf.reduce_any": 1,
            "tf.expand_dims": 1,
            "tf.less": 1,
            "tf.range": 1,
            "tf.reduce_max": 3,
            "tf.reshape": 3,
            "tf.Session": 1,
            "tf.keras.preprocessing.sequence.pad_sequences": 1
        },
        "coverage_percentage": 80.0,
        "total_in_target": 5,
        "total_covered": 4
    },
    {
        "task_id": "google_09",
        "completions": [
            "\ndef sort_segments(input_list):\n    # Convert the input list to a TensorFlow tensor\n    tensor = tf.constant(input_list, dtype=tf.int32)\n    \n    # Find the indices of the zeros in the tensor\n    zero_indices = tf.where(tensor == 0)\n    zero_indices = tf.reshape(zero_indices, [-1])\n    \n    # Add the start and end indices of the tensor to the zero indices\n    indices = tf.concat([[0], zero_indices + 1, [tf.size(tensor)]], 0)\n    \n    # Initialize the sum of the minimum numbers\n    min_sum = 0\n    \n    # Iterate through the indices\n    for i in range(tf.size(indices) - 1):\n        # Find the minimum number in each segment\n        segment_min = tf.reduce_min(tensor[indices[i]:indices[i + 1]])\n        # Add the minimum number to the sum\n        min_sum += segment_min\n    \n    return min_sum\n",
            "\ndef sort_segments(input_list):\n    input_tensor = tf.constant(input_list, dtype=tf.int32)\n    diff = tf.concat([[1], tf.sign(tf.diff(input_tensor))], 0)\n    segment_ids = tf.cumsum(tf.clip_by_value(diff, 0, 1))\n    sums = tf.math.unsorted_segment_sum(input_tensor, segment_ids, tf.reduce_max(segment_ids)+1)\n    sorted_sums = tf.sort(sums)\n    return sorted_sums[1]\n",
            "\ndef sort_segments(input_list):\n    tensor = tf.constant(input_list)\n    zero_indices = tf.where(tensor == 0)\n    segment_ids = tf.range(tf.size(zero_indices))\n    segment_min = tf.segment_min(tensor, segment_ids)\n    return tf.reduce_min(segment_min).numpy()\n",
            "",
            "\ndef sort_segments(arr):\n    arr = tf.constant(arr, dtype=tf.int32)\n    zero_indices = tf.where(tf.equal(arr, 0))\n    zero_indices = tf.reshape(zero_indices, [-1])\n    segments = tf.split(arr, tf.concat([[zero_indices[0]], zero_indices[1:] - zero_indices[:-1], [tf.size(arr) - zero_indices[-1]], 0))\n    min_values = [tf.reduce_min(tf.sort(segment)) for segment in segments if tf.size(segment) > 0]\n    return tf.reduce_sum(min_values).numpy()\n\n",
            "\ndef sort_segments(lst):\n    tensor = tf.constant(lst, dtype=tf.int32)\n    zeros = tf.where(tf.equal(tensor, 0))\n    segments = tf.split(tensor, zeros[:, 0] + 1)\n    maxs = [tf.reduce_max(segment) for segment in segments if tf.reduce_max(segment) != 0]\n    return tf.reduce_min(maxs)\n\n",
            "\ndef third_smallest_num(lst):\n    tensor = tf.constant(lst, dtype=tf.int32)\n    sorted_tensor = tf.sort(tensor)\n    third_smallest = sorted_tensor[2].numpy()\n    return third_smallest\n",
            "\ndef sort_segments(input_list):\n    # Convert the input list to a TensorFlow tensor\n    input_tensor = tf.constant(input_list, dtype=tf.int32)\n\n    # Calculate the differences between consecutive elements in the tensor\n    diffs = tf.diff(input_tensor)\n\n    # Get the indices where a new segment starts\n    segment_indices = tf.where(diffs > 0)\n\n    # Get the last number of each segment\n    last_numbers = tf.gather(input_tensor, segment_indices + 1)\n\n    # Find the smallest last number of all segments\n    min_last_number = tf.reduce_min(last_numbers)\n\n    return min_last_number.numpy()\n",
            "\ndef sort_segments(input_list):\n    # Convert the input list into a tensorflow tensor\n    input_tensor = tf.constant(input_list, dtype=tf.int32)\n    \n    # Segments are sorted by the sum of their elements\n    segment_ids = tf.constant([0, 0, 0, 1, 1, 2], dtype=tf.int32)\n    \n    # Use the tf.segment_sum function to sort the segments\n    sorted_segments = tf.segment_sum(input_tensor, segment_ids)\n\n    # Return the minimum value among the sorted segments\n    return tf.reduce_min(sorted_segments).numpy()\n",
            ""
        ],
        "target-program": "tf.gather(in2, tf.argsort(in1, stable=True))",
        "description": "sort the segments",
        "tf_operators": {
            "tf.where": 5,
            "tf.reshape": 2,
            "tf.reduce_min": 6,
            "tf.int32": 7,
            "tf.constant": 8,
            "tf.size": 3,
            "tf.concat": 3,
            "tf.sort": 3,
            "tf.cumsum": 1,
            "tf.sign": 1,
            "tf.math.unsorted_segment_sum": 1,
            "tf.clip_by_value": 1,
            "tf.reduce_max": 2,
            "tf.diff": 2,
            "tf.range": 1,
            "tf.segment_min": 1,
            "tf.equal": 2,
            "tf.reduce_sum": 1,
            "tf.split": 2,
            "tf.gather": 1,
            "tf.segment_sum": 1
        },
        "coverage_percentage": 50.0,
        "total_in_target": 2,
        "total_covered": 1
    },
    {
        "task_id": "google_10",
        "completions": [
            "\ndef gather_marked_elements(data, mask):\n    data_tensor = tf.convert_to_tensor(data)\n    mask_tensor = tf.convert_to_tensor(mask)\n    output = tf.boolean_mask(data_tensor, mask_tensor)\n    return output\n",
            "\ndef gather_marked_elements(input1, input2):\n    tensor1 = tf.convert_to_tensor(input1)\n    tensor2 = tf.convert_to_tensor(input2)\n    indices = tf.where(tensor2 == 1)\n    gathered_elements = tf.gather(tensor1, indices)\n    return gathered_elements\n",
            "\ndef gather_marked_elements(arr):\n    tensor1 = tf.constant(arr, dtype=tf.int32)\n    tensor2 = tf.constant([10, 20, 30, 40, 50, 60], dtype=tf.int32)\n    result = tf.reduce_sum(tf.multiply(tensor1, tensor2))\n    return result.numpy()\n",
            "\ndef gather_marked_elements(input_list):\n    input_tensor = tf.constant(input_list, dtype=tf.int32)\n    mask = tf.not_equal(input_tensor, 0)\n    non_zero_elements = tf.boolean_mask(input_tensor, mask)\n    output = tf.reduce_sum(non_zero_elements)\n    return output\n",
            "\ndef gather_marked_elements(data, mask):\n    tensor_data = tf.constant(data, dtype=tf.int32)\n    tensor_mask = tf.constant(mask, dtype=tf.bool)\n    gathered_elements = tf.boolean_mask(tensor_data, tensor_mask)\n    return gathered_elements\n",
            "\ntensor = tf.constant([10, 20, 0, 40, 0, 30])\nmask = tf.constant([1, 1, 0, 1, 0, 1], dtype=bool)\n\noutput = tf.boolean_mask(tensor, mask)\n",
            "\ndef gather_marked_elements(input_list, mask_list):\n    input_tensor = tf.constant(input_list)\n    mask_tensor = tf.constant(mask_list)\n    mask_tensor = tf.equal(mask_tensor, 1)\n    gathered_elements = tf.boolean_mask(input_tensor, mask_tensor)\n    return gathered_elements\n",
            "\ndef gather_elements(main_list, indicator_list):\n    main_tensor = tf.constant(main_list)\n    indicator_tensor = tf.constant(indicator_list)\n    selected_elements = tf.boolean_mask(main_tensor, indicator_tensor)\n    return selected_elements\n\nmain_list = [10, 20, 0, 40, 0, 30]\nindicator_list = [1, 1, 0, 1, 0, 1]\n",
            "\ndata = tf.constant([10, 20, 0, 40, 0, 30])\nmask = tf.constant([1, 1, 0, 1, 0, 1], dtype=bool)\n\nmarked_elements = tf.boolean_mask(data, mask)\n",
            "\ndef gather_marked_elements(list1, list2):\n    tensor1 = tf.convert_to_tensor(list1)\n    tensor2 = tf.cast(tf.convert_to_tensor(list2), tf.bool)\n    result = tf.boolean_mask(tensor1, tensor2)\n    return result\n\nlist1 = [10, 20, 0, 40, 0, 30]\nlist2 = [1, 1, 0, 1, 0, 1]\n"
        ],
        "target-program": "tf.boolean_mask(in1, tf.cast(in2, tf.bool))",
        "description": "gather the marked elements",
        "tf_operators": {
            "tf.convert_to_tensor": 3,
            "tf.boolean_mask": 8,
            "tf.gather": 1,
            "tf.where": 1,
            "tf.constant": 7,
            "tf.reduce_sum": 2,
            "tf.multiply": 1,
            "tf.int32": 3,
            "tf.not_equal": 1,
            "tf.bool": 2,
            "tf.equal": 1,
            "tf.cast": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 3,
        "total_covered": 3
    },
    {
        "task_id": "google_11",
        "completions": [
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], \n        [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], \n        [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], \n        [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\n\ntensor_data = tf.constant(data)\n\ngreater_than_zero = tf.greater(tensor_data, 0)\n\ncount = tf.reduce_sum(tf.cast(greater_than_zero, tf.int32), axis=1)\n\n",
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\ntensor = tf.constant(data)\ngreater_than_zero = tf.math.greater(tensor, 0)\ncount = tf.reduce_sum(tf.cast(greater_than_zero, tf.int32), axis=1)\n",
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\n\ntensor = tf.constant(data)\n\ngreater_than_zero = tf.greater(tensor, 0)\n\ncount = tf.reduce_sum(tf.cast(greater_than_zero, tf.int32), axis=1)\n\n",
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\ntensor = tf.constant(data)\n\ngreater_than_zero = tf.greater(tensor, 0)\ncount = tf.reduce_sum(tf.cast(greater_than_zero, tf.int32))\n\nwith tf.Session() as sess:\n    output = sess.run(count)\n",
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\n\ntensor = tf.convert_to_tensor(data)\n\nbool_tensor = tf.greater(tensor, 0)\n\nint_tensor = tf.cast(bool_tensor, tf.int32)\n\ncounts_per_row = tf.reduce_sum(int_tensor, axis=1)\n\ntotal_count = tf.reduce_sum(counts_per_row)\n\n",
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\n\ntensor_data = tf.convert_to_tensor(data)\n\nmask = tf.greater(tensor_data, 0)\n\ncount = tf.reduce_sum(tf.cast(mask, tf.int32), axis=1)\n\n",
            "\ninput_list = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\n\ntensor = tf.convert_to_tensor(input_list)\n\noutput = tf.reduce_sum(tf.cast(tf.math.greater(tensor, 0), tf.int32), axis=1)\n\n",
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\n\ntensor = tf.constant(data)\n\nbool_tensor = tf.greater(tensor, 0)\n\nint_tensor = tf.cast(bool_tensor, tf.int32)\n\ncount_per_row = tf.reduce_sum(int_tensor, axis=1)\n\ntotal_count = tf.reduce_sum(count_per_row)\n\n",
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\n\ntensor = tf.constant(data)\n\ngreater_than_zero = tf.math.greater(tensor, 0)\n\ninteger_tensor = tf.cast(greater_than_zero, tf.int32)\n\nresult = tf.reduce_sum(integer_tensor, axis=1)\n\n",
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\n\ntensor_data = tf.constant(data)\n\ngreater_than_zero = tf.greater(tensor_data, 0)\n\ncount = tf.reduce_sum(tf.cast(greater_than_zero, tf.int32), axis=1)\n\n"
        ],
        "target-program": "tf.reduce_sum(tf.cast(tf.greater(in1, 0), tf.int32), axis=1)",
        "description": "count the number of elements greater than 0 in each row",
        "tf_operators": {
            "tf.int32": 10,
            "tf.constant": 7,
            "tf.reduce_sum": 10,
            "tf.greater": 7,
            "tf.cast": 10,
            "tf.math.greater": 3,
            "tf.Session": 1,
            "tf.convert_to_tensor": 3
        },
        "coverage_percentage": 100.0,
        "total_in_target": 4,
        "total_covered": 4
    },
    {
        "task_id": "google_12",
        "completions": [
            "\ndef identify_elements(input_list):\n    tensor = tf.constant(input_list, dtype=tf.float32)\n    bool_tensor = tf.logical_and(tf.greater(tensor, 0), tf.less(tensor, 1))\n    int_tensor = tf.cast(bool_tensor, tf.int32)\n    return int_tensor\n",
            "\ndata = tf.constant([[1.0, 0.3, -4.2, 0.0, 2.1], [-0.1, 0.0, 1.4, -1.0, 0.4], [0.1, 0.0, 0.7, -0.3, 0.5], [1.4, 2.5, 0.3, -0.1, 0.0]])\n\nmask = tf.logical_and(data > 0, data < 1)\n\nresult = tf.cast(mask, tf.int32)\n\n",
            "\ndef identify_elements_between_0_and_1(input_list):\n    tensor = tf.constant(input_list)\n    tensor = tf.reshape(tensor, [-1])\n    result = tf.logical_and(tf.greater(tensor, 0.0), tf.less(tensor, 1.0))\n    result = tf.cast(result, tf.int32)\n    return result.numpy().tolist()\n",
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1], [-0.1, 0.0, 1.4, -1.0, 0.4], [0.1, 0.0, 0.7, -0.3, 0.5], [1.4, 2.5, 0.3, -0.1, 0.0]]\n\ntensor = tf.constant(data)\n\nresult = tf.cast(tf.logical_and(tensor > 0, tensor < 1), tf.int32)\n\n",
            "\ntensor = tf.constant([[1.0, 0.3, -4.2, 0.0, 2.1], [-0.1, 0.0, 1.4, -1.0, 0.4], [0.1, 0.0, 0.7, -0.3, 0.5], [1.4, 2.5, 0.3, -0.1, 0.0]])\n\nresult = tf.cast(tf.math.logical_and(tf.math.greater(tensor, 0), tf.math.less(tensor, 1)), tf.int32)\n\n",
            "\ninput_tensor = tf.constant([[1.0, 0.3, -4.2, 0.0, 2.1], [-0.1, 0.0, 1.4, -1.0, 0.4], [0.1, 0.0, 0.7, -0.3, 0.5], [1.4, 2.5, 0.3, -0.1, 0.0]])\n\noutput_tensor = tf.cast(tf.logical_and(input_tensor > 0, input_tensor < 1), tf.int32)\n\noutput_list = tf.reshape(output_tensor, [-1]).numpy().tolist()\n\n",
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1], [-0.1, 0.0, 1.4, -1.0, 0.4], [0.1, 0.0, 0.7, -0.3, 0.5], [1.4, 2.5, 0.3, -0.1, 0.0]]\n\ndata_tensor = tf.constant(data)\n\nresult = tf.cast(tf.logical_and(tf.greater(data_tensor, 0), tf.less(data_tensor, 1)), tf.int32)\n\n",
            "\ndef identify_elements(data):\n    data = tf.constant(data)\n    data = tf.reshape(data, [-1])\n    result = tf.math.logical_and(tf.less(data, 1.0), tf.greater_equal(data, 0.0))\n    result = tf.cast(result, tf.int32)\n    return result.numpy().tolist()\n\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1], [-0.1, 0.0, 1.4, -1.0, 0.4], [0.1, 0.0, 0.7, -0.3, 0.5], [1.4, 2.5, 0.3, -0.1, 0.0]]\n",
            "\ndef identify_elements(input_tensor):\n    condition = tf.logical_and(tf.greater(input_tensor, 0), tf.less(input_tensor, 1))\n    output_tensor = tf.cast(condition, tf.int32)\n    return output_tensor\n",
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1], [-0.1, 0.0, 1.4, -1.0, 0.4], [0.1, 0.0, 0.7, -0.3, 0.5], [1.4, 2.5, 0.3, -0.1, 0.0]]\n\ntensor = tf.reshape(tf.constant(data), [-1])\n\nresult = tf.cast(tf.logical_and(tf.greater(tensor, 0), tf.less(tensor, 1)), tf.int32)\n\n"
        ],
        "target-program": "tf.cast(tf.logical_and(0 <= in1, in1 <= 1), tf.int32)",
        "description": "identify elements between 0 and 1",
        "tf_operators": {
            "tf.int32": 10,
            "tf.float32": 1,
            "tf.constant": 9,
            "tf.less": 6,
            "tf.logical_and": 8,
            "tf.greater": 5,
            "tf.cast": 10,
            "tf.reshape": 4,
            "tf.math.logical_and": 2,
            "tf.math.less": 1,
            "tf.math.greater": 1,
            "tf.greater_equal": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 3,
        "total_covered": 3
    },
    {
        "task_id": "google_13",
        "completions": [
            "\ndef concatenate_sequences(seq1, seq2):\n    tensor1 = tf.constant(seq1)\n    tensor2 = tf.constant(seq2)\n    concatenated = tf.concat([tensor1, tensor2], axis=0)\n    return concatenated.numpy().tolist()\n\n",
            "\nseq1 = tf.constant([1, 2])\nseq2 = tf.constant([10, 20])\n\noutput = tf.concat([seq1, seq2], 0)\n",
            "\ndef concat_sequences(sequences):\n    return tf.concat(sequences, axis=0)\n\nsequences = [[1, 2], [10, 20]]\n",
            "\ndef concatenate_sequences(seq1, seq2):\n    tensor1 = tf.constant(seq1)\n    tensor2 = tf.constant(seq2)\n    return tf.concat([tensor1, tensor2], 0)\n",
            "\ndef concat_batches(batches):\n    return tf.concat(batches, axis=0)\n\nbatches = [tf.constant([1, 2]), tf.constant([10, 20])]\n\nbatches = [tf.constant([3, 4, 5]), tf.constant([30, 40, 50])]\n",
            "\ndef concatenate_sequences(sequences):\n    tensor_sequences = [tf.constant(seq) for seq in sequences]\n    concatenated = tf.concat(tensor_sequences, axis=0)\n    return concatenated.numpy().tolist()\n\n",
            "\ndef concatenate_sequences(sequences):\n    # Convert the sequences to tensors\n    tensors = [tf.convert_to_tensor(seq) for seq in sequences]\n    \n    # Concatenate the tensors along the first dimension\n    concatenated = tf.concat(tensors, axis=0)\n    \n    return concatenated.numpy().tolist()\n",
            "\ndef concat_sequences(seq):\n    return tf.concat(seq, axis=0)\n\n",
            "\ndef concat_sequences(sequences):\n    return tf.concat(sequences, axis=0)\n",
            "\ndef concatenate_sequences(sequences):\n    return tf.concat(sequences, axis=0)\n\n"
        ],
        "target-program": "tf.concat([in1, in2], axis=1)",
        "description": "Concatenate batches of sequences",
        "tf_operators": {
            "tf.constant": 5,
            "tf.concat": 10,
            "tf.convert_to_tensor": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "google_14",
        "completions": [
            "\ndef circular_buffer(input_list):\n    tensor = tf.convert_to_tensor(input_list)\n    indices = [len(sub_list) - 1 for sub_list in input_list]\n    last_elements = tf.gather(tensor, indices, axis=1)\n    return last_elements.numpy().tolist()\n",
            "\ndef circular_buffer(input_list):\n    tensor = tf.constant(input_list)\n    shifted_tensor = tf.roll(tensor, shift=-1, axis=0)\n    return shifted_tensor.numpy()[0].tolist()\n\ninput_list = [[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]]\n",
            "\ndef circular_buffer(data):\n    return tf.roll(data, shift=-1, axis=1)\n\ndata = tf.constant([[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]])\n",
            "\ndef circular_buffer(input):\n    input_tensor = tf.constant(input)\n    output_tensor = tf.roll(input_tensor, shift=1, axis=1)\n    return output_tensor.numpy().tolist()\n\ninput = [[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]]\n",
            "\ndef circular_buffer(input_array):\n    return tf.roll(input_array, shift=1, axis=1)\n\ninput_array = tf.constant([[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]])\noutput = circular_buffer(input_array)\n",
            "\ndata = [[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]]\n\ntensor_data = tf.constant(data)\n\nlast_elements = tf.gather(tensor_data, [-1], axis=1)\n\nwith tf.Session() as sess:\n    # Convert tensor back to list\n    output = sess.run(tf.unstack(last_elements, axis=1))\n\n",
            "\ndef circular_buffer(data):\n    data_tf = tf.constant(data)\n    last_index = tf.gather(data_tf, -1)\n    return last_index.numpy().tolist()\n\n",
            "\ndef circular_buffer(arr):\n    return tf.roll(arr, shift=-1, axis=0)\n\narr = tf.constant([[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]])\noutput = circular_buffer(arr)\n",
            "\ndef circular_buffer(input):\n    tensor = tf.constant(input)\n    last_element = tf.slice(tensor, [len(input)-1, len(input[0])-1], [1, 1])\n    first_list = tf.slice(tensor, [0, 0], [1, len(input[0])-1])\n    buffer = tf.concat([last_element, first_list], 1)\n    return buffer.numpy()[0]\n\ninput = [[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]]\n",
            "\ndef circular_buffer(arr):\n    return tf.roll(arr, shift=-1, axis=1)\n\narr = tf.constant([[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]])\noutput = circular_buffer(arr)\n"
        ],
        "target-program": "tf.roll(in1, 1, 1)",
        "description": "circular buffer",
        "tf_operators": {
            "tf.gather": 3,
            "tf.convert_to_tensor": 1,
            "tf.constant": 9,
            "tf.roll": 6,
            "tf.Session": 1,
            "tf.unstack": 1,
            "tf.slice": 1,
            "tf.concat": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "google_15",
        "completions": [
            "\ntensor = tf.constant([[1, 3, 5, 7], [2, 4, 6, 8]])\n\npaddings = tf.constant([[0, 0], [0, 1]])\nresult = tf.pad(tensor, paddings, \"CONSTANT\")\n\n",
            "\ninput_data = [[1, 3, 5, 7], [2, 4, 6, 8]]\n\ntensor = tf.constant(input_data, dtype=tf.int32)\n\noutput = tf.pad(tensor, [[0, 0], [0, 1]])\n\n",
            "\ndef pad_zero_column(matrix):\n    matrix = tf.constant(matrix, tf.int32)\n    paddings = tf.constant([[0, 0], [0, 1]])\n    padded_matrix = tf.pad(matrix, paddings, \"CONSTANT\")\n    return padded_matrix\n",
            "\ninput_tensor = tf.constant([[1, 3, 5, 7], [2, 4, 6, 8]])\n\npadding = tf.constant([[0, 0], [0, 1]])\n\noutput_tensor = tf.pad(input_tensor, padding)\n\n",
            "\ndata = [[1, 3, 5, 7], [2, 4, 6, 8]]\n\ntensor_data = tf.constant(data)\n\nzeros = tf.zeros([tf.shape(tensor_data)[0], 1], dtype=tf.int32)\n\nresult = tf.concat([tensor_data, zeros], axis=1)\n\n",
            "\ndata = [[1, 3, 5, 7], [2, 4, 6, 8]]\n\ntensor_data = tf.constant(data)\n\nzero_tensor = tf.zeros(tensor_data.shape[0], dtype=tf.int32)\n\nresult = tf.concat([tensor_data, tf.expand_dims(zero_tensor, axis=-1)], axis=1)\n\n",
            "\ninput_array = tf.constant([[1, 3, 5, 7], [2, 4, 6, 8]])\n\npaddings = tf.constant([[0, 0], [0, 1]])\n\npadded_array = tf.pad(input_array, paddings, \"CONSTANT\")\n\nwith tf.Session() as sess:\n    print(sess.run(padded_array))\n",
            "\nmatrix = tf.constant([[1, 3, 5, 7], [2, 4, 6, 8]])\n\npaddings = tf.constant([[0, 0], [0, 1]])\n\nresult = tf.pad(matrix, paddings, \"CONSTANT\")\n\n",
            "\ntensor = tf.constant([[1, 3, 5, 7], [2, 4, 6, 8]])\n\npaddings = tf.constant([[0, 0], [0, 1]])\n\nresult = tf.pad(tensor, paddings, \"CONSTANT\")\n\n",
            "\ntensor = tf.constant([[1, 3, 5, 7], [2, 4, 6, 8]])\n\npaddings = tf.constant([[0, 0], [0, 1]])\n\nresult = tf.pad(tensor, paddings)\n\n"
        ],
        "target-program": "tf.pad(in1, [[0, 0], [0, 1]], 'CONSTANT')",
        "description": "pad a zero column",
        "tf_operators": {
            "tf.constant": 10,
            "tf.pad": 8,
            "tf.int32": 4,
            "tf.shape": 1,
            "tf.zeros": 2,
            "tf.concat": 2,
            "tf.expand_dims": 1,
            "tf.Session": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "google_16",
        "completions": [
            "\ndef count_replicated_elements(input):\n    _, _, counts = tf.unique_with_counts(input)\n    return tf.reduce_sum(tf.cast(tf.greater(counts, 1), tf.int32))\n",
            "\ndef count_unique_elements(input_list):\n    tensor = tf.constant(input_list)\n    unique_elements = tf.unique(tensor).y\n    return tf.size(unique_elements)\n",
            "",
            "\ndef replicate_elements(arr):\n    _, _, count = tf.unique_with_counts(arr)\n    return tf.reduce_min(count)\n\narr = tf.constant([1, 2, 0, 3])\nresult = replicate_elements(arr)\n",
            "\ndef max_replication(lst):\n    _, _, count = tf.unique_with_counts(lst)\n    return tf.reduce_max(count)\n\nlst = tf.constant([1, 2, 0, 3], dtype=tf.int32)\n",
            "\ndef replicate_elements(input_list, repeat_count):\n    tensor = tf.constant(input_list)\n    result = tf.repeat(tensor, repeat_count)\n    return result.numpy().tolist()\n\n",
            "",
            "\ndef replicate_elements(input_list):\n    tensor = tf.constant(input_list)\n    replicated_tensor = tf.repeat(tensor, repeats=2)\n    return replicated_tensor.numpy().tolist()\n",
            "\ndef count_ones(input):\n    tensor = tf.constant(input)\n    ones_tensor = tf.subtract(1, tensor)\n    count = tf.math.count_nonzero(ones_tensor)\n    return count\n",
            "\ndef max_replication_count(arr):\n    _, _, counts = tf.unique_with_counts(arr)\n    return tf.reduce_max(counts).numpy()\n\n"
        ],
        "target-program": "tf.gather(in1, tf.where(tf.sequence_mask(in2))[:, 0])",
        "description": "replicate elements a given number of times",
        "tf_operators": {
            "tf.int32": 2,
            "tf.reduce_sum": 1,
            "tf.greater": 1,
            "tf.cast": 1,
            "tf.unique_with_counts": 4,
            "tf.constant": 6,
            "tf.size": 1,
            "tf.unique": 1,
            "tf.reduce_min": 1,
            "tf.reduce_max": 2,
            "tf.repeat": 2,
            "tf.math.count_nonzero": 1,
            "tf.subtract": 1
        },
        "coverage_percentage": 0.0,
        "total_in_target": 3,
        "total_covered": 0
    },
    {
        "task_id": "google_17",
        "completions": [
            "\ndef conditional_sum(condition):\n    return tf.reduce_sum(tf.where(condition, tf.ones_like(condition), -5*tf.ones_like(condition)))\n",
            "\ndef process_tensors(bool_tensor, int_tensor):\n    if tf.math.reduce_any(bool_tensor):\n        return 1\n    else:\n        return -tf.math.reduce_sum(int_tensor)\n",
            "\ndef process_tensor(input_list):\n    tensor = tf.constant(input_list)\n    if tensor.dtype == tf.bool:\n        if tf.reduce_all(tensor):\n            return 1\n    return -tf.reduce_sum(tensor)\n",
            "\ndef apply_condition(tensor):\n    tensor = tf.where(tensor, 1, -20)\n    return tf.reduce_sum(tensor)\n",
            "\ndef calculate(tensor_bool, tensor_num):\n    num_trues = tf.reduce_sum(tf.cast(tensor_bool, tf.int32))\n    product = tf.reduce_prod(tensor_num)\n    result = product - num_trues\n    return result\n",
            "\ndef process_input(input_list):\n    tensor = tf.convert_to_tensor(input_list)\n    if tensor.dtype == tf.bool:\n        tensor = tf.cast(tensor, tf.int32)\n    sum = tf.reduce_sum(tensor)\n    return 1 if sum > 0 else -20\n",
            "\ndef process_tensor(tensor):\n    if tensor.dtype == tf.bool:\n        if tf.reduce_any(tensor):\n            return 1\n        else:\n            return 0\n    else:\n        return -tf.reduce_sum(tensor)\n",
            "\nbool_tensor = tf.constant([True, False, False, True, False])\noutput = tf.math.count_nonzero(bool_tensor)\n\nbool_tensor = tf.constant([True, False, False, True, False])\nnumber_tensor = tf.constant([1, 2, 3, 4, 5])\nmasked_tensor = tf.boolean_mask(number_tensor, bool_tensor)\noutput = -tf.reduce_sum(masked_tensor)\n",
            "\ndef check_tensor_type(tensor):\n    if tf.debugging.assert_bool(tensor):\n        return 1\n    elif tf.debugging.assert_integer(tensor):\n        return -20\n",
            "\ndef process_tensor(tensor):\n    if tf.reduce_all(tensor):\n        return 1\n    else:\n        return -tf.reduce_sum(tensor)\n"
        ],
        "target-program": "tf.where(in1, in2, tf.multiply(in2, -10))",
        "description": "use bool tensor as condition",
        "tf_operators": {
            "tf.where": 2,
            "tf.ones_like": 1,
            "tf.reduce_sum": 8,
            "tf.math.reduce_sum": 1,
            "tf.math.reduce_any": 1,
            "tf.constant": 2,
            "tf.bool": 3,
            "tf.reduce_all": 2,
            "tf.reduce_prod": 1,
            "tf.cast": 2,
            "tf.int32": 2,
            "tf.convert_to_tensor": 1,
            "tf.reduce_any": 1,
            "tf.math.count_nonzero": 1,
            "tf.boolean_mask": 1,
            "tf.debugging.assert_integer": 1,
            "tf.debugging.assert_bool": 1
        },
        "coverage_percentage": 50.0,
        "total_in_target": 2,
        "total_covered": 1
    },
    {
        "task_id": "google_18",
        "completions": [
            "\ndef sum_partitioned_elements(tensor1, tensor2):\n    # Partition the first tensor according to the second tensor\n    partitions = tf.dynamic_partition(tensor1, tensor2, np.max(tensor2)+1)\n    # Sum the elements in each partition\n    sums = [tf.reduce_sum(partition) for partition in partitions]\n    # Sum the sums\n    total_sum = tf.reduce_sum(sums)\n    return total_sum\n\ntensor1 = tf.constant([5, 7, -12, 10, 20])\ntensor2 = tf.constant([1, 2, 3, 1, 2])\n\nresult = sum_partitioned_elements(tensor1, tensor2)\n",
            "\ndef sum_partitioned_by_tensor(tensor1, tensor2):\n    return tf.math.reduce_sum(tf.math.unsorted_segment_sum(tensor1, tensor2, tf.reduce_max(tensor2) + 1))\n",
            "\ndef sum_partitioned_elements(tensor1, tensor2):\n    partitions = tf.dynamic_partition(tensor1, tensor2, max(tensor2) + 1)\n    sum_partitions = [tf.reduce_sum(partition) for partition in partitions]\n    total_sum = tf.reduce_sum(sum_partitions)\n    with tf.Session() as sess:\n        result = sess.run(total_sum)\n    return result\n\n",
            "\ndef partitioned_sum(t1, t2):\n    t1_tensor = tf.constant(t1)\n    t2_tensor = tf.constant(t2)\n    result = tf.segment_sum(t1_tensor, t2_tensor)\n    return tf.reduce_sum(result).numpy()\n",
            "\ndef sum_partitioned_by_second_tensor(tensor1, tensor2):\n    product = tf.multiply(tensor1, tensor2)\n    sum = tf.reduce_sum(product)\n    return sum\n\ntensor1 = tf.constant([5, 7, -12, 10, 20], dtype=tf.float32)\ntensor2 = tf.constant([1, 2, 3, 1, 2], dtype=tf.float32)\n\n",
            "\ndef sum_partitioned_by_tensor(tensor1, tensor2):\n    tensor1 = tf.constant(tensor1)\n    tensor2 = tf.constant(tensor2)\n    return tf.math.reduce_sum(tf.math.segment_sum(tensor1, tensor2)).numpy()\n\n",
            "\ndef sum_partitioned_elements(tensor1, tensor2):\n    partitions = tf.dynamic_partition(tensor1, tensor2, max(tensor2)+1)\n    return sum([tf.reduce_sum(partition) for partition in partitions])\n",
            "\ndef sum_partitioned_elements(data, partitions):\n    partitions = tf.dynamic_partition(data, partitions, 2)\n    sum_partitions = [tf.reduce_sum(partition) for partition in partitions]\n    return tf.reduce_sum(sum_partitions)\n\ndata = tf.constant([5, 7, -12, 10, 20], dtype=tf.int32)\npartitions = tf.constant([0, 0, 1, 1, 1], dtype=tf.int32)\n\noutput = sum_partitioned_elements(data, partitions)\n",
            "\ndef sum_partitioned_elements(tensor1, tensor2):\n    tensor1 = tf.constant(tensor1)\n    tensor2 = tf.constant(tensor2)\n    partitions = tf.dynamic_partition(tensor1, tensor2, max(tensor2) + 1)\n    sums = [tf.reduce_sum(partition) for partition in partitions]\n    total_sum = tf.reduce_sum(sums)\n    return total_sum\n\n",
            "\ndef sum_partitioned_elements(tensor1, tensor2):\n    partitions = tf.dynamic_partition(tensor1, tensor2, maxval=max(tensor2)+1)\n    sum_tensor = tf.reduce_sum([tf.reduce_sum(partition) for partition in partitions])\n    return sum_tensor\n\ntensor1 = tf.constant([5, 7, -12, 10, 20], dtype=tf.int32)\ntensor2 = tf.constant([0, 0, 0, 0, 0], dtype=tf.int32)\n\noutput = sum_partitioned_elements(tensor1, tensor2)\n"
        ],
        "target-program": "tf.linalg.matvec(tf.cast(tf.equal(in2[:, None], in2), tf.int32), in1)",
        "description": "(\\'sum of elements in the first tensor but partitioned by the second tensor\\')",
        "tf_operators": {
            "tf.constant": 7,
            "tf.reduce_sum": 8,
            "tf.dynamic_partition": 6,
            "tf.math.reduce_sum": 2,
            "tf.reduce_max": 1,
            "tf.math.unsorted_segment_sum": 1,
            "tf.Session": 1,
            "tf.segment_sum": 1,
            "tf.float32": 1,
            "tf.multiply": 1,
            "tf.math.segment_sum": 1,
            "tf.int32": 2
        },
        "coverage_percentage": 25.0,
        "total_in_target": 4,
        "total_covered": 1
    },
    {
        "task_id": "google_19",
        "completions": [
            "\ndef scatter_tensor(input_tensor):\n    indices = tf.constant([[0, 1], [0, 2], [0, 0]])\n    output = tf.gather_nd(input_tensor, indices)\n    return output.numpy().tolist()\n\ninput_tensor = tf.constant([[11, 12, 13], [30, 20, 10], [77, 88, 99]])\n",
            "\ndef scatter_tensor(tensor):\n    indices = tf.constant([[0,1], [1,2], [2,0]])\n    return tf.gather_nd(tensor, indices)\n\ntensor = tf.constant([[11, 12, 13], [30, 20, 10], [77, 88, 99]])\n",
            "\ndef scatter_tensor(params, indices):\n    return tf.gather_nd(params, indices)\n\nparams = tf.constant([[11, 12, 13], [30, 20, 10], [77, 88, 99]])\nindices = tf.constant([[0, 1], [1, 2], [2, 0]])\n\noutput = scatter_tensor(params, indices)\n",
            "\ntensor = tf.constant([[11, 12, 13], [30, 20, 10], [77, 88, 99]])\n\nindices = tf.constant([[0, 1], [0, 2], [0, 0]])\n\noutput = tf.gather_nd(tensor, indices)\n\n",
            "\ndef scatter_2d_tensor(values, indices):\n    return tf.map_fn(lambda x: tf.gather(x[0], x[1]), (values, indices), dtype=tf.int32)\n\nvalues = tf.constant([[11, 12, 13], [30, 20, 10], [77, 88, 99]])\nindices = tf.constant([[2, 0, 1], [1, 0, 2], [0, 2, 1]])\n\nresult = scatter_2d_tensor(values, indices)\n",
            "\ndef scatter_2d_tensor(input_tensor):\n    indices = tf.constant([[0, 1], [1, 2], [2, 0]])\n    output_tensor = tf.gather_nd(input_tensor, indices)\n    return output_tensor.numpy().tolist()\n\ninput_tensor = tf.constant([[11, 12, 13], [30, 20, 10], [77, 88, 99]])\n\ninput_tensor = tf.constant([[2, 0, 1], [1, 0, 2], [0, 2, 1]])\n",
            "\ndef scatter_tensor(input_tensor):\n    tensor = tf.constant(input_tensor)\n    result = tf.gather(tensor[0], tensor[1])\n    return result.numpy().tolist()\n",
            "\ndef scatter_tensor(tensor):\n    indices = [[0, 1], [1, 2], [2, 0]]\n    return tf.gather_nd(tensor, indices)\n\ntensor = tf.constant([[11, 12, 13], [30, 20, 10], [77, 88, 99]])\n\ntensor = tf.constant([[2, 0, 1], [1, 0, 2], [0, 2, 1]])\n",
            "\ndef scatter_tensor(tensor, indices):\n    scattered = []\n    for i in range(len(tensor)):\n        scattered.append(tf.gather(tensor[i], indices[i]))\n    return scattered\n\ntensor = tf.constant([[11, 12, 13], [30, 20, 10], [77, 88, 99]])\nindices = tf.constant([[2, 0, 1], [1, 0, 2], [0, 2, 1]])\noutput = scatter_tensor(tensor, indices)\n",
            "\ndef scatter_tensor(data, indices):\n    data_tensor = tf.constant(data)\n    indices_tensor = tf.constant(indices)\n    result = tf.map_fn(lambda x: tf.gather(x[0], x[1]), (data_tensor, indices_tensor), dtype=tf.int32)\n    return result.numpy().tolist()\n"
        ],
        "target-program": "tf.gather(in1, tf.argsort(in2, axis=1), batch_dims=1)",
        "description": "scatter a 2-D tensor with indices",
        "tf_operators": {
            "tf.constant": 10,
            "tf.gather_nd": 6,
            "tf.gather": 4,
            "tf.map_fn": 2,
            "tf.int32": 2
        },
        "coverage_percentage": 50.0,
        "total_in_target": 2,
        "total_covered": 1
    },
    {
        "task_id": "google_20",
        "completions": [
            "\ndef find_index(tensor, value):\n    sorted_indices = tf.argsort(tensor)\n    index = tf.where(tf.equal(sorted_indices, value))\n    return index\n\ntensor = tf.constant([10, 7, 4, 3, 2, 8])\nvalue = 5\n",
            "\ntensor = tf.constant([10, 7, 4, 3, 2, 8])\n\nsorted_indices = tf.argsort(tensor, direction='ASCENDING')\n\n",
            "\ninput_list = [10, 7, 4, 3, 2, 8]\n\ntensor = tf.constant(input_list)\n\nsorted_indices = tf.argsort(tensor)\n\nresult = tf.reshape(sorted_indices, tensor.shape)\n\n",
            "\ntensor = tf.constant([10, 7, 4, 3, 2, 8])\n\nindices = tf.argsort(tensor, direction='DESCENDING')\n\nindices = tf.reverse(indices, axis=[0])\n\n",
            "\ntensor = tf.constant([10, 7, 4, 3, 2, 8])\n\nsorted_indices = tf.argsort(tensor)\n\noriginal_order_indices = tf.gather(sorted_indices, tf.argsort(sorted_indices))\n\n",
            "\ndef sort_tensor(input_tensor):\n    tensor = tf.constant(input_tensor)\n    sorted_indices = tf.argsort(tensor)\n    sorted_indices_in_original_order = tf.argsort(sorted_indices)\n    return sorted_indices_in_original_order + 1\n",
            "\ninput_list = [10, 7, 4, 3, 2, 8]\n\ntensor = tf.constant(input_list)\n\nsorted_indices = tf.argsort(tensor)\n\nzero_tensor = tf.zeros_like(sorted_indices)\n\nrange_tensor = tf.range(tf.shape(tensor)[0])\n\noutput = tf.scatter_nd(tf.expand_dims(sorted_indices, 1), range_tensor, tf.shape(tensor))\n\n",
            "\ntensor = tf.constant([10, 7, 4, 3, 2, 8])\n\nsorted_indices = tf.argsort(tensor)\n\n",
            "\nx = tf.constant([10, 7, 4, 3, 2, 8])\n\nsorted_indices = tf.argsort(x)\n\noriginal_order_indices = tf.argsort(sorted_indices)\n\n",
            "\ntensor = tf.constant([10, 7, 4, 3, 2, 8])\n\nsorted_indices = tf.argsort(tensor)\n\n"
        ],
        "target-program": "tf.cast(tf.argsort(tf.argsort(in1)), tf.int32)",
        "description": "sort a tensor and return sorted index in original order",
        "tf_operators": {
            "tf.where": 1,
            "tf.constant": 10,
            "tf.argsort": 10,
            "tf.equal": 1,
            "tf.reshape": 1,
            "tf.reverse": 1,
            "tf.gather": 1,
            "tf.shape": 1,
            "tf.expand_dims": 1,
            "tf.range": 1,
            "tf.scatter_nd": 1,
            "tf.zeros_like": 1
        },
        "coverage_percentage": 33.33333333333333,
        "total_in_target": 3,
        "total_covered": 1
    },
    {
        "task_id": "google_22",
        "completions": [
            "\ndata = tf.constant([[0, 2], [1, 3], [2, 4]])\n\nequal_elements = tf.reduce_all(data == data[0], axis=1)\n\nindex = tf.where(equal_elements)\n\n",
            "\ndata = tf.constant([[0, 2], [1, 3], [2, 4]])\n\nrange_tensor = tf.range(tf.shape(data)[0])\n\nfirst_column = tf.strided_slice(data, [0,0], tf.shape(data), [1,1])\n\nindices = tf.where(tf.equal(first_column, range_tensor))\n\nwith tf.Session() as sess:\n    print(sess.run(indices))\n",
            "\ndata = tf.constant([[0, 2], [1, 3], [2, 4]])\n\nindices = tf.where(tf.range(tf.shape(data)[0])[:, None] == data)\n\noutput = indices[:, 1]\n\n",
            "\ninput_tensor = tf.constant([[0, 2], [1, 3], [2, 4]], dtype=tf.int32)\n\nindices = tf.where(input_tensor == 0)\n\nrow_indices = indices[:, 0]\n\n",
            "\ndef pair_with_index(elem):\n    return tf.cast(tf.range(tf.shape(elem)[0]), tf.int32)\n\ninput_data = tf.constant([[0, 2], [1, 3], [2, 4]])\noutput = tf.map_fn(pair_with_index, input_data, dtype=tf.int32)\n",
            "\ndef get_indices(input):\n    tensor = tf.constant(input)\n    range_tensor = tf.range(tf.shape(tensor)[0])\n    condition = tf.equal(range_tensor, tensor[:, 0])\n    indices = tf.where(condition)\n    return indices.numpy().flatten().tolist()\n",
            "\ndata = tf.constant([[0, 2], [1, 3], [2, 4]])\n\npair = tf.constant([0, 0])\n\nindices = tf.where(tf.reduce_all(tf.equal(data, pair), axis=1))\n",
            "\ndef pair_with_row_index(input_data):\n    input_tensor = tf.constant(input_data)\n    row_indices = tf.range(tf.shape(input_tensor)[0])\n    condition = tf.equal(input_tensor[:, 0], row_indices)\n    output_indices = tf.where(condition)\n    return output_indices[:, 0].numpy().tolist()\n\n",
            "\ndef find_min_sum_row(input_list):\n    tensor = tf.constant(input_list)\n    row_sums = tf.reduce_sum(tensor, axis=1)\n    min_index = tf.argmin(row_sums).numpy()\n    return min_index\n\ninput_list = [[0, 2], [1, 3], [2, 4]]\n",
            "\ndef pair_with_row_index(data):\n    tensor_data = tf.constant(data)\n    row_indices = tf.range(tf.shape(tensor_data)[0])\n    result = tf.where(tf.equal(tensor_data, tf.reshape(row_indices, (-1, 1))))\n    return result[:, 0].numpy().tolist()\n\ndata = [[0, 2], [1, 3], [2, 4]]\n"
        ],
        "target-program": "tf.cast(tf.where(tf.reduce_max(tf.one_hot(in1, tf.reduce_max(in1) + 1), axis=1)), tf.int32)",
        "description": "pair with row index",
        "tf_operators": {
            "tf.where": 8,
            "tf.constant": 10,
            "tf.reduce_all": 2,
            "tf.shape": 6,
            "tf.equal": 5,
            "tf.strided_slice": 1,
            "tf.range": 6,
            "tf.Session": 1,
            "tf.int32": 2,
            "tf.map_fn": 1,
            "tf.cast": 1,
            "tf.argmin": 1,
            "tf.reduce_sum": 1,
            "tf.reshape": 1
        },
        "coverage_percentage": 60.0,
        "total_in_target": 5,
        "total_covered": 3
    },
    {
        "task_id": "stackoverflow_01",
        "completions": [
            "\nx = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\n\nx_dup = tf.tile(x, [1, 2])\n\noutput = tf.reshape(x_dup, [x.shape[0], x.shape[1]*2])\n\n",
            "\ndata = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n\ntensor = tf.constant(data)\n\ntensor = tf.expand_dims(tensor[:, 0], axis=-1)\n\ntensor = tf.tile(tensor, [1, 2])\n\ntensor = tf.reshape(tensor, [-1, 2])\n\n",
            "\ndata = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n\ntensor = tf.constant(data)\n\ntensor1, _ = tf.split(tensor, [1, 1], axis=1)\n\noutput = tf.concat([tensor1, tensor1], axis=1)\n\n",
            "\ninput_tensor = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\n\nfirst_column = tf.slice(input_tensor, [0, 0], [-1, 1])\n\nduplicated_first_column = tf.concat([first_column, first_column], axis=1)\n\noutput_tensor = tf.reshape(duplicated_first_column, [-1, 2])\n\n",
            "\ninput_array = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\n\nfirst_column = tf.slice(input_array, [0, 0], [-1, 1])\n\noutput_array = tf.concat([first_column, first_column], 1)\n\n",
            "\ndata = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\n\nresult = tf.stack([data[:, 0], data[:, 0]], axis=1)\n\n",
            "\ndef reshape_and_duplicate(input_list):\n    tensor = tf.constant(input_list)\n    tensor = tf.reshape(tensor, [tensor.shape[0], tensor.shape[1], 1])\n    tensor = tf.repeat(tensor, repeats=[2], axis=2)\n    tensor = tf.reshape(tensor, [tensor.shape[0], -1])\n    return tensor.numpy()\n",
            "\ndef reshape_and_duplicate(input_array):\n    reshaped_array = tf.reshape(input_array[:,0], (-1, 1))\n    output_array = tf.tile(reshaped_array, [1, 2])\n    return output_array\n\ninput_array = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\noutput_array = reshape_and_duplicate(input_array)\n",
            "\ndata = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n\ntensor = tf.constant(data)\n\nsplit_tensors = tf.split(tensor, num_or_size_splits=2, axis=1)\n\noutput = tf.concat([split_tensors[0], split_tensors[0]], axis=1)\n\n",
            "\ndata = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n\ntensor = tf.constant(data)\n\nfirst_column, _ = tf.split(tensor, [1, 1], axis=1)\n\noutput = tf.stack([first_column, first_column], axis=2)\n\noutput = tf.reshape(output, [-1, 2])\n\n"
        ],
        "target-program": "tf.transpose(tf.cast((in1, in1), tf.float32))",
        "description": "reshape by separating and duplicating columns",
        "tf_operators": {
            "tf.constant": 10,
            "tf.reshape": 6,
            "tf.tile": 3,
            "tf.expand_dims": 1,
            "tf.split": 3,
            "tf.concat": 4,
            "tf.slice": 2,
            "tf.stack": 2,
            "tf.repeat": 1
        },
        "coverage_percentage": 0.0,
        "total_in_target": 3,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_02",
        "completions": [
            "\ninput_list = [5, 1, 0, 3, 0, -1, 2, -10, 2]\n\ninput_tensor = tf.constant(input_list, dtype=tf.float32)\n\noutput_tensor = tf.clip_by_value(input_tensor, clip_value_min=-tf.float32.max, clip_value_max=1)\n\n",
            "\nlst = [5, 1, 0, 3, 0, -1, 2, -10, 2]\n\ntensor = tf.constant(lst, dtype=tf.float32)\n\nclipped_tensor = tf.clip_by_value(tensor, clip_value_min=float('-inf'), clip_value_max=1.0)\n\nclipped_list = clipped_tensor.numpy().tolist()\n\n",
            "\ninput_tensor = tf.constant([5, 1, 0, 3, 0, -1, 2, -10, 2], dtype=tf.float32)\n\noutput_tensor = tf.clip_by_value(input_tensor, clip_value_min=-tf.float32.max, clip_value_max=1)\n\n",
            "\nnumbers = [5, 1, 0, 3, 0, -1, 2, -10, 2]\n\nnumbers_tensor = tf.constant(numbers)\n\nclipped_values = tf.clip_by_value(numbers_tensor, tf.reduce_min(numbers_tensor), 1)\n\n",
            "\nlst = [5, 1, 0, 3, 0, -1, 2, -10, 2]\n\ntensor = tf.constant(lst, dtype=tf.float32)\n\nclipped_tensor = tf.clip_by_value(tensor, clip_value_min=float('-inf'), clip_value_max=1)\n\n",
            "\ntensor = tf.constant([5, 1, 0, 3, 0, -1, 2, -10, 2], dtype=tf.float32)\n\nclipped_tensor = tf.clip_by_value(tensor, clip_value_min=-tf.float32.max, clip_value_max=1)\n\n",
            "\ndata = [5, 1, 0, 3, 0, -1, 2, -10, 2]\n\ntensor_data = tf.constant(data, dtype=tf.float32)\n\nclipped_data = tf.clip_by_value(tensor_data, clip_value_min=tf.float32.min, clip_value_max=1)\n\n",
            "\ntensor = tf.constant([5, 1, 0, 3, 0, -1, 2, -10, 2], dtype=tf.float32)\n\nclipped_tensor = tf.clip_by_value(tensor, clip_value_min=tf.float32.min, clip_value_max=1)\n\n",
            "\ninput_list = [5, 1, 0, 3, 0, -1, 2, -10, 2]\n\ntensor = tf.constant(input_list, dtype=tf.float32)\n\nclipped_tensor = tf.clip_by_value(tensor, clip_value_min=float('-inf'), clip_value_max=1)\n\noutput_list = clipped_tensor.numpy().tolist()\n\n",
            "\ndata = [5, 1, 0, 3, 0, -1, 2, -10, 2]\n\ntensor_data = tf.constant(data, dtype=tf.float32)\n\nclipped_data = tf.clip_by_value(tensor_data, clip_value_min=-tf.float32.max, clip_value_max=1)\n\nclipped_data = clipped_data.numpy()\n\n"
        ],
        "target-program": "tf.minimum(in1, tf.constant(1))",
        "description": "clip values that are greater than 1",
        "tf_operators": {
            "tf.float32": 9,
            "tf.constant": 10,
            "tf.float32.max": 4,
            "tf.clip_by_value": 10,
            "tf.reduce_min": 1,
            "tf.float32.min": 2
        },
        "coverage_percentage": 50.0,
        "total_in_target": 2,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_03",
        "completions": [
            "\ntensor1 = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\ntensor2 = tf.constant([[-6, -5], [14, 15]])\n\nindices = tf.constant([[0, 3], [0, 4], [1, 3], [1, 4]])\n\nupdates = tf.reshape(tensor2, [-1])\n\noutput = tf.tensor_scatter_nd_update(tensor1, indices, updates)\n",
            "\ntensor1 = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\ntensor2 = tf.constant([[-6, -5], [14, 15]])\n\nindices = tf.constant([[0, 3], [0, 4], [1, 3], [1, 4]])\n\nupdates = tf.reshape(tensor2, [-1])\n\nupdated_tensor = tf.tensor_scatter_nd_update(tensor1, indices, updates)\n\nwith tf.Session() as sess:\n    print(sess.run(updated_tensor))\n",
            "\ntensor1 = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\ntensor2 = tf.constant([[-6, -5], [14, 15]])\n\nindices = tf.constant([[0, 3], [0, 4], [1, 3], [1, 4]])\n\nvalues = tf.reshape(tf.gather(tensor2, [0, 1], axis=1), [-1])\n\noutput = tf.tensor_scatter_nd_update(tensor1, indices, values)\n",
            "\ntensor1 = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\ntensor2 = tf.constant([-6, -5, 14, 15])\n\nindices = tf.constant([[0, 3], [0, 4], [1, 3], [1, 4]])\n\nupdates = tensor2\n\noutput = tf.tensor_scatter_nd_update(tensor1, indices, updates)\n",
            "\ntensor1 = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\n\ntensor2 = tf.constant([[-6, -5], [14, 15]])\n\ntensor1_left = tf.slice(tensor1, [0, 0], [-1, 3])\ntensor1_right = tf.slice(tensor1, [0, 5], [-1, -1])\n\noutput = tf.concat([tensor1_left, tensor2, tensor1_right], axis=1)\n",
            "\noriginal = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\n\nreplacement = tf.constant([-6, -5, 14, 15])\n\nindices = tf.constant([[0, 3], [0, 4], [1, 3], [1, 4]])\n\nresult = tf.tensor_scatter_nd_update(original, indices, replacement)\n\n",
            "\ntensor1 = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\ntensor2 = tf.constant([[-6, -5], [14, 15]])\n\nindices = tf.constant([[0, 3], [0, 4], [1, 3], [1, 4]])\n\nnew_columns = tf.reshape(tensor2, [-1])\n\nresult = tf.tensor_scatter_nd_update(tensor1, indices, new_columns)\n\n",
            "\na = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\nb = tf.constant([[-6, -5], [14, 15]])\n\nindices = tf.constant([[0, 3], [0, 4], [1, 3], [1, 4]])\n\nupdated_a = tf.tensor_scatter_nd_update(a, indices, tf.reshape(b, [-1]))\n\nwith tf.Session() as sess:\n    print(sess.run(updated_a))\n",
            "\ndata = [[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]]\n\ndata_tensor = tf.constant(data)\n\nindices = tf.constant([[0,3], [0,4], [1,3], [1,4]])\n\nupdates = tf.constant([-6, -5, 14, 15])\n\nresult = tf.tensor_scatter_nd_update(data_tensor, indices, updates)\n\n",
            "\ntensor1 = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\n\ntensor2 = tf.constant([[-6, -5], [14, 15]])\n\nindices = tf.constant([[0, 3], [0, 4], [1, 3], [1, 4]])\n\nupdates = tf.reshape(tensor2, [-1])\n\noutput = tf.tensor_scatter_nd_update(tensor1, indices, updates)\n"
        ],
        "target-program": "tf.reduce_sum(tf.one_hot(tf.range(3, 5), depth=in1.shape[1], dtype=tf.int32), axis=0) * in2 + (1 - tf.reduce_sum(tf.one_hot(tf.range(3, 5), depth=in1.shape[1], dtype=tf.int32), axis=0)) * in1",
        "description": "replace certain columns with columns from the other tensor",
        "tf_operators": {
            "tf.constant": 10,
            "tf.reshape": 6,
            "tf.tensor_scatter_nd_update": 9,
            "tf.Session": 2,
            "tf.gather": 1,
            "tf.slice": 1,
            "tf.concat": 1
        },
        "coverage_percentage": 0.0,
        "total_in_target": 4,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_04",
        "completions": [
            "\ndef index_into_tensor(data):\n    tensor_data = tf.constant(data)\n    indexed_data = tf.gather(tensor_data, indices=[0], axis=1)\n    return tf.stack([indexed_data, indexed_data], axis=1)\n\ndata = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n",
            "\ndef index_into_tensor(data):\n    tensor = tf.constant(data)\n    result = tf.gather(tensor, indices=[0, 0], axis=1)\n    return result.numpy()\n",
            "\ndef update_tensor(tensor):\n    tensor = tf.constant(tensor)\n    indices = tf.constant([[i, 1] for i in range(tf.shape(tensor)[0])])\n    updates = tensor[:, 0]\n    return tf.tensor_scatter_nd_update(tensor, indices, updates).numpy().tolist()\n\ntensor = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n",
            "\ndata = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n\ntensor = tf.constant(data)\n\nindexed_tensor = tf.gather(tensor, [0, 0], axis=1)\n\noutput = tf.reshape(indexed_tensor, tf.shape(tensor))\n\n",
            "\ndef duplicate_first_item(tensor):\n    indices = tf.zeros((tf.shape(tensor)[0],), dtype=tf.int32)\n    return tf.gather(tensor, indices, axis=1)\n\ntensor = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\noutput = duplicate_first_item(tensor)\n",
            "\ntensor = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\n\noutput = tf.gather(tensor, indices=0, axis=1)\n\noutput = tf.stack([output, output], axis=1)\n",
            "\ndef index_into_tensor(tensor):\n    tensor = tf.constant(tensor, dtype=tf.float32)\n    indices = tf.constant([[i, 1] for i in range(tf.shape(tensor)[0])])\n    updates = tf.gather_nd(tensor, [[i, 0] for i in range(tf.shape(tensor)[0])])\n    return tf.tensor_scatter_nd_update(tensor, indices, updates).numpy().tolist()\n\n",
            "\ninput_tensor = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\nindices = tf.constant([0, 0])\n\noutput_tensor = tf.gather(input_tensor, indices, axis=1)\n",
            "\ninput_tensor = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\n\nindices = tf.zeros(input_tensor.shape, dtype=tf.int32)\n\noutput_tensor = tf.gather(input_tensor, indices, axis=1)\n\n",
            "\ndef index_into_tensor(input_list):\n    tensor = tf.constant(input_list)\n    first_elements = tensor[:, 0:1]\n    modified_tensor = tf.concat([first_elements, first_elements], axis=1)\n    return modified_tensor.numpy().tolist()\n\ninput_list = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n"
        ],
        "target-program": "tf.gather_nd(in1, tf.stack((in2, in3), axis=-1))",
        "description": "index into the tensor",
        "tf_operators": {
            "tf.gather": 7,
            "tf.constant": 10,
            "tf.stack": 2,
            "tf.tensor_scatter_nd_update": 2,
            "tf.shape": 4,
            "tf.reshape": 1,
            "tf.int32": 2,
            "tf.zeros": 2,
            "tf.float32": 1,
            "tf.gather_nd": 1,
            "tf.concat": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 2,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_05",
        "completions": [
            "\ndef tensor_multiplication(tensor):\n    if len(tensor) == 2:\n        result = tf.tensordot(tensor[0], tensor[1], axes=2)\n    else:\n        result = tf.tensordot(tensor[0], tensor[1], axes=1)\n    return result.numpy().tolist()\n",
            "\ndef tensordot_operation(input_tensor):\n    tensor1 = tf.constant(input_tensor)\n    tensor2 = tf.constant([[1, 2]])\n    result = tf.tensordot(tensor1, tensor2, axes=1)\n    return result.numpy().tolist()\n",
            "\ndef tensor_multiplication(tensor):\n    return tf.tensordot(tensor[0], tensor[1], axes=1)\n",
            "\ndef tensor_multiplication(input_tensor):\n    return tf.tensordot(input_tensor, input_tensor, axes=len(input_tensor.shape))\n",
            "\ndef tensor_mul(a, b):\n    return tf.tensordot(a, b, axes=1)\n\n",
            "\ndef tensor_multiplication(input_tensor):\n    return tf.tensordot(input_tensor[0], input_tensor[1], axes=-1)\n",
            "\ndef tensor_multiplication(input_tensor):\n    tensor = tf.constant(input_tensor)\n    result = tf.tensordot(tensor, tensor, axes=[[0, 1], [0, 1]])\n    return result\n",
            "\ndef tensor_dot(a, b):\n    return tf.tensordot(a, b, [[len(a.shape)-1], [len(b.shape)-2]])\n\na = tf.constant([[4, 3, 1], [6, 5, 2]])\nb = tf.constant([[5, 5], [1, 5], [6, 0]])\n",
            "\ndef tensor_multiply(tensor):\n    if len(tensor) == 2:\n        return tf.tensordot(tensor[0], tensor[1], axes=1)\n    elif len(tensor) == 3:\n        return tf.tensordot(tensor[0], tensor[1], axes=2)\n",
            "\ndef tensor_mul(input_tensor):\n    input_tensor = tf.constant(input_tensor)\n    output_tensor = tf.tensordot(input_tensor, input_tensor, axes=[[0,1],[1,0]])\n    return output_tensor.numpy()\n"
        ],
        "target-program": "tf.tensordot(in1, in2, 1)",
        "description": "tensor multiplication like np.tensordot",
        "tf_operators": {
            "tf.tensordot": 10,
            "tf.constant": 4
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_06",
        "completions": [
            "\ndef binary_tensor(vector):\n    tensor = tf.constant(vector)\n    first_element = tensor[0]\n    equal_tensor = tf.equal(tensor, first_element)\n    binary_tensor = tf.cast(equal_tensor, tf.float32)\n    return binary_tensor\n\nvector = [3, 5, 0, 2, 3, 3, 0]\n",
            "\nvector = tf.constant([3, 5, 0, 2, 3, 3, 0])\n\nequal_to_3 = tf.equal(vector, 3)\n\nbinary_tensor = tf.cast(equal_to_3, tf.float32)\n\n",
            "\nvector = tf.constant([3, 5, 0, 2, 3, 3, 0], dtype=tf.float32)\n\nfirst_element = vector[0]\n\nbinary_tensor = tf.cast(tf.equal(vector, first_element), tf.float32)\n\n",
            "\ndef binary_tensor_from_vector(vector):\n    tensor = tf.constant(vector)\n    first_element = tensor[0]\n    first_element_tensor = tf.fill(tf.shape(tensor), first_element)\n    equal_tensor = tf.equal(tensor, first_element_tensor)\n    binary_tensor = tf.cast(equal_tensor, tf.float32)\n    return binary_tensor\n",
            "\ndef binary_tensor(vector):\n    first_element = vector[0]\n    equal_to_first = tf.equal(vector, first_element)\n    binary_tensor = tf.cast(equal_to_first, tf.float32)\n    return binary_tensor\n\nvector = tf.constant([3, 5, 0, 2, 3, 3, 0])\n",
            "\ndef binary_tensor_from_vector(vector):\n    tensor = tf.constant(vector)\n    binary_tensor = tf.equal(tensor, tensor[0])\n    binary_tensor = tf.cast(binary_tensor, tf.float32)\n    return binary_tensor\n\nvector = [3, 5, 0, 2, 3, 3, 0]\n",
            "\ndef binary_tensor(vector):\n    tensor = tf.constant(vector)\n    first_element = tensor[0]\n    binary_tensor = tf.cast(tf.equal(tensor, first_element), tf.float32)\n    return binary_tensor\n",
            "\ndef binary_tensor_from_vector(vector):\n    vector = tf.constant(vector, dtype=tf.float32)\n    first_element = vector[0]\n    binary_tensor = tf.cast(tf.equal(vector, first_element), tf.float32)\n    return binary_tensor\n\nvector = [3, 5, 0, 2, 3, 3, 0]\n",
            "\nvector = [3, 5, 0, 2, 3, 3, 0]\n\ntensor = tf.constant(vector, dtype=tf.float32)\n\nequal_to_first = tf.equal(tensor, tensor[0])\n\nbinary_tensor = tf.cast(equal_to_first, tf.float32)\n\n",
            "\ndef binary_tensor_from_vector(vector):\n    tensor = tf.constant(vector)\n    first_element = tensor[0]\n    binary_tensor = tf.cast(tf.equal(tensor, first_element), tf.float32)\n    return binary_tensor\n"
        ],
        "target-program": "tf.cast(tf.equal(in1, tf.expand_dims(in1, 1)), tf.float32)",
        "description": "binary tensor from vector indicating if elements are equal",
        "tf_operators": {
            "tf.cast": 10,
            "tf.constant": 10,
            "tf.float32": 10,
            "tf.equal": 10,
            "tf.fill": 1,
            "tf.shape": 1
        },
        "coverage_percentage": 75.0,
        "total_in_target": 4,
        "total_covered": 3
    },
    {
        "task_id": "stackoverflow_07",
        "completions": [
            "\ntensor = [[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]]\n\ntransposed_tensor = tf.transpose(tensor, perm=[1, 0, 2])\n\noutput = tf.gather(transposed_tensor, 0, axis=0)\n\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\nresult = tf.transpose(tensor, perm=[1, 0, 2])\n\noutput = result[0].numpy().tolist()\n\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\nresult = tf.transpose(tensor, perm=[1, 0, 2])\n\noutput = result[0]\n\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\nswapped_tensor = tf.transpose(tensor, perm=[1, 0, 2])\n\noutput = swapped_tensor[0].numpy().tolist()\n\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\ntensor_swapped = tf.transpose(tensor, perm=[1, 0, 2])\n\noutput = tensor_swapped[0].numpy().tolist()\n\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\ntensor_transposed = tf.transpose(tensor, perm=[1, 0, 2])\n\noutput = tensor_transposed[0]\n",
            "\ndata = [[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]]\n\ntensor = tf.constant(data)\n\noutput = tf.transpose(tensor, perm=[1, 0, 2])\n\noutput = output[0]\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\ntransposed_tensor = tf.transpose(tensor, perm=[1, 0, 2])\n\nresult = tf.gather(transposed_tensor, 0, axis=0)\n\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\nswapped_tensor = tf.transpose(tensor, perm=[1, 0, 2])\n\nresult = swapped_tensor[0]\n\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\nresult = tf.strided_slice(tensor, [0, 0, 0], tf.shape(tensor), [1, 1, 1])\n\nresult.numpy()\n"
        ],
        "target-program": "tf.cast(tf.unstack(in1, axis=1), tf.int32)",
        "description": "swap the first two dimensions of the tensor",
        "tf_operators": {
            "tf.gather": 2,
            "tf.transpose": 9,
            "tf.constant": 9,
            "tf.strided_slice": 1,
            "tf.shape": 1
        },
        "coverage_percentage": 0.0,
        "total_in_target": 3,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_08",
        "completions": [
            "\ndef select_values(input):\n    tensor1 = tf.constant(input)\n    tensor2 = tf.range(1, len(input) + 1)\n    mask = tf.greater(tensor1, 1)\n    result = tf.boolean_mask(tensor2, mask)\n    return result\n",
            "\ndef select_values(first_tensor, second_tensor):\n    mask = tf.greater(first_tensor, 1)\n    selected_values = tf.boolean_mask(second_tensor, mask)\n    return selected_values\n",
            "\ndef select_values(first_tensor):\n    first_tensor = tf.constant(first_tensor)\n    second_tensor = tf.range(0, tf.size(first_tensor), 1)\n    mask = tf.greater(first_tensor, 1)\n    output = tf.boolean_mask(second_tensor, mask)\n    return tf.size(output)\n\n",
            "\ndef get_count_of_values(input_list):\n    input_tensor = tf.constant(input_list, dtype=tf.int32)\n    mask = tf.greater(input_tensor, 1)\n    second_tensor = tf.range(len(input_list))\n    result = tf.boolean_mask(second_tensor, mask)\n    count = tf.size(result)\n    return count.numpy()\n\n",
            "\ndef select_values(tensor1, tensor2):\n    mask = tf.greater(tensor1, 1)\n    output = tf.boolean_mask(tensor2, mask)\n    return output\n",
            "\ndef select_values(input_data):\n    tensor1 = tf.constant(input_data)\n    tensor2 = tf.range(len(input_data))\n    mask = tf.greater(tensor1, 1)\n    result = tf.boolean_mask(tensor2, mask)\n    return result.numpy().size\n\n",
            "\ndef select_values(input_list):\n    # Create the tensors\n    tensor1 = tf.range(len(input_list))\n    tensor2 = tf.constant(input_list)\n\n    # Create the boolean mask\n    mask = tf.greater(tensor1, 1)\n\n    # Select the values in the second tensor\n    selected_values = tf.boolean_mask(tensor2, mask)\n\n    return selected_values\n",
            "\ndef select_values(first_tensor):\n    first_tensor = tf.constant(first_tensor)\n    second_tensor = tf.range(tf.size(first_tensor))\n    mask = tf.greater(first_tensor, 1)\n    result = tf.boolean_mask(second_tensor, mask)\n    return result\n",
            "\ndef count_greater_than_one(input_list):\n    # Create tensors\n    tensor1 = tf.constant(input_list, dtype=tf.int32)\n    tensor2 = tf.range(tf.size(tensor1), dtype=tf.int32)\n\n    # Create a boolean mask where tensor1 > 1\n    mask = tf.greater(tensor1, 1)\n\n    # Apply the mask to tensor2 and count the number of elements\n    result = tf.size(tf.boolean_mask(tensor2, mask))\n\n    return result.numpy()\n",
            "\ndef select_values(tensor1):\n    mask = tf.greater(tensor1, 1)\n    selected_values = tf.boolean_mask(tensor1, mask)\n    return tf.size(selected_values)\n\ntensor1 = tf.constant([-1, 0, -3, 2, 1, 3, 5, -1, -9, 2, 10])\n\ntensor2 = tf.constant([12, 3, 45, 6, 7, 8, 9, 87, 65, 4, 32])\n"
        ],
        "target-program": "tf.boolean_mask(in2, tf.greater(in1, tf.constant(1)))",
        "description": "(\\'select the values in the second tensor where the first tensor is greater than 1\\')",
        "tf_operators": {
            "tf.constant": 8,
            "tf.boolean_mask": 10,
            "tf.range": 7,
            "tf.greater": 10,
            "tf.size": 5,
            "tf.int32": 2
        },
        "coverage_percentage": 100.0,
        "total_in_target": 3,
        "total_covered": 3
    },
    {
        "task_id": "stackoverflow_09",
        "completions": [
            "\ndef group_items(input):\n    _, idx, counts = tf.unique_with_counts(input)\n    return tf.argmax(counts)\n\ninput = tf.constant([37, 42, 42, 37, 28, 15, 42, 15], dtype=tf.int32)\n",
            "\nx = tf.constant([37, 42, 42, 37, 28, 15, 42, 15])\ny, idx, count = tf.unique_with_counts(x)\n\nwith tf.Session() as sess:\n    print(sess.run(idx))\n",
            "\ndef group_items_by_value(input):\n    _, idx, _ = tf.unique_with_counts(input)\n    return idx.numpy()\n\n",
            "\ndef group_items_by_value(items):\n    tensor = tf.constant(items)\n    unique_values, _ = tf.unique(tensor)\n    group_indices = [tf.where(tf.equal(tensor, value)).numpy().flatten().tolist() for value in unique_values.numpy()]\n    return group_indices\n\nitems = [37, 42, 42, 37, 28, 15, 42, 15]\n",
            "\ndef group_items(input):\n    y, idx, count = tf.unique_with_counts(input)\n    return idx\ninput = [37, 42, 42, 37, 28, 15, 42, 15]\n",
            "\ndef group_items_by_value(input):\n    unique_values, indices = tf.unique(input)\n    return indices.numpy()\n\ninput = tf.constant([37, 42, 42, 37, 28, 15, 42, 15])\n",
            "\ndef group_indices(lst):\n    unique, _, count = tf.unique_with_counts(lst)\n    indices_dict = {key.numpy(): [] for key in unique.numpy()}\n    for i, item in enumerate(lst):\n        indices_dict[item.numpy()].append(i)\n    return indices_dict\n\nlst = tf.constant([37, 42, 42, 37, 28, 15, 42, 15], tf.int32)\n",
            "\ndata = [37, 42, 42, 37, 28, 15, 42, 15]\n\ndata_tensor = tf.constant(data)\n\nunique_values, indices = tf.unique(data_tensor)\n\n",
            "\nlst = [37, 42, 42, 37, 28, 15, 42, 15]\n\ntensor = tf.constant(lst)\n\ny, idx, count = tf.unique_with_counts(tensor)\n\n",
            "\ndef group_items_by_value(input):\n    _, idx, counts = tf.unique_with_counts(input)\n    return idx.numpy()\n\ninput = tf.constant([37, 42, 42, 37, 28, 15, 42, 15])\n"
        ],
        "target-program": "tf.unique_with_counts(in1)[1]",
        "description": "group items by value and get the group indices",
        "tf_operators": {
            "tf.constant": 8,
            "tf.argmax": 1,
            "tf.unique_with_counts": 7,
            "tf.int32": 2,
            "tf.Session": 1,
            "tf.where": 1,
            "tf.equal": 1,
            "tf.unique": 3
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_10",
        "completions": [
            "\ndef matrix_mult(matrix):\n    matrix = tf.constant(matrix, dtype=tf.int32)\n    transpose = tf.transpose(matrix)\n    result = tf.matmul(matrix, transpose)\n    return result.numpy()\n",
            "\nmatrix1 = tf.constant([[1, 2], [3, 4]])\nmatrix2 = tf.constant([[5, 6], [7, 8]])\n\nresult = tf.matmul(matrix1, matrix2)\n",
            "",
            "\nmatrix1 = tf.constant([[15, 10], [20, -5]])\nmatrix2 = tf.constant([[1, 2, 3], [4, 5, 6]])\n\nresult = tf.matmul(matrix1, matrix2)\n\n",
            "",
            "\nmatrix1 = tf.constant([[15, 10], [20, -5]])\nmatrix2 = tf.constant([[2, 3], [-2, 5]])\n\nresult = tf.matmul(matrix1, matrix2)\n\n",
            "",
            "\ndef matrix_multiplication(matrix):\n    tensor = tf.constant(matrix)\n    transpose = tf.transpose(tensor)\n    result = tf.linalg.matmul(tensor, transpose)\n    return result.numpy()\n",
            "\nmatrix1 = tf.constant([[15, 10], [20, -5]])\nmatrix2 = tf.constant([[1, 2, 3], [4, 5, 6]])\n\nresult = tf.matmul(matrix1, matrix2)\n",
            "\ninput_matrix = tf.constant([[15, 10], [20, -5]], dtype=tf.int32)\nfixed_matrix = tf.constant([[1, 2, 3], [4, 5, 6]], dtype=tf.int32)\n\noutput_matrix = tf.matmul(input_matrix, fixed_matrix)\n\n"
        ],
        "target-program": "tf.matmul(tf.expand_dims(in1, -1), tf.expand_dims(in2, 1))",
        "description": "perform matrix multiplication",
        "tf_operators": {
            "tf.matmul": 6,
            "tf.constant": 7,
            "tf.transpose": 2,
            "tf.int32": 2,
            "tf.linalg.matmul": 1
        },
        "coverage_percentage": 50.0,
        "total_in_target": 2,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_11",
        "completions": [
            "\ninput_list = [4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1]\n\ninput_tensor = tf.constant(input_list)\n\nunique_values, _, counts = tf.unique_with_counts(input_tensor)\n\noutput_dict = dict(zip(unique_values.numpy(), counts.numpy()))\n\n",
            "\ndef count_distinct_numbers(input):\n    _, _, counts = tf.unique_with_counts(input)\n    return tf.size(counts)\n\ninput = tf.constant([4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1])\noutput = count_distinct_numbers(input)\n",
            "\ndef count_occurrences(input_list):\n    _, _, count = tf.unique_with_counts(input_list)\n    return count.numpy()\n\ninput_list = tf.constant([4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1])\n",
            "\ndata = [4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1]\n\ndata_tensor = tf.constant(data)\n\nunique, idx, counts = tf.unique_with_counts(data_tensor)\n\nfor u, c in zip(unique.numpy(), counts.numpy()):\n    print(f\"Element {u} occurs {c} times\")\n",
            "\ndata = [4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1]\n\ntensor = tf.constant(data)\n\n_, _, count = tf.unique_with_counts(tensor)\n\n",
            "\ndef count_occurrences(input_tensor):\n    _, _, count = tf.unique_with_counts(input_tensor)\n    return count\n\ninput_tensor = tf.constant([4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1], tf.int32)\noutput_tensor = count_occurrences(input_tensor)\n\n",
            "\ndef count_occurrences(input_list):\n    tensor = tf.constant(input_list)\n    _, _, count = tf.unique_with_counts(tensor)\n    return count\n\ninput_list = [4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1]\n",
            "\ndef count_distinct_numbers(numbers):\n    tensor = tf.constant(numbers)\n    unique_numbers, _ = tf.unique_with_counts(tensor)\n    return len(unique_numbers.numpy())\n\nnumbers = [4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1]\n",
            "\ninput_list = [4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1]\n\ninput_tensor = tf.constant(input_list)\n\n_, _, counts = tf.unique_with_counts(input_tensor)\n\n",
            "\ndef count_occurrences(array):\n    tensor = tf.constant(array)\n    _, _, counts = tf.unique_with_counts(tensor)\n    return counts\n\narray = [4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1]\n"
        ],
        "target-program": "tf.math.bincount(in1)",
        "description": "count the number of occurences of each distinct number",
        "tf_operators": {
            "tf.constant": 10,
            "tf.unique_with_counts": 10,
            "tf.size": 1,
            "tf.int32": 1
        },
        "coverage_percentage": 0.0,
        "total_in_target": 1,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_12",
        "completions": [
            "\ntensor = tf.constant([[12, 34, 56], [33, 22, 11]])\n\nindices = [0, 2]\n\nresult = tf.gather(tensor, indices, axis=1)\n",
            "\ndata = [[12, 34, 56], [33, 22, 11]]\n\ntensor = tf.constant(data)\n\nselected_columns = tf.gather(tensor, [0, 2], axis=1)\n\noutput = tf.reshape(selected_columns, [-1])\n\n",
            "\ntensor = tf.constant([[12, 34, 56], [33, 22, 11]])\n\nindices = [0, 2]\n\nresult = tf.gather(tensor, indices, axis=1)\n\n",
            "\ninput_tensor = tf.constant([[12, 34, 56], [33, 22, 11]])\n\noutput_tensor = tf.concat([tf.slice(input_tensor, [0, 0], [2, 1]), tf.slice(input_tensor, [0, 2], [2, 1])], 1)\n\n",
            "\ndata = [[12, 34, 56], [33, 22, 11]]\n\ntensor = tf.constant(data)\n\nresult = tf.gather(tensor, [0, 2], axis=1)\n\noutput = result.numpy().tolist()\n\n",
            "\ndata = [[12, 34, 56], [33, 22, 11]]\n\ntensor = tf.constant(data)\n\noutput = tf.gather(tensor, [0, 2], axis=1)\n\n",
            "\ntensor = tf.constant([[12, 34, 56], [33, 22, 11]])\n\nslice1 = tf.slice(tensor, [0, 0], [2, 1])\n\nslice3 = tf.slice(tensor, [0, 2], [2, 1])\n\noutput = tf.concat([slice1, slice3], 1)\n\n",
            "\ntensor = tf.constant([[12, 34, 56], [33, 22, 11]])\n\nstart = tf.constant([0, 0])\nsize = tf.constant([-1, 2])\n\nresult = tf.slice(tensor, start, size)\n\n",
            "\ninput_data = [[12, 34, 56], [33, 22, 11]]\n\ntensor_data = tf.constant(input_data)\n\nselected_columns = tf.gather(tensor_data, [0, 2], axis=1)\n\noutput = tf.reshape(selected_columns, [-1])\n\n",
            "\ntensor = tf.constant([[12, 34, 56], [33, 22, 11]])\n\nindices = [0, 2]\n\noutput = tf.transpose(tf.gather(tf.transpose(tensor), indices))\n\n"
        ],
        "target-program": "tf.gather(in1, (0, 2), axis=1, batch_dims=0)",
        "description": "remove a column from the tensor",
        "tf_operators": {
            "tf.gather": 7,
            "tf.constant": 10,
            "tf.reshape": 2,
            "tf.slice": 3,
            "tf.concat": 2,
            "tf.transpose": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_13",
        "completions": [
            "\ndef multiply_vectors_by_tensor(input_list):\n    tensor = tf.constant([[7, 4], [2, 10]])\n    return tf.multiply(input_list, tensor)\n\ninput_list = [[3, 5], [10, 2]]\noutput = multiply_vectors_by_tensor(input_list)\n",
            "\ndef multiply_by_tensor(vector):\n    tensor = tf.constant([[7, 4], [3, 10]], dtype=tf.int32)\n    vector = tf.constant(vector, dtype=tf.int32)\n    result = tf.matmul(vector, tensor)\n    return result.numpy()\n",
            "\ndef multiply_vectors_by_tensor(input_tensor):\n    tensor2 = tf.constant([[4, 4], [1, 10]])\n    return tf.multiply(input_tensor, tensor2)\n",
            "\ninput_data = [[3, 5], [10, 2]]\n\ntensor = tf.constant(input_data)\n\ntensor_to_multiply = tf.constant([[4, 1], [3, 4]])\n\noutput = tf.linalg.matvec(tensor_to_multiply, tensor)\n\n",
            "\ndef multiply_vectors_by_tensor(tensor):\n    vector = tf.constant([4, 7])\n    return tf.multiply(tensor, vector)\n",
            "\ndef multiply_tensors(input_tensor):\n    constant_tensor = tf.constant([[4, 4], [1, 10]])\n    result = tf.multiply(input_tensor, constant_tensor)\n    return result\n",
            "\nvector = tf.constant([[3, 5], [10, 2]])\ntensor = tf.constant([[2, 3], [4, 5]])\n\nresult = tf.multiply(vector, tensor)\n\n",
            "\ninput_tensor = tf.constant([[[1, 0], [5, 4]], [[3, 10], [2, -2]]], dtype=tf.float32)\n\nmultiplier = tf.divide(output_tensor[0], input_tensor[0])\n\noutput_tensor = tf.multiply(input_tensor, multiplier)\n",
            "\ntensor = tf.constant([[[1, 0], [5, 4]], [[3, 10], [2, -2]]])\nvector = tf.constant([2, 3])\n\noutput = tf.map_fn(lambda x: tf.linalg.matvec(x, vector), tensor)\n",
            "\ntensor2 = tf.constant([[7, 4], [1, 10]])\n\ninput_tensor = tf.constant([[3, 5], [10, 2]])\n\noutput_tensor = tf.multiply(input_tensor, tensor2)\n"
        ],
        "target-program": "tf.tensordot(in1, in2, (1, 1))",
        "description": "multiply vectors by tensor",
        "tf_operators": {
            "tf.constant": 10,
            "tf.multiply": 7,
            "tf.matmul": 1,
            "tf.int32": 1,
            "tf.linalg.matvec": 2,
            "tf.float32": 1,
            "tf.divide": 1,
            "tf.map_fn": 1
        },
        "coverage_percentage": 0.0,
        "total_in_target": 1,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_14",
        "completions": [
            "\ndef check_any_true(input_tensor):\n    return tf.reduce_any(input_tensor, axis=1)\n\ninput_data = [[[False, False, True], [False, False, False], [True, False, True], [False, True, False], [False, False, False], [True, True, True], [True, True, False]]]\ninput_tensor = tf.constant(input_data)\noutput = check_any_true(input_tensor)\n",
            "\ndef check_true_in_row(arr):\n    arr = tf.constant(arr)\n    result = tf.reduce_any(arr, axis=1)\n    return result\n",
            "\ndef any_value_true(input_tensor):\n    return tf.reduce_any(input_tensor, axis=1)\n",
            "\ndef any_true_in_row(input_data):\n    tensor_data = tf.constant(input_data)\n    return tf.reduce_any(tensor_data, axis=2)\n",
            "\ndef any_true_in_row(tensor):\n    return tf.reduce_any(tensor, axis=-1)\n",
            "\ndef check_any_true(input_list):\n    input_tensor = tf.constant(input_list)\n    result = tf.reduce_any(input_tensor, axis=1)\n    return result.numpy().tolist()\n\ninput_list = [[[False, False, True], [False, False, False], [True, False, True], [False, True, False], [False, False, False], [True, True, True], [True, True, False]]]\n",
            "\ndef any_true_in_row(input):\n    return tf.reduce_any(input, axis=2)\n\ninput = [[[False, False, True], [False, False, False], [True, False, True], [False, True, False], [False, False, False], [True, True, True], [True, True, False]]]\n",
            "\ndef any_true(input_list):\n    tensor = tf.constant(input_list)\n    result = tf.reduce_any(tensor, axis=1)\n    return result\n\ninput_list = [[[False, False, True], [False, False, False], [True, False, True], \n               [False, True, False], [False, False, False], [True, True, True], \n               [True, True, False]]]\n",
            "\ndef check_rows(input):\n    tensor = tf.constant(input)\n    result = tf.reduce_any(tensor, axis=1)\n    return result\n\ninput = [[[False, False, True], [False, False, False], [True, False, True], [False, True, False], [False, False, False], [True, True, True], [True, True, False]]]\n",
            "\ndata = [[[false, false, true], [false, false, false], [true, false, true], [false, true, false], [false, false, false], [true, true, true], [true, true, false]]]\n\ntensor = tf.constant(data)\n\nresult = tf.reduce_any(tensor, axis=2)\n"
        ],
        "target-program": "tf.reduce_any(in1, axis=-1)",
        "description": "choose True if any value in a row is True, False otherwise",
        "tf_operators": {
            "tf.constant": 7,
            "tf.reduce_any": 10
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_15",
        "completions": [
            "\ninput_list = [3, 1, 2, 0, 1, -1, 10, 1, -10]\n\ntensor = tf.constant(input_list)\n\noutput_tensor = tf.where(tf.equal(tensor, 1), 0, tensor)\n\n",
            "\ndata = tf.constant([3, 1, 2, 0, 1, -1, 10, 1, -10])\n\nindices = tf.where(tf.equal(data, 1))\n\nupdates = tf.zeros(shape=tf.shape(indices)[0], dtype=data.dtype)\n\nresult = tf.tensor_scatter_nd_update(data, indices, updates)\n",
            "\ninput_list = [3, 1, 2, 0, 1, -1, 10, 1, -10]\n\ntensor = tf.constant(input_list)\n\nindices = tf.where(tf.equal(tensor, 1))\n\nupdates = tf.zeros(shape=indices.shape[0], dtype=tensor.dtype)\n\noutput_tensor = tf.tensor_scatter_nd_update(tensor, indices, updates)\n",
            "\ntensor = tf.constant([3, 1, 2, 0, 1, -1, 10, 1, -10])\n\noutput = tf.where(tf.equal(tensor, 1), 0, tensor)\n\n",
            "\ninput_list = [3, 1, 2, 0, 1, -1, 10, 1, -10]\n\ninput_tensor = tf.constant(input_list)\n\noutput_tensor = tf.where(tf.equal(input_tensor, 1), 0, input_tensor)\n\n",
            "\ninput_list = [3, 1, 2, 0, 1, -1, 10, 1, -10]\n\ntensor = tf.constant(input_list)\n\nmask = tf.equal(tensor, 1)\n\noutput = tf.where(mask, 0, tensor)\n\n",
            "\ninput_list = [3, 1, 2, 0, 1, -1, 10, 1, -10]\n\ninput_tensor = tf.constant(input_list)\n\noutput_tensor = tf.where(tf.equal(input_tensor, 1), 0, input_tensor)\n\n",
            "\nx = [3, 1, 2, 0, 1, -1, 10, 1, -10]\n\nx = tf.constant(x)\n\nx = tf.where(tf.equal(x, 1), 0, x)\n\n",
            "\nlst = [3, 1, 2, 0, 1, -1, 10, 1, -10]\n\ntensor = tf.constant(lst)\n\noutput = tf.where(tensor != 1, tensor, 0)\n\n",
            "\ninput_list = [3, 1, 2, 0, 1, -1, 10, 1, -10]\n\ntensor = tf.convert_to_tensor(input_list)\n\noutput_tensor = tf.where(tf.equal(tensor, 1), 0, tensor)\n\n"
        ],
        "target-program": "tf.subtract(in1, tf.cast(tf.equal(in1, tf.constant(1)), tf.int32))",
        "description": "set all instances of 1 to 0",
        "tf_operators": {
            "tf.where": 10,
            "tf.constant": 9,
            "tf.equal": 9,
            "tf.shape": 1,
            "tf.zeros": 2,
            "tf.tensor_scatter_nd_update": 2,
            "tf.convert_to_tensor": 1
        },
        "coverage_percentage": 40.0,
        "total_in_target": 5,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_16",
        "completions": [
            "\ndef multiply_tensors(input_tensor):\n    return tf.reduce_prod(input_tensor, axis=0)\n",
            "\ndef multiply_tensors(input_tensor):\n    tensor = tf.constant(input_tensor)\n    result = tf.reduce_prod(tensor, axis=1)\n    return result.numpy().tolist()\n",
            "\ndef multiply_tensors(input_tensor):\n    return tf.reduce_prod(input_tensor, axis=1)\n",
            "\ndef multiply_tensors(input_tensor):\n    input_tensor = tf.constant(input_tensor)\n    output_tensor = tf.reduce_prod(input_tensor, axis=0)\n    return output_tensor.numpy().tolist()\n",
            "\ndef multiply_tensors(tensor):\n    tensor = tf.constant(tensor)\n    result = tf.reduce_prod(tensor, axis=0)\n    return result.numpy()\n",
            "\ndef multiply_tensors(input_list):\n    tensor = tf.constant(input_list)\n    result = tf.reduce_prod(tensor, axis=0)\n    return result.numpy().tolist()\n",
            "\ndef multiply_tensors(tensor):\n    tensor = tf.convert_to_tensor(tensor)\n    result = tf.reduce_prod(tensor, axis=0)\n    return result.numpy().tolist()\n",
            "\ndef multiply_tensors_across_first_axis(input_tensor):\n    tensor = tf.constant(input_tensor)\n    product = tf.reduce_prod(tensor, axis=0)\n    return product.numpy().tolist()\n",
            "\ndef multiply_tensors(tensor):\n    tensor = tf.convert_to_tensor(tensor)\n    result = tf.reduce_prod(tensor, axis=0)\n    return result.numpy()\n",
            "\ndef multiply_tensors(input_list):\n    tensor = tf.constant(input_list)\n    result = tf.reduce_prod(tensor, axis=0)\n    return result.numpy().tolist()\n"
        ],
        "target-program": "tf.multiply(in1, tf.expand_dims(in2, 1))",
        "description": "multiply tensors across the first axis",
        "tf_operators": {
            "tf.reduce_prod": 10,
            "tf.constant": 6,
            "tf.convert_to_tensor": 2
        },
        "coverage_percentage": 0.0,
        "total_in_target": 2,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_17",
        "completions": [
            "\ndef duplicate_elements(input_list):\n    tensor = tf.constant(input_list)\n    duplicated_tensor = tf.repeat(tensor, repeats=2)\n    return duplicated_tensor.numpy().tolist()\n",
            "\ntensor = tf.constant([17, -32, 99])\n\noutput = tf.repeat(tensor, repeats=2)\n\n",
            "\ndef duplicate_elements(tensor):\n    return tf.repeat(tensor, repeats=2)\n\ntensor = tf.constant([17, -32, 99])\noutput = duplicate_elements(tensor)\n",
            "\ninput_tensor = tf.constant([17, -32, 99])\n\noutput_tensor = tf.repeat(input_tensor, repeats=2)\n\n",
            "\ndef duplicate_elements(tensor):\n    result = tf.repeat(tensor, repeats=[2]*len(tensor))\n    return result\n\ntensor = tf.constant([17, -32, 99])\n",
            "\ntensor = tf.constant([17, -32, 99])\n\noutput = tf.repeat(tensor, repeats=2)\n\n",
            "\ndef duplicate_elements(tensor):\n    return tf.repeat(tensor, repeats=2)\n\ntensor = tf.constant([17, -32, 99])\noutput = duplicate_elements(tensor)\n",
            "\ninput_list = [17, -32, 99]\n\ntensor = tf.constant(input_list)\n\noutput = tf.repeat(tensor, repeats=2)\n\n",
            "\ntensor = tf.constant([17, -32, 99])\n\nduplicated_tensor = tf.repeat(tensor, repeats=2)\n\n",
            "\ndef duplicate_elements(tensor):\n    return tf.repeat(tensor, repeats=2)\n\ntensor = tf.constant([17, -32, 99])\noutput = duplicate_elements(tensor)\n"
        ],
        "target-program": "tf.stack((in1, in1), axis=1)",
        "description": "duplicate each element of a tensor",
        "tf_operators": {
            "tf.repeat": 10,
            "tf.constant": 10
        },
        "coverage_percentage": 0.0,
        "total_in_target": 1,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_19",
        "completions": [
            "\ndef sort_tensor(tensor):\n    tensor = tf.constant(tensor)\n    sorted_tensor = tf.sort(tensor, axis=0)\n    sorted_tensor = tf.sort(sorted_tensor, axis=0)\n    return tf.gather(sorted_tensor, 0)\n    \ntensor = [[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]]\n",
            "\ndef sort_tensor(input_list):\n    tensor = tf.constant(input_list)\n    tensor = tf.sort(tensor, axis=0)\n    tensor = tf.sort(tensor, axis=1)\n    return tensor[0].numpy()\n    \ninput_list = [[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]]\n",
            "\ndef sort_tensor(input_list):\n    tensor = tf.constant(input_list)\n    sorted_indices = tf.argsort(tf.gather(tensor, tf.argsort(tensor[:,1]), axis=0)[:,0], axis=0)\n    sorted_tensor = tf.gather(tensor, sorted_indices, axis=0)\n    return sorted_tensor[0].numpy()\n\ninput_list = [[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]]\n",
            "\ndata = [[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]]\n\ntensor = tf.constant(data)\n\nsorted_indices = tf.argsort(tensor[:, :2], axis=0, direction='ASCENDING')\n\nsorted_tensor = tf.gather(tensor, sorted_indices[:, 0])\n\noutput = sorted_tensor[0].numpy()\n",
            "\nx = tf.constant([[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]])\n\nindices = tf.argsort(x[:, 1], direction='ASCENDING')\n\nx = tf.gather(x, indices)\n\nindices = tf.argsort(x[:, 0], direction='ASCENDING')\n\nx = tf.gather(x, indices)\n\n",
            "import numpy as np\n\ntensor = tf.constant([[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]])\n\narray = tensor.numpy()\n\nsorted_indices = np.lexsort((array[:, 1], array[:, 0]))\n\nfirst_row = array[sorted_indices][0]\n\nresult = tf.convert_to_tensor(first_row)\n\n",
            "\ntensor = tf.constant([[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]])\n\nindices = tf.argsort(tensor[:, 0])\n\nfor i in range(tensor.shape[0]-1):\n    if tensor[indices[i], 0] == tensor[indices[i+1], 0]:\n        if tensor[indices[i], 1] > tensor[indices[i+1], 1]:\n            indices[i], indices[i+1] = indices[i+1], indices[i]\n\nsorted_tensor = tf.gather(tensor, indices)\n\n",
            "\ndef sort_tensor(tensor):\n    tensor = tf.constant(tensor, dtype=tf.float32)\n\n    # Add a small constant times the second column to the first column to break ties\n    tensor_with_ties_broken = tensor[:, 0] + 1e-3 * tensor[:, 1]\n\n    # Get the indices that would sort the tensor\n    sorted_indices = tf.argsort(tensor_with_ties_broken)\n\n    # Reorder the rows of the original tensor according to the sorted indices\n    sorted_tensor = tf.gather(tensor, sorted_indices)\n\n    return sorted_tensor.numpy()\n",
            "\ndata = [[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]]\n\ntensor = tf.constant(data)\n\nindices = tf.argsort(tensor, axis=0)\nindices = tf.argsort(indices[:, 0] + indices[:, 1] / tf.reduce_max(indices[:, 1] + 1))\n\nsorted_tensor = tf.gather(tensor, indices)\n\noutput = sorted_tensor[0]\n",
            "\ndef sort_tensor(input_tensor):\n    tensor = tf.constant(input_tensor)\n    sorted_tensor = tf.gather(tensor, tf.lexsort(tf.unstack(tf.reverse(tensor, [-1]))))\n    return sorted_tensor[0].numpy()\n\ninput_tensor = [[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]]\n"
        ],
        "target-program": "tf.gather(tf.gather(in1, tf.argsort(in1[:, 1], stable=True)), tf.argsort(tf.gather(in1, tf.argsort(in1[:, 1], stable=True))[:, 0], stable=True))",
        "description": "(\\'sort a tensor considering the first column, breaking ties using the second column\\')",
        "tf_operators": {
            "tf.gather": 8,
            "tf.constant": 10,
            "tf.sort": 2,
            "tf.argsort": 6,
            "tf.convert_to_tensor": 1,
            "tf.float32": 1,
            "tf.reduce_max": 1,
            "tf.reverse": 1,
            "tf.lexsort": 1,
            "tf.unstack": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 2,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_20",
        "completions": [
            "\ndata = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\n\ntensor = tf.constant(data)\n\nargmax = tf.argmax(tensor, axis=1)\n\n",
            "\ntensor = tf.constant([[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]])\n\nargmax_indices = tf.argmax(tensor, axis=1)\n\nzeros = tf.zeros_like(tensor)\n\noutput = tf.tensor_scatter_nd_update(zeros, tf.expand_dims(argmax_indices, axis=-1), tf.ones_like(argmax_indices))\n\n",
            "\ndef compute_argmax(input_data):\n    tensor_data = tf.constant(input_data)\n    argmax_indices = tf.argmax(tensor_data, axis=1)\n    return argmax_indices.numpy().tolist()\n\ninput_data = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\n",
            "\ndata = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\n\ntensor = tf.constant(data)\n\nindices = tf.argmax(tensor, axis=1)\n\noutput = tf.one_hot(indices, depth=tensor.shape[1])\n\n",
            "\nx = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\n\nx = tf.constant(x)\n\nindices = tf.argmax(x, axis=-1)\n\noutput = tf.one_hot(indices, depth=3, on_value=1, off_value=0)\n\n",
            "\ndef set_argmax_to_one(tensor):\n    tensor = tf.constant(tensor)\n    argmax_indices = tf.argmax(tensor, axis=1)\n    output = [1 if i == argmax else 0 for i, argmax in enumerate(argmax_indices)]\n    return output\n\ntensor = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\n",
            "\ndef set_argmax_to_one(input_data):\n    tensor_data = tf.constant(input_data)\n    argmax_indices = tf.argmax(tensor_data, axis=1)\n    return argmax_indices.numpy().tolist()\n\ninput_data = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\n",
            "\ninput_tensor = tf.constant([[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]])\n\nargmax_tensor = tf.argmax(input_tensor, 1)\n\noutput_tensor = tf.one_hot(argmax_tensor, depth=input_tensor.shape[1])\n\noutput_tensor\n",
            "\ndef set_argmax_to_one(tensor):\n    max_indices = tf.argmax(tensor, axis=1)\n    one_hot_vector = tf.one_hot(max_indices, depth=tf.shape(tensor)[1])\n    return one_hot_vector\n\ntensor = tf.constant([[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]])\n",
            "\ndata = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\n\ntensor_data = tf.convert_to_tensor(data)\n\nargmax_values = tf.argmax(tensor_data, axis=1)\n\n"
        ],
        "target-program": "tf.cast(tf.one_hot(tf.argmax(in1, axis=1), 3), tf.int32)",
        "description": "compute argmax in each tensor and set it to 1",
        "tf_operators": {
            "tf.argmax": 10,
            "tf.constant": 9,
            "tf.ones_like": 1,
            "tf.expand_dims": 1,
            "tf.tensor_scatter_nd_update": 1,
            "tf.zeros_like": 1,
            "tf.one_hot": 4,
            "tf.shape": 1,
            "tf.convert_to_tensor": 1
        },
        "coverage_percentage": 50.0,
        "total_in_target": 4,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_21",
        "completions": [
            "\nindices = tf.constant([[2], [0], [1], [0]])\nvalues = tf.constant([[0.2, 0.5, 0.3], [0.1, 0.3, 0.6], [0.1, 0.6, 0.3], [0.7, 0.0, 0.3]])\n\nresult = tf.gather_nd(values, indices)\n\n",
            "\ndata = tf.constant([[0.2, 0.5, 0.3], [0.1, 0.3, 0.6], [0.1, 0.6, 0.3], [0.7, 0.0, 0.3]])\nindices = tf.constant([[2], [0], [1], [0]])\n\ngathered = tf.gather(data, indices, axis=1)\n\noutput = tf.reduce_mean(gathered)\n",
            "\ndef gather_elements(source, indices):\n    indices = tf.squeeze(indices, axis=-1)  # remove the last dimension from indices\n    batch_indices = tf.range(tf.shape(indices)[0])  # create a range tensor for batch indices\n    gather_indices = tf.stack([batch_indices, indices], axis=1)  # stack batch indices with indices\n    gathered = tf.gather_nd(source, gather_indices)  # gather elements from source\n    return gathered\n",
            "\nparams = tf.constant([[0.2, 0.5, 0.3], [0.1, 0.3, 0.6], [0.1, 0.6, 0.3], [0.7, 0.0, 0.3]])\nindices = tf.constant([[2], [0], [1], [0]])\n\nresult = tf.gather_nd(params, indices)\n\n",
            "\ndef gather_elements(params, indices):\n    return tf.gather_nd(params, indices)\n\nparams = tf.constant([[0.2, 0.5, 0.3], [0.1, 0.3, 0.6], [0.1, 0.6, 0.3], [0.7, 0.0, 0.3]])\nindices = tf.constant([[2], [0], [1], [0]])\n\noutput = gather_elements(params, indices)\n",
            "\ndef gather_elements(tensor):\n    return tf.reduce_min(tensor, axis=1)\n",
            "\ndef gather_elements(input1, input2):\n    tensor1 = tf.constant(input1, dtype=tf.float32)\n    tensor2 = tf.constant(input2, dtype=tf.int32)\n    output = tf.gather_nd(tensor1, tensor2)\n    return output.numpy()\n\ninput1 = [[0.2, 0.5, 0.3], [0.1, 0.3, 0.6], [0.1, 0.6, 0.3], [0.7, 0.0, 0.3]]\ninput2 = [[2], [0], [1], [0]]\n",
            "\ndef gather_elements(input_tensor, indices):\n    input_tensor = tf.constant(input_tensor, dtype=tf.float32)\n    indices = tf.constant(indices, dtype=tf.int32)\n    gathered = tf.gather(input_tensor, indices, axis=1)\n    return gathered\n\ninput_tensor = [[0.2, 0.5, 0.3], [0.1, 0.3, 0.6], [0.1, 0.6, 0.3], [0.7, 0.0, 0.3]]\nindices = [[2], [0], [1], [0]]\n",
            "\ndef gather_elements(params, indices):\n    indices = tf.squeeze(indices, axis=1)\n    indices = tf.stack([tf.range(tf.shape(indices)[0]), indices], axis=1)\n    return tf.gather_nd(params, indices)\n",
            "\ndef gather_elements(input_list):\n    tensor = tf.constant([0.1, 0.3, 0.6])\n    indices = tf.constant(input_list)\n    gathered = tf.gather_nd(tensor, indices)\n    return gathered.numpy().tolist()\n"
        ],
        "target-program": "tf.gather(in2, in1, axis=1, batch_dims=1)",
        "description": "gather elements in a tensor along axis 1",
        "tf_operators": {
            "tf.constant": 7,
            "tf.gather_nd": 7,
            "tf.gather": 2,
            "tf.reduce_mean": 1,
            "tf.shape": 2,
            "tf.stack": 2,
            "tf.squeeze": 2,
            "tf.range": 2,
            "tf.reduce_min": 1,
            "tf.float32": 2,
            "tf.int32": 2
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_22",
        "completions": [
            "\nvec = tf.constant([3, 1, 10], dtype=tf.float32)\n\nmat = tf.constant([[0.6, 0.4], [0.5, 1.0], [3.0, 4.0]], dtype=tf.float32)\n\nresult = tf.linalg.matvec(mat, vec)\n\noutput = tf.reduce_sum(result)\n\n",
            "\ndef multiply_vector_with_matrix(vector, matrix):\n    return tf.reduce_sum(tf.linalg.matvec(matrix, vector))\n",
            "\ndef multiply_vector_matrix(vector, matrix):\n    result = tf.matmul([vector], matrix)\n    sum_result = tf.reduce_sum(result)\n    return sum_result\n",
            "\ndef multiply_vector_with_matrix(vector, matrix):\n    vector_tf = tf.constant(vector, dtype=tf.float32)\n    matrix_tf = tf.constant(matrix, dtype=tf.float32)\n    result = tf.linalg.matvec(matrix_tf, vector_tf)\n    return tf.reduce_sum(result).numpy()\n",
            "\ndef multiply_vector_matrix(vector, matrix):\n    # Compute the tensor dot product\n    result = tf.tensordot(vector, matrix, axes=1)\n    # Compute the sum of the result\n    sum_result = tf.reduce_sum(result)\n    return sum_result.numpy()\n",
            "\nmatrix = tf.constant([[0.6, 0.4], [0.5, 1.0], [3.0, 4.0]], dtype=tf.float32)\nvector = tf.constant([3, 1, 10], dtype=tf.float32)\n\nresult = tf.linalg.matvec(matrix, vector)\n\noutput = tf.reduce_sum(result)\n\n",
            "\ndef multiply_vector_matrix(vector, matrix):\n    return tf.tensordot(vector, matrix, axes=1)\n\nvector = tf.constant([3, 1, 10], dtype=tf.float32)\nmatrix = tf.constant([[0.6, 0.4], [0.5, 1.0], [3.0, 4.0]], dtype=tf.float32)\noutput = multiply_vector_matrix(vector, matrix)\n",
            "\nv = tf.constant([3, 1, 10], dtype=tf.float32)\n\nm = tf.constant([[0.6, 0.4], [0.5, 1.0], [3.0, 4.0]], dtype=tf.float32)\n\nresult = tf.tensordot(v, m, axes=1)\n\nfinal_result = tf.reduce_sum(result)\n\nwith tf.Session() as sess:\n    print(sess.run(final_result))\n",
            "\ndef multiply_vector_matrix(vector, matrix):\n    return tf.tensordot(vector, matrix, axes=1)\n",
            "\ndef multiply_vector_matrix(vector, matrix):\n    return tf.reduce_sum(tf.linalg.matvec(matrix, vector))\n\nvector = tf.constant([3, 1, 10], dtype=tf.float32)\nmatrix = tf.constant([[0.6, 0.4], [0.5, 1.0], [3.0, 4.0]], dtype=tf.float32)\nresult = multiply_vector_matrix(vector, matrix)\n"
        ],
        "target-program": "tf.tensordot(tf.cast(in1, tf.float32), in2, 1)",
        "description": "multiply a vector with a matrix without reshaping the vector",
        "tf_operators": {
            "tf.float32": 6,
            "tf.constant": 6,
            "tf.reduce_sum": 8,
            "tf.linalg.matvec": 5,
            "tf.matmul": 1,
            "tf.tensordot": 4,
            "tf.Session": 1
        },
        "coverage_percentage": 66.66666666666666,
        "total_in_target": 3,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_23",
        "completions": [
            "\ndef place_ones_at_indices(input_tensor):\n    # Convert the 2D list to 1D tensor\n    input_tensor = tf.reshape(input_tensor, [-1])\n    \n    # Create a tensor of zeros with size equal to the max value in the input tensor plus one\n    zeros = tf.zeros(tf.reduce_max(input_tensor) + 1, dtype=tf.int32)\n    \n    # Create indices for the scatter function\n    indices = tf.reshape(input_tensor, [-1, 1])\n    \n    # Create updates for the scatter function\n    updates = tf.ones_like(input_tensor, dtype=tf.int32)\n    \n    # Use scatter function to place 1 at the indices in the input tensor\n    result = tf.tensor_scatter_nd_update(zeros, indices, updates)\n    \n    return result.numpy().tolist()\n\ninput_tensor = tf.constant([[0, 5, 2], [3, 1, 4], [5, 1, 5]], dtype=tf.int32)\n",
            "\ndef place_ones_at_indices(input):\n    indices = tf.reshape(input, [-1, 1])\n    updates = tf.ones(tf.shape(indices)[0], dtype=tf.int32)\n    tensor = tf.zeros(tf.reduce_max(indices) + 1, dtype=tf.int32)\n    return tf.tensor_scatter_nd_update(tensor, indices, updates).numpy()\n    \ninput = tf.constant([[0, 5, 2], [3, 1, 4], [5, 1, 5]])\n",
            "\ndef place_ones_at_indices(input_tensor):\n    flat_input = tf.reshape(input_tensor, [-1])\n    max_val = tf.reduce_max(flat_input)\n    zeros_tensor = tf.zeros([max_val+1], tf.int32)\n    indices = tf.reshape(flat_input, [-1, 1])\n    updates = tf.ones_like(flat_input, tf.int32)\n    result = tf.tensor_scatter_nd_update(zeros_tensor, indices, updates)\n    return result\n",
            "\ninput_tensor = tf.constant([[0, 5, 2], [3, 1, 4], [5, 1, 5]])\n\nindices = tf.reshape(input_tensor, [-1, 1])\n\nzeros = tf.zeros([tf.reduce_max(input_tensor) + 1], tf.int32)\n\nupdates = tf.ones(tf.size(indices), tf.int32)\n\noutput_tensor = tf.tensor_scatter_nd_update(zeros, indices, updates)\n",
            "\ndef place_ones_at_indices(input_tensor):\n    max_val = tf.reduce_max(input_tensor)\n    indices = tf.reshape(input_tensor, [-1, 1])\n    updates = tf.ones_like(indices, dtype=tf.int32)\n    tensor = tf.Variable(tf.zeros([max_val+1], dtype=tf.int32))\n    tensor = tf.tensor_scatter_nd_update(tensor, indices, updates)\n    return tensor\n",
            "\ndef place_ones(input_tensor):\n    input_tensor = tf.constant(input_tensor, dtype=tf.int32)\n    max_value = tf.reduce_max(input_tensor)\n    initial_tensor = tf.Variable(tf.zeros(max_value+1, dtype=tf.int32))\n    updates = tf.ones_like(input_tensor)\n    indices = tf.reshape(input_tensor, [-1, 1])\n    output_tensor = tf.tensor_scatter_nd_update(initial_tensor, indices, updates)\n    return output_tensor\n",
            "\ndef place_ones_at_indices(input_tensor):\n    input_tensor = tf.constant(input_tensor)\n    flat_input = tf.reshape(input_tensor, [-1])\n    indices = tf.expand_dims(flat_input, axis=-1)\n    updates = tf.ones_like(flat_input, dtype=tf.int32)\n    shape = [tf.reduce_max(input_tensor) + 1]\n    output = tf.scatter_nd(indices, updates, shape)\n    return output\n",
            "\ndef place_ones_at_indices(input_tensor):\n    input_tensor = tf.reshape(input_tensor, [-1])\n    zeros_tensor = tf.zeros(tf.reduce_max(input_tensor) + 1, dtype=tf.int32)\n    indices = tf.reshape(input_tensor, [-1, 1])\n    updates = tf.ones_like(input_tensor, dtype=tf.int32)\n    result = tf.tensor_scatter_nd_update(zeros_tensor, indices, updates)\n    return result\n\ninput_tensor = tf.constant([[0, 5, 2], [3, 1, 4], [5, 1, 5]])\noutput_tensor = place_ones_at_indices(input_tensor)\n",
            "\ndef place_ones(input_tensor):\n    input_tensor = tf.reshape(input_tensor, [-1])\n    max_val = tf.reduce_max(input_tensor)\n    zeros = tf.zeros(max_val + 1, dtype=tf.int32)\n    updates = tf.ones_like(input_tensor, dtype=tf.int32)\n    output = tf.tensor_scatter_nd_update(zeros, tf.reshape(input_tensor, [-1, 1]), updates)\n    return output\n",
            "\ndef place_ones(input_tensor):\n    max_val = tf.reduce_max(input_tensor)\n    zero_tensor = tf.zeros(max_val + 1, dtype=tf.int32)\n    indices = tf.reshape(input_tensor, [-1, 1])\n    updates = tf.ones_like(indices, dtype=tf.int32)\n    output_tensor = tf.tensor_scatter_nd_update(zero_tensor, indices, updates)\n    return output_tensor\n\ninput_tensor = tf.constant([[0, 5, 2], [3, 1, 4], [5, 1, 5]])\noutput_tensor = place_ones(input_tensor)\n"
        ],
        "target-program": "tf.cast(tf.reduce_max(tf.one_hot(in1, 9), axis=1), tf.int32)",
        "description": "place 1 at the indices in the input tensor",
        "tf_operators": {
            "tf.reshape": 10,
            "tf.ones_like": 8,
            "tf.int32": 10,
            "tf.zeros": 9,
            "tf.constant": 7,
            "tf.tensor_scatter_nd_update": 9,
            "tf.reduce_max": 10,
            "tf.shape": 1,
            "tf.ones": 2,
            "tf.size": 1,
            "tf.Variable": 2,
            "tf.expand_dims": 1,
            "tf.scatter_nd": 1
        },
        "coverage_percentage": 50.0,
        "total_in_target": 4,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_24",
        "completions": [
            "\ndef safe_divide(numerator, denominator):\n    condition = tf.equal(denominator, 0)\n    safe_denominator = tf.where(condition, tf.ones_like(denominator), denominator)\n    division_result = tf.divide(numerator, safe_denominator)\n    output = tf.reduce_sum(division_result)\n    return output\n\nnumerator = tf.constant([3.0, 1.0, 4.0, 5.0, 2.0, 8.0, -6.0, -7.0])\ndenominator = tf.constant([0.5, 0.0, -2.0, 0.0, 1.0, -1.0, 0.0, 2.0])\n\nresult = safe_divide(numerator, denominator)\n",
            "\ndef safe_divide(nums):\n    nums_tensor = tf.constant(nums, dtype=tf.float32)\n    sum_nums = tf.reduce_sum(nums_tensor)\n    count_nonzero = tf.cast(tf.count_nonzero(nums_tensor), tf.float32)\n    result = tf.cond(tf.equal(count_nonzero, 0), \n                     lambda: sum_nums, \n                     lambda: tf.divide(sum_nums, count_nonzero))\n    return result\n",
            "\ndef safe_divide(numerator, denominator):\n    return tf.where(tf.equal(denominator, 0), numerator, tf.divide(numerator, denominator))\n",
            "\ndef custom_division(numerator, denominator):\n    result = tf.where(tf.equal(denominator, 0), numerator, tf.divide(numerator, denominator))\n    return tf.reduce_sum(result)\n\nnumerator = tf.constant([3.0, 1.0, 4.0, 5.0, 2.0, 8.0, -6.0, -7.0])\ndenominator = tf.constant([0.5, 0.0, -2.0, 0.0, 1.0, -1.0, 0.0, 2.0])\n\noutput = custom_division(numerator, denominator)\n",
            "\ndef custom_division(input_array):\n    # Create a TensorFlow constant from the input array\n    input_tensor = tf.constant(input_array, dtype=tf.float32)\n\n    # Perform the division and handle division by zero\n    result = tf.where(tf.equal(0.0, 0.0), input_tensor, input_tensor / 0.0)\n\n    # Compute the sum of the array\n    sum = tf.reduce_sum(result)\n\n    return sum.numpy()\n",
            "\ndef safe_divide(numerator, denominator):\n    return tf.where(tf.not_equal(denominator, 0), tf.divide(numerator, denominator), numerator)\n",
            "\ndef safe_divide(numerator, denominator):\n    return tf.where(tf.equal(denominator, 0), numerator, tf.divide(numerator, denominator))\n\nnumerator = tf.constant([3.0, 1.0, 4.0, 5.0, 2.0, 8.0, -6.0, -7.0])\ndenominator = tf.constant([0.5, 0.0, -2.0, 0.0, 1.0, -1.0, 0.0, 2.0])\n\nresult = safe_divide(numerator, denominator)\n",
            "\ndef safe_divide(numerator, denominator):\n    return tf.where(tf.equal(denominator, 0), numerator, tf.divide(numerator, denominator))\n\nnumerator = tf.constant([3.0, 1.0, 4.0, 5.0, 2.0, 8.0, -6.0, -7.0])\ndenominator = tf.constant([0.5, 0.0, -2.0, 0.0, 1.0, -1.0, 0.0, 2.0])\n\nresult = safe_divide(numerator, denominator)\n",
            "\ndef safe_divide(numerator, denominator):\n    return tf.reduce_sum(tf.where(tf.equal(denominator, 0), numerator, tf.divide(numerator, denominator)))\n\nnumerator = tf.constant([3.0, 1.0, 4.0, 5.0, 2.0, 8.0, -6.0, -7.0])\ndenominator = tf.constant([0.5, 0.0, -2.0, 0.0, 1.0, -1.0, 0.0, 2.0])\n\n",
            "\ndef safe_divide(numerator, denominator):\n    return tf.where(tf.equal(denominator, 0), numerator, tf.divide(numerator, denominator))\n"
        ],
        "target-program": "tf.where(tf.cast(in2, tf.bool), x=tf.divide(in1, in2), y=in1)",
        "description": "(\\'like tf.divide(), but when dividing by 0, return the numerator\\')",
        "tf_operators": {
            "tf.where": 9,
            "tf.ones_like": 1,
            "tf.equal": 9,
            "tf.divide": 9,
            "tf.reduce_sum": 5,
            "tf.constant": 7,
            "tf.cond": 1,
            "tf.float32": 2,
            "tf.count_nonzero": 1,
            "tf.cast": 1,
            "tf.not_equal": 1
        },
        "coverage_percentage": 75.0,
        "total_in_target": 4,
        "total_covered": 3
    },
    {
        "task_id": "stackoverflow_25",
        "completions": [
            "\nidentity_matrix = tf.eye(3)\n\noutput = tf.tile(identity_matrix, [4, 1])\n\n",
            "\nidentity_matrix = tf.eye(3)\n\nresult = tf.tile(identity_matrix, [4, 1])\n\n",
            "\nidentity_matrix = tf.eye(3)\n\nresult = tf.repeat(identity_matrix, repeats=4, axis=0)\n\n",
            "\nidentity_matrix = tf.eye(3)\n\nrepeated_tensor = tf.tile(identity_matrix[None, ...], [4, 1, 1])\n",
            "\nidentity_matrix = tf.eye(3)\n\nresult = tf.tile(tf.expand_dims(identity_matrix, 0), [4, 1, 1])\n",
            "\nidentity = tf.eye(3)\n\nresult = tf.tile(identity, [4, 1])\n\n",
            "\nidentity_matrix = tf.eye(3)\n\nresult = tf.tile(identity_matrix, [4, 1])\n\n",
            "\nidentity_matrix = tf.eye(3)\n\nresult = tf.tile(identity_matrix, [4, 1])\n\n",
            "\neye_tensor = tf.eye(3)\n\nresult = tf.tile(eye_tensor, [4, 1])\n\n",
            "\nidentity_matrix = tf.eye(3)\n\ncopied_matrix = tf.tile(identity_matrix[tf.newaxis, ...], [4, 1, 1])\n\n"
        ],
        "target-program": "tf.tile(tf.eye(in1), (in2, 1))",
        "description": "copy the tensor tf.eye(3), 4 times",
        "tf_operators": {
            "tf.eye": 10,
            "tf.tile": 9,
            "tf.repeat": 1,
            "tf.expand_dims": 1,
            "tf.newaxis": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 2,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_26",
        "completions": [
            "\narr = tf.constant([[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]])\n\nmax_value = tf.reduce_max(arr)\n\n",
            "\ndata = [[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]]\n\ntensor = tf.constant(data)\n\nmax_value = tf.reduce_max(tensor)\n\n",
            "\ndata = [[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]]\n\ntensor = tf.constant(data)\n\nresult = tf.reduce_sum(tensor)\n\n",
            "\ndata = [[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]]\n\ntensor_data = tf.constant(data)\n\nresult = tf.reduce_min(tensor_data)\n\n",
            "\ninput_tensor = tf.constant([[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]])\n\noutput = tf.reduce_max(input_tensor)\n\n",
            "\ndata = [[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]]\n\ntensor = tf.constant(data)\n\nresult = tf.reduce_sum(tensor)\n\n",
            "\ntensor = tf.constant([[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]])\n\noutput = tf.reduce_min(tensor)\n\n",
            "\ninput_tensor = tf.constant([[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]])\n\noutput = tf.reduce_max(input_tensor)\n\n",
            "\ndef max_reduction(tensor):\n    return tf.reduce_max(tensor)\n\ntensor = [[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]]\n",
            "\ndata = [[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]]\n\ntensor_data = tf.constant(data)\n\nmax_value = tf.reduce_max(tensor_data)\n\n"
        ],
        "target-program": "tf.reduce_sum(tf.reduce_sum(in1, axis=1), axis=1)",
        "description": "reduction operation for multiple dimensions simultaneously",
        "tf_operators": {
            "tf.constant": 9,
            "tf.reduce_max": 6,
            "tf.reduce_sum": 2,
            "tf.reduce_min": 2
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_27",
        "completions": [
            "\ndef bool_tensor(input_indices):\n    # Create a tensor of zeros with the size of the maximum number in the input list plus one\n    tensor = tf.Variable(tf.zeros([max(input_indices) + 1], tf.int32))\n    \n    # Iterate through the input list and set the corresponding indices in the tensor to one\n    for index in input_indices:\n        tensor[index].assign(1)\n    \n    return tensor\n",
            "\ndef boolean_tensor(indices):\n    max_index = tf.reduce_max(indices)\n    tensor = tf.zeros(max_index + 1, dtype=tf.int32)\n    updates = tf.ones_like(indices, dtype=tf.int32)\n    return tf.tensor_scatter_nd_update(tensor, tf.expand_dims(indices, 1), updates)\n",
            "\ndef boolean_tensor(indices):\n    indices = tf.constant(indices, dtype=tf.int32)\n    indices = tf.reshape(indices, [-1, 1])\n    updates = tf.ones(tf.shape(indices)[0], dtype=tf.bool)\n    shape = tf.constant([tf.reduce_max(indices) + 1], dtype=tf.int32)\n    tensor = tf.zeros(shape, dtype=tf.bool)\n    tensor = tf.tensor_scatter_nd_update(tensor, indices, updates)\n    return tensor\n",
            "\ndef create_boolean_tensor(indices):\n    # Create a tensor of zeros with a shape large enough to accommodate the maximum index\n    zeros = tf.zeros(tf.reduce_max(indices) + 1, dtype=tf.int32)\n\n    # Create a tensor of ones with the same shape as the indices tensor\n    updates = tf.ones_like(indices, dtype=tf.int32)\n\n    # Use scatter_nd to update the zeros tensor at the specified indices with ones\n    tensor = tf.tensor_scatter_nd_update(zeros, tf.expand_dims(indices, axis=-1), updates)\n\n    # Convert the tensor to a boolean tensor\n    bool_tensor = tf.greater(tensor, 0)\n\n    return bool_tensor\n",
            "\ndef boolean_tensor(input_data):\n    tensor = tf.constant(input_data)\n    sum = tf.reduce_sum(tensor)\n    boolean = tf.cast(sum, tf.bool)\n    return boolean\n",
            "\ndef one_hot_tensor(indices):\n    if isinstance(indices, int):\n        return 0\n    else:\n        depth = max(indices) + 1\n        return tf.one_hot(indices, depth)\n",
            "\ndef boolean_tensor(indices):\n    # Create a zero tensor with the maximum size from indices\n    tensor = tf.Variable(tf.zeros(tf.reduce_max(indices) + 1, dtype=tf.bool))\n    \n    # Update the tensor with ones at the specified indices\n    tensor = tf.tensor_scatter_nd_update(tensor, tf.reshape(indices, [-1, 1]), tf.repeat(True, len(indices)))\n    \n    return tensor\n",
            "\ndef create_boolean_tensor(indices):\n    indices = tf.constant(indices, dtype=tf.int32)\n    updates = tf.ones_like(indices, dtype=tf.float32)\n    tensor = tf.Variable(tf.zeros([10], dtype=tf.float32))\n    tensor = tf.tensor_scatter_nd_update(tensor, tf.reshape(indices, [-1, 1]), updates)\n    return tensor\n",
            "\ndef update_tensor(indices, size=10):\n    init_tensor = tf.zeros(size, dtype=tf.int32)\n    indices = tf.constant([[i] for i in indices], dtype=tf.int32)\n    updates = tf.ones_like(indices, dtype=tf.int32)\n    return tf.tensor_scatter_nd_update(init_tensor, indices, updates)\n",
            "\ndef update_tensor(indices):\n    with tf.Session() as sess:\n        if isinstance(indices, list):\n            size = max(indices) + 1\n        else:\n            size = indices + 1\n            indices = [indices]\n        tensor = tf.Variable(tf.zeros(size, dtype=tf.int32))\n        sess.run(tensor.initializer)\n        update = tf.scatter_nd_update(tensor, tf.reshape(tf.constant(indices, dtype=tf.int32), [len(indices), 1]), tf.ones(len(indices), dtype=tf.int32))\n        return sess.run(update)\n"
        ],
        "target-program": "tf.cast(tf.reduce_max(tf.one_hot(in1, in2), axis=0), tf.int32)",
        "description": "boolean tensor with 1 at the indices in the input tensor",
        "tf_operators": {
            "tf.int32": 7,
            "tf.Variable": 4,
            "tf.zeros": 8,
            "tf.ones_like": 4,
            "tf.expand_dims": 2,
            "tf.tensor_scatter_nd_update": 6,
            "tf.reduce_max": 4,
            "tf.reshape": 4,
            "tf.shape": 1,
            "tf.ones": 2,
            "tf.constant": 5,
            "tf.bool": 3,
            "tf.greater": 1,
            "tf.cast": 1,
            "tf.reduce_sum": 1,
            "tf.one_hot": 1,
            "tf.repeat": 1,
            "tf.float32": 1,
            "tf.scatter_nd_update": 1,
            "tf.Session": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 4,
        "total_covered": 4
    },
    {
        "task_id": "stackoverflow_28",
        "completions": [
            "\ndef extract_columns(tensor, indices):\n    tensor = tf.constant(tensor)\n    result = tf.gather(tensor, indices, axis=2)\n    return result.numpy().tolist()\n\ntensor = [[[5, 3], [0, 2]], [[7, 4], [5, 1]], [[10, 20], [15, 30]], [[11, 16], [14, 12]], [[-2, -7], [-4, 6]]]\nindices = [1, 0, 1, 1, 0]\nextract_columns(tensor, indices)\n",
            "\ndef extract_columns(tensor_3d, indices):\n    tensor_3d = tf.constant(tensor_3d)\n    indices = tf.constant(indices)\n    indices = tf.stack([indices, tf.range(tf.shape(indices)[0])], axis=1)\n    return tf.gather_nd(tensor_3d, indices)\n\ntensor_3d = [[[5, 3], [0, 2]], [[7, 4], [5, 1]], [[10, 20], [15, 30]], [[11, 16], [14, 12]], [[-2, -7], [-4, 6]]]\nindices = [1, 0, 1, 1, 0]\noutput = extract_columns(tensor_3d, indices)\n",
            "\ndef extract_columns(tensor, indices):\n    indices = tf.stack([tf.range(tf.shape(indices)[0]), indices], axis=1)\n    return tf.gather_nd(tensor, indices)\n",
            "\ndef extract_columns(tensor_3d, indices):\n    tensor_3d = tf.constant(tensor_3d)\n    indices = tf.constant(indices)\n    extracted_columns = tf.gather(tensor_3d, indices, axis=2)\n    return [column.numpy().tolist() for column in extracted_columns]\n",
            "\ndef extract_columns(tensor_3d, column_indices):\n    tensor_3d = tf.constant(tensor_3d)\n    column_indices = tf.constant(column_indices)\n    result = tf.gather(tensor_3d, column_indices, axis=2)\n    return result.numpy().tolist()\n",
            "\ntensor_3d = [[[5, 3], [0, 2]], [[7, 4], [5, 1]], [[10, 20], [15, 30]], [[11, 16], [14, 12]], [[-2, -7], [-4, 6]]]\nindices = [1, 0, 1, 1, 0]\n\ntensor_3d = tf.constant(tensor_3d)\nindices = tf.constant(indices)\n\nindices = tf.stack([tf.range(tf.shape(indices)[0]), indices], axis=1)\n\noutput = tf.gather_nd(tensor_3d, indices)[:, 0]\n\n",
            "\ntensor = tf.constant([[[5, 3], [0, 2]], [[7, 4], [5, 1]], [[10, 20], [15, 30]], [[11, 16], [14, 12]], [[-2, -7], [-4, 6]]])\n\nindices = tf.constant([1, 0, 1, 1, 0])\n\nreshaped_tensor = tf.reshape(tensor, [-1, tensor.shape[-1]])\n\noutput = tf.gather(reshaped_tensor, indices)\n\noutput = output[:, 1]\n\n",
            "\ndef extract_columns(tensor_3d, column_indices):\n    tensor_3d = tf.constant(tensor_3d)\n    column_indices = tf.constant(column_indices)\n    \n    tensor_2d = tf.reshape(tensor_3d, (-1, tensor_3d.shape[-1]))\n    extracted_columns = tf.gather(tensor_2d, column_indices, axis=1)\n    extracted_columns = tf.reshape(extracted_columns, tensor_3d.shape)\n    \n    return extracted_columns.numpy().tolist()\n",
            "\ndef extract_columns(tensor, indices):\n    tensor = tf.constant(tensor)\n    result = tf.gather(tensor, indices, axis=2)\n    return [x[0].numpy() for x in result]\n",
            "\ndef extract_columns(tensor, indices):\n    tensor = tf.convert_to_tensor(tensor)\n    indices = tf.convert_to_tensor(indices)\n    indices = tf.reshape(indices, [-1, 1])\n    indices = tf.concat([tf.range(tf.shape(indices)[0])[:, tf.newaxis], indices], axis=1)\n    return tf.gather_nd(tensor[:, 0, :], indices)\n\ntensor = [[[5, 3], [0, 2]], [[7, 4], [5, 1]], [[10, 20], [15, 30]], [[11, 16], [14, 12]], [[-2, -7], [-4, 6]]]\nindices = [1, 0, 1, 1, 0]\n"
        ],
        "target-program": "tf.squeeze(tf.gather(in1, tf.expand_dims(in2, 1), axis=-1, batch_dims=1))",
        "description": "extract columns from a 3D tensor given column indices",
        "tf_operators": {
            "tf.gather": 6,
            "tf.constant": 8,
            "tf.shape": 4,
            "tf.stack": 3,
            "tf.range": 4,
            "tf.gather_nd": 4,
            "tf.reshape": 3,
            "tf.convert_to_tensor": 1,
            "tf.concat": 1,
            "tf.newaxis": 1
        },
        "coverage_percentage": 33.33333333333333,
        "total_in_target": 3,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_29",
        "completions": [
            "\ndef bucketize_values(values):\n    bins = tf.histogram_fixed_width_bins(values, value_range=[-1, 1], nbins=10)\n    return bins[0].numpy()\n",
            "\ndef bucketize(values):\n  value_range = [-1.0, 1.0]\n  nbins = 10\n  indices = tf.histogram_fixed_width_bins(values, value_range, nbins)\n  return tf.reduce_sum(indices)\n",
            "\ndef bucket_values(values):\n    bucket_range = tf.constant([-1.0, 1.0])\n    bins = tf.histogram_fixed_width_bins(values, bucket_range, nbins=5)\n    unique_bins = tf.unique(bins).y\n    return tf.size(unique_bins)\n",
            "\ndef count_values_in_buckets(values):\n    # Define the bucket boundaries\n    edges = tf.constant([-1.0, 1.0])\n\n    # Bucketize the input tensor\n    bucket_indices = tf.histogram_fixed_width_bins(values, edges, nbins=5)\n\n    # Count the number of zeros in the bucket indices\n    count = tf.size(values) - tf.math.count_nonzero(bucket_indices)\n\n    return count\n",
            "import numpy as np\n\ndef majority_bucket(values):\n    # Define the bucket boundaries\n    value_range = tf.constant([-1.0, 1.0], dtype=tf.float32)\n\n    # Place values into buckets\n    bucket_indices = tf.histogram_fixed_width_bins(values, value_range, nbins=10)\n\n    # Count the number of values in each bucket\n    bucket_counts = np.bincount(bucket_indices.numpy())\n\n    # Return the bucket with the majority of values\n    return np.argmax(bucket_counts)\n",
            "\ndef bucketize(input_data, boundaries):\n    with tf.Session() as sess:\n        input_tensor = tf.constant(input_data)\n        output_tensor = tf.bucketize(input_tensor, boundaries)\n        output = sess.run(output_tensor)\n    return tf.argmax(tf.bincount(output)).numpy()\n\n",
            "\ndef bucket_indices(values):\n    return tf.histogram_fixed_width_bins(values, value_range=[-1.0, 1.0], nbins=10)\n",
            "\ndef get_bucket(values):\n    values = tf.constant(values, dtype=tf.float32)\n    bucket_indices = tf.histogram_fixed_width_bins(values, (-1.0, 1.0), nbins=10)\n    bucket_counts = tf.math.bincount(bucket_indices)\n    max_bucket = tf.math.argmax(bucket_counts)\n    return max_bucket.numpy()\n",
            "\nrange_ = [-1.0, 1.0]\nbucket_width = 0.2857\n\nbin_indices = tf.histogram_fixed_width_bins(values, range_, nbins=int((range_[1] - range_[0]) / bucket_width))\n",
            "\ndef bucket_values(values):\n    bucket_boundaries = tf.constant([-1.0, 1.0])\n    bin_indices = tf.histogram_fixed_width_bins(values, bucket_boundaries, nbins=3)\n    bin_counts = tf.math.bincount(bin_indices)\n    most_populated_bin = tf.math.argmax(bin_counts)\n    return most_populated_bin.numpy()\n\nvalues = tf.constant([-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0])\n\nvalues = tf.constant([0.1, -10, -0.1, 1.1, 0.41])\n"
        ],
        "target-program": "tf.searchsorted(in1, in2, side='left')",
        "description": "place continuous values into buckets given bucket boundaries",
        "tf_operators": {
            "tf.histogram_fixed_width_bins": 9,
            "tf.reduce_sum": 1,
            "tf.constant": 6,
            "tf.size": 2,
            "tf.unique": 1,
            "tf.math.count_nonzero": 1,
            "tf.float32": 2,
            "tf.bincount": 1,
            "tf.argmax": 1,
            "tf.Session": 1,
            "tf.bucketize": 1,
            "tf.math.bincount": 2,
            "tf.math.argmax": 2
        },
        "coverage_percentage": 0.0,
        "total_in_target": 1,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_30",
        "completions": [
            "",
            "",
            "\ndef compute_euclidean_distance(tensor1, tensor2):\n    return tf.norm(tensor1 - tensor2)\n",
            "",
            "",
            "",
            "\ndef euclidean_distance(tensor1, tensor2):\n    difference = tf.subtract(tensor1, tensor2)\n    square_difference = tf.square(difference)\n    sum_of_squares = tf.reduce_sum(square_difference)\n    euclidean_distance = tf.sqrt(sum_of_squares)\n    return euclidean_distance\n",
            "",
            "\neuclidean_distance = tf.norm(tensor1 - tensor2)\n",
            "\ndef compute_euclidean_distance(tensor_A, tensor_B):\n    return tf.norm(tensor_A - tensor_B)\n"
        ],
        "target-program": "tf.sqrt(tf.reduce_sum(tf.square(tf.subtract(tf.expand_dims(in1, 1), tf.expand_dims(in2, 0))), axis=2))",
        "description": "compute Euclidean distance between two tensors",
        "tf_operators": {
            "tf.norm": 3,
            "tf.reduce_sum": 1,
            "tf.subtract": 1,
            "tf.sqrt": 1,
            "tf.square": 1
        },
        "coverage_percentage": 80.0,
        "total_in_target": 5,
        "total_covered": 4
    },
    {
        "task_id": "stackoverflow_31",
        "completions": [
            "\ndef calculate_squared_error(input_char):\n    # Create a dictionary that maps each character to its ASCII value\n    char_to_ascii = {chr(i): i for i in range(128)}\n\n    # Convert the input character to its ASCII value\n    ascii_value = char_to_ascii[input_char]\n\n    # Create a sparse tensor with the ASCII value\n    sparse_tensor = tf.SparseTensor(indices=[[0, 0]], values=[ascii_value], dense_shape=[1, 1])\n\n    # Create a dense tensor with the same value\n    dense_tensor = tf.constant([[ascii_value]], dtype=tf.int32)\n\n    # Calculate the squared difference between the sparse tensor and the dense tensor\n    squared_difference = tf.squared_difference(tf.sparse.to_dense(sparse_tensor), dense_tensor)\n\n    # Reduce the squared difference tensor to a single scalar value by summing all its elements\n    squared_error = tf.reduce_sum(squared_difference)\n\n    return squared_error.numpy()\n",
            "\ndense_tensor = tf.constant([1.0, 2.0, 3.0])\nsparse_tensor = tf.SparseTensor(indices=[[0, 0], [1, 1]], values=[2.0, 3.0], dense_shape=[3, 3])\n\ndense_sparse_tensor = tf.sparse.to_dense(sparse_tensor)\n\nsquared_error = tf.square(dense_tensor - dense_sparse_tensor)\n",
            "\n\ndense_tensor_b = tf.sparse.to_dense(sparse_tensor_b)\n\nsquared_error = tf.square(tensor_a - dense_tensor_b)\n",
            "\nindices = [[0, 0], [1, 2]]\n\nvalues = [1, 2]\n\nshape = [3, 4]\n\nsparse_tensor = tf.SparseTensor(indices=indices, values=values, dense_shape=shape)\n\ndense_tensor = tf.sparse.to_dense(sparse_tensor)\n\nmse = tf.losses.mean_squared_error(sparse_tensor.values, dense_tensor)\n\n",
            "\nsquared_error = tf.reduce_sum(tf.square(tf.subtract(tensor1, tf.sparse.to_dense(tensor2))))\n",
            "",
            "",
            "",
            "",
            ""
        ],
        "target-program": "tf.reduce_sum(tf.square(tf.subtract(in2, tf.sparse.to_dense(in1))))",
        "description": "squared error between two tensors, one being a sparse tensor",
        "tf_operators": {
            "tf.int32": 1,
            "tf.squared_difference": 1,
            "tf.constant": 2,
            "tf.reduce_sum": 2,
            "tf.sparse.to_dense": 5,
            "tf.SparseTensor": 3,
            "tf.square": 3,
            "tf.losses.mean_squared_error": 1,
            "tf.subtract": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 4,
        "total_covered": 4
    },
    {
        "task_id": "stackoverflow_32",
        "completions": [
            "\narray = tf.constant([[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]])\n\nweights = tf.range(tf.shape(array)[1])\n\nweighted_array = tf.multiply(array, tf.cast(weights, tf.float32))\n\noutput = tf.reduce_sum(weighted_array)\n\n",
            "\ndata = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n\ndata_tensor = tf.constant(data)\n\nweights = tf.range(start=0, limit=tf.shape(data_tensor)[1], delta=1, dtype=tf.float32)\n\nweighted_sum = tf.reduce_sum(tf.multiply(data_tensor, weights))\n\n",
            "\ndata = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n\ndata_tf = tf.constant(data)\n\nweights = tf.range(tf.shape(data_tf)[1])\n\nweighted_data = tf.multiply(data_tf, tf.cast(weights, tf.float32))\n\noutput = tf.reduce_sum(weighted_data)\n\n",
            "\ninput_tensor = tf.constant([[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]])\n\nweights = tf.range(tf.shape(input_tensor)[1], dtype=tf.float32)\n\nweighted_tensor = tf.multiply(input_tensor, weights)\n\noutput = tf.reduce_sum(weighted_tensor)\n\n",
            "\ndata = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n\ntensor = tf.constant(data, dtype=tf.float32)\n\nweights = tf.range(tf.shape(tensor)[1], dtype=tf.float32)\n\nweighted_sum = tf.reduce_sum(tensor * weights)\n\n",
            "\ndef weighted_sum(input_data):\n    # Create a 2D Tensor from the input data\n    tensor_data = tf.constant(input_data)\n\n    # Create a 1D Tensor of weights where each weight is equal to its index\n    weights = tf.range(tf.shape(tensor_data)[1], dtype=tf.float32)\n\n    # Multiply the 2D Tensor with the 1D Tensor of weights\n    weighted_data = tf.multiply(tensor_data, weights)\n\n    # Sum all the elements of the resulting Tensor\n    result = tf.reduce_sum(weighted_data)\n\n    return result\n\ninput_data = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n",
            "\ndata = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n\ntensor = tf.constant(data)\n\nweights = tf.range(tf.shape(tensor)[1], dtype=tensor.dtype)\n\nweighted_tensor = tf.multiply(tensor, weights)\n\nweighted_sum = tf.reduce_sum(weighted_tensor)\n\n",
            "\ndata = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n\ndata_tensor = tf.constant(data)\n\nweights = tf.range(tf.shape(data_tensor)[1], dtype=tf.float32)\n\nweighted_sum = tf.reduce_sum(data_tensor * weights)\n\n",
            "\ndata = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n\ntensor = tf.constant(data)\n\nweights = tf.range(tf.shape(tensor)[1], dtype=tensor.dtype)\n\nresult = tf.reduce_sum(tensor * weights)\n\n",
            "\ndef weighted_sum(input_list):\n    # Creating a tensor from the given input list\n    input_tensor = tf.constant(input_list, dtype=tf.float32)\n\n    # Creating a tensor of weights (column indices)\n    weights = tf.range(start=0, limit=tf.shape(input_tensor)[1], dtype=tf.float32)\n\n    # Performing a weighted sum across rows\n    weighted_sum = tf.reduce_sum(input_tensor * weights)\n\n    return weighted_sum\n\ninput_list = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n"
        ],
        "target-program": "tf.tensordot(in1, tf.cast(tf.range(4), tf.float32), 1)",
        "description": "weighted sum across rows, where the column index is the weight",
        "tf_operators": {
            "tf.multiply": 6,
            "tf.shape": 10,
            "tf.float32": 8,
            "tf.constant": 10,
            "tf.reduce_sum": 10,
            "tf.cast": 2,
            "tf.range": 10
        },
        "coverage_percentage": 75.0,
        "total_in_target": 4,
        "total_covered": 3
    },
    {
        "task_id": "stackoverflow_33",
        "completions": [
            "\ndef min_distance(points):\n    points = tf.constant(points, dtype=tf.float32)\n    r = tf.reduce_sum(points*points, 1)\n    r = tf.reshape(r, [-1, 1])\n    D = r - 2*tf.matmul(points, tf.transpose(points)) + tf.transpose(r)\n    D = tf.sqrt(D)\n    return tf.reduce_min(D)\n",
            "\ndef min_distance(points):\n    points = tf.constant(points, dtype=tf.float32)\n    r = tf.reduce_sum(points*points, 1)\n    r = tf.reshape(r, [-1, 1])\n    D = r - 2*tf.matmul(points, tf.transpose(points)) + tf.transpose(r)\n    D = tf.sqrt(D)\n    return tf.reduce_min(D).numpy()\n",
            "\ndef min_distance(points):\n    points = tf.constant(points, dtype=tf.float32)\n    r = tf.reduce_sum(points*points, 1)\n    r = tf.reshape(r, [-1, 1])\n    D = r - 2*tf.matmul(points, tf.transpose(points)) + tf.transpose(r)\n    D = tf.sqrt(D)\n    min_val = tf.reduce_min(D + tf.eye(tf.shape(D)[0])*1e10)\n    return min_val\n\npoints = [[0.3, 0.1, 0.4], [0.1, 0.5, 0.9], [0.2, 0.6, 0.5], [0.3, 0.5, 0.8], [0.9, 0.7, 0.9]]\n",
            "\ndef min_distance(points):\n    points = tf.convert_to_tensor(points, dtype=tf.float32)\n    expanded_points = tf.expand_dims(points, 1)\n    distances = tf.sqrt(tf.reduce_sum(tf.square(expanded_points - points), axis=-1))\n    min_distance = tf.reduce_min(distances + tf.eye(tf.shape(points)[0])*tf.float32.max)\n    return min_distance.numpy()\n",
            "\ndef min_distance(points):\n    points = tf.constant(points, dtype=tf.float32)\n    r = tf.reduce_sum(points*points, 1)\n    r = tf.reshape(r, [-1, 1])\n    D = r - 2*tf.matmul(points, tf.transpose(points)) + tf.transpose(r)\n    D = tf.sqrt(D)\n    min_val = tf.reduce_min(D + tf.eye(tf.shape(D)[0])*1e10)\n    return min_val\n\npoints1 = [[0.3, 0.1, 0.4], [0.1, 0.5, 0.9], [0.2, 0.6, 0.5], [0.3, 0.5, 0.8], [0.9, 0.7, 0.9]]\npoints2 = [[0.3, 0.2, 0.3], [0.8, 0.4, 0.6], [0.2, 0.6, 0.4], [0.3, 0.3, 0.8]]\n\n",
            "\ndef min_distance(points):\n    points = tf.constant(points, dtype=tf.float32)\n    points_expanded = tf.expand_dims(points, 1)\n    distances = tf.norm(points_expanded - points, axis=-1)\n    min_distance = tf.reduce_min(distances + tf.eye(tf.shape(points)[0]) * tf.reduce_max(distances))\n    return min_distance.numpy()\n",
            "\ndef min_distance(points):\n    points = tf.constant(points, dtype=tf.float32)\n    expanded_points = tf.expand_dims(points, 0)\n    distances = tf.reduce_sum(tf.square(expanded_points - tf.transpose(expanded_points)), 2)\n    distances = tf.linalg.set_diag(distances, tf.fill([distances.shape[0]], tf.constant(float('inf'))))\n    return tf.reduce_min(distances)\n\npoints = [[0.3, 0.1, 0.4], [0.1, 0.5, 0.9], [0.2, 0.6, 0.5], [0.3, 0.5, 0.8], [0.9, 0.7, 0.9]]\n",
            "\ndef min_distance(x, y):\n    x = tf.convert_to_tensor(x)\n    y = tf.convert_to_tensor(y)\n    \n    x = tf.expand_dims(x, 1) \n    y = tf.expand_dims(y, 0) \n    \n    dists = tf.reduce_sum(tf.square(x - y), -1)\n    min_dist = tf.sqrt(tf.reduce_min(dists))\n    \n    return min_dist.numpy()\n",
            "\ndef min_distance(points):\n    points = tf.convert_to_tensor(points)\n    r = tf.reduce_sum(points*points, 1)\n    r = tf.reshape(r, [-1, 1])\n    D = r - 2*tf.matmul(points, tf.transpose(points)) + tf.transpose(r)\n    return tf.sqrt(tf.reduce_min(D))\n\npoints = [[0.3, 0.1, 0.4], [0.1, 0.5, 0.9], [0.2, 0.6, 0.5], [0.3, 0.5, 0.8], [0.9, 0.7, 0.9]]\n",
            "\ndef min_distance(points):\n    points = tf.constant(points, dtype=tf.float32)\n    expanded_points = tf.expand_dims(points, 1)\n    distances = tf.norm(expanded_points - points, axis=-1)\n    min_distance = tf.reduce_min(distances + tf.eye(tf.shape(distances)[0])*1e10)\n    return min_distance.numpy()\n"
        ],
        "target-program": "tf.reduce_min(tf.reduce_sum(tf.square(tf.subtract(tf.expand_dims(in1, 0), tf.expand_dims(in2, 1))), axis=2), axis=1)",
        "description": "find the minimum distance between two sets of points",
        "tf_operators": {
            "tf.reshape": 5,
            "tf.reduce_min": 10,
            "tf.float32": 8,
            "tf.constant": 7,
            "tf.reduce_sum": 8,
            "tf.matmul": 5,
            "tf.sqrt": 7,
            "tf.transpose": 6,
            "tf.shape": 5,
            "tf.eye": 5,
            "tf.expand_dims": 5,
            "tf.convert_to_tensor": 3,
            "tf.square": 3,
            "tf.float32.max": 1,
            "tf.reduce_max": 1,
            "tf.norm": 2,
            "tf.fill": 1,
            "tf.linalg.set_diag": 1
        },
        "coverage_percentage": 80.0,
        "total_in_target": 5,
        "total_covered": 4
    },
    {
        "task_id": "stackoverflow_34",
        "completions": [
            "\ndef weighted_sum_tensors(tensors):\n    weighted_tensors = [i * tf.constant(tensor) for i, tensor in enumerate(tensors)]\n    return tf.reduce_sum(weighted_tensors, axis=0)\n\ntensors = [tf.constant([[1, 2], [3, 4]]), tf.constant([[5, 6], [7, 8]]), tf.constant([[10, 20], [30, 40]])]\noutput = weighted_sum_tensors(tensors)\n",
            "\ndef weighted_sum(input_list):\n    # Convert the input list to a tensor\n    input_tensor = tf.constant(input_list, dtype=tf.float32)\n    \n    # Create a weights tensor\n    weights = tf.range(1, input_tensor.shape[0] + 1, dtype=tf.float32)\n    \n    # Perform element-wise multiplication\n    multiplied = tf.multiply(input_tensor, weights[:, tf.newaxis, tf.newaxis])\n    \n    # Sum the elements of the resulting tensor along the last axis\n    result = tf.reduce_sum(multiplied, axis=[0, 1])\n    \n    return result.numpy().tolist()\n",
            "\ndef weighted_sum_tensors(tensors):\n    weights = tf.range(1, len(tensors) + 1)\n    tensors = tf.convert_to_tensor(tensors)\n    weights = tf.cast(weights, tensors.dtype)\n    weighted_sums = tf.reduce_sum(tensors, axis=[1, 2]) * weights\n    result = tf.reduce_sum(weighted_sums)\n    return result\n\ntensors = [[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[10, 20], [30, 40]]]\n\ntensors = [3, 5, 10]\n",
            "\ndef weighted_sum(tensors):\n    weights = tf.range(1, len(tensors) + 1, dtype=tf.float32)\n    tensors = tf.convert_to_tensor(tensors, dtype=tf.float32)\n    weighted_tensors = tensors * tf.reshape(weights, [-1, 1, 1])\n    return tf.reduce_sum(weighted_tensors, axis=0)\n\ntensors = [[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[10, 20], [30, 40]]]\n\ntensors = [3, 5, 10]\n",
            "\ndef weighted_sum(input):\n    tensor = tf.constant(input, dtype=tf.float32)\n    weights = tf.range(1, tf.shape(tensor)[0] + 1, dtype=tf.float32)\n    weighted_tensor = tensor * tf.reshape(weights, (-1, 1, 1))\n    result = tf.reduce_sum(weighted_tensor, axis=0)\n    return result\n",
            "\ndef weighted_sum_tensors(tensors):\n    weights = tf.range(start=1, limit=len(tensors)+1, dtype=tf.float32)\n    tensors = tf.convert_to_tensor(tensors, dtype=tf.float32)\n    weighted_tensors = tf.multiply(tensors, weights[:, None, None])\n    sum_tensors = tf.reduce_sum(weighted_tensors, axis=0)\n    return sum_tensors\n",
            "\ndef weighted_sum_tensors(tensors):\n    weights = tf.range(1, len(tensors) + 1, dtype=tf.int32)\n    weighted_tensors = [tf.multiply(t, w) for t, w in zip(tensors, weights)]\n    return tf.reduce_sum(weighted_tensors, axis=0)\n",
            "\ndef weighted_sum_tensors(tensor):\n    weights = tf.constant([1, 2], dtype=tf.int32)\n    result = tf.tensordot(tensor, weights, axes=[0,0])\n    return result.numpy().tolist()\n\ntensor = tf.constant([[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[10, 20], [30, 40]]], dtype=tf.int32)\n",
            "\ndef weighted_sum_tensors(input_list):\n    tensor = tf.constant(input_list, dtype=tf.int32)\n    weights = tf.range(1, len(input_list) + 1, dtype=tf.int32)\n    weighted_tensor = tensor * tf.reshape(weights, [-1, 1, 1])\n    result = tf.reduce_sum(weighted_tensor, axis=0)\n    return result.numpy().tolist()\n",
            "\ndef weighted_sum(input_list):\n    input_tensor = tf.constant(input_list, dtype=tf.int32)\n    weights = tf.range(tf.shape(input_tensor)[0])\n    weighted_input = tf.multiply(input_tensor, tf.expand_dims(weights, axis=-1))\n    return tf.reduce_sum(weighted_input, axis=0)\n\ninput_list = [[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[10, 20], [30, 40]]]\n\ninput_list = [3, 5, 10]\n"
        ],
        "target-program": "tf.tensordot(in2, in1, 1)",
        "description": "compute a weighted sum of tensors",
        "tf_operators": {
            "tf.constant": 6,
            "tf.reduce_sum": 9,
            "tf.multiply": 4,
            "tf.float32": 4,
            "tf.range": 8,
            "tf.newaxis": 1,
            "tf.convert_to_tensor": 3,
            "tf.cast": 1,
            "tf.reshape": 3,
            "tf.shape": 2,
            "tf.int32": 4,
            "tf.tensordot": 1,
            "tf.expand_dims": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_35",
        "completions": [
            "\ndef interpolate_tensors(tensor1, tensor2):\n    tensor1 = tf.constant(tensor1, dtype=tf.float32)\n    tensor2 = tf.constant(tensor2, dtype=tf.float32)\n\n    interpolated_tensor = tf.add(tensor1, tf.multiply(tf.subtract(tensor2, tensor1), 0.8))\n\n    return interpolated_tensor.numpy().tolist()\n",
            "\ndef linear_interpolation(tensors):\n    tensor1 = tf.constant(tensors[0])\n    tensor2 = tf.constant(tensors[1])\n\n    interpolated_tensor = tf.add(tensor1, tensor2)\n    interpolated_tensor = tf.multiply(interpolated_tensor, 0.1)\n\n    return interpolated_tensor\n",
            "\ndef interpolate_tensors(tensor1, tensor2):\n    tensor1 = tf.constant(tensor1, dtype=tf.float32)\n    tensor2 = tf.constant(tensor2, dtype=tf.float32)\n\n    interpolated_tensor = tf.add(tensor1, tf.multiply(tf.subtract(tensor2, tensor1), 0.2))\n    return interpolated_tensor.numpy().tolist()\n",
            "\ndef linear_interpolation(tensors):\n    tensor1, tensor2 = tf.constant(tensors[0]), tf.constant(tensors[1])\n    output = tf.multiply(tf.add(tensor1, tensor2), 0.1)\n    return output.numpy().tolist()\n",
            "\ndef interpolate_tensors(tensor1, tensor2):\n    tensor1 = tf.constant(tensor1, dtype=tf.float32)\n    tensor2 = tf.constant(tensor2, dtype=tf.float32)\n    t = tf.constant(0.1, dtype=tf.float32)\n    return tf.add(tf.multiply(tensor1, 1-t), tf.multiply(tensor2, t))\n",
            "\ndef linear_interpolation(tensors):\n    tensor1 = tf.constant(tensors[0])\n    tensor2 = tf.constant(tensors[1])\n    return tf.add(tensor1, tf.multiply(tf.subtract(tensor2, tensor1), 0.8))\n",
            "\ndef linear_interpolation(tensors):\n    tensor1, tensor2 = tensors\n    tensor1 = tf.convert_to_tensor(tensor1)\n    tensor2 = tf.convert_to_tensor(tensor2)\n    return tf.reduce_mean([tensor1, tensor2], axis=0)\n\ntensor1 = [[[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]], [[10.0, 20.0], [30.0, 40.0], [50.0, 60.0]]]\ntensor2 = [[[9.0, 8.0], [7.0, 6.0], [5.0, 4.0]], [[90.0, 80.0], [70.0, 60.0], [50.0, 40.0]]]\n",
            "\ndef interpolate_tensors(tensor1, tensor2):\n    tensor1 = tf.constant(tensor1, dtype=tf.float32)\n    tensor2 = tf.constant(tensor2, dtype=tf.float32)\n    \n    interpolated_tensor = tf.add(tensor1, tensor2) * 0.1\n    return interpolated_tensor\n",
            "\ndef interpolate_tensors(tensor1, tensor2):\n    tensor1 = tf.convert_to_tensor(tensor1, dtype=tf.float32)\n    tensor2 = tf.convert_to_tensor(tensor2, dtype=tf.float32)\n\n    result = tf.add(tensor1, tf.multiply(tf.subtract(tensor2, tensor1), 0.8))\n\n    return result\n",
            "\ndef linear_interpolation(tensor1, tensor2, alpha=0.9):\n    tensor1 = tf.convert_to_tensor(tensor1, dtype=tf.float32)\n    tensor2 = tf.convert_to_tensor(tensor2, dtype=tf.float32)\n    return tf.add(tf.multiply((1 - alpha), tensor1), tf.multiply(alpha, tensor2))\n"
        ],
        "target-program": "tf.add(in2, tf.multiply(tf.expand_dims(in3, 1), tf.subtract(in1, in2)))",
        "description": "linear interpolation between two tensors",
        "tf_operators": {
            "tf.multiply": 8,
            "tf.float32": 6,
            "tf.constant": 7,
            "tf.subtract": 4,
            "tf.add": 9,
            "tf.convert_to_tensor": 3,
            "tf.reduce_mean": 1
        },
        "coverage_percentage": 75.0,
        "total_in_target": 4,
        "total_covered": 3
    },
    {
        "task_id": "stackoverflow_36",
        "completions": [
            "\ndata = [1, 0, 1, 1, 0, 1, 0, 1]\n\ntensor = tf.constant(data, dtype=tf.float32)\n\nindices = tf.range(start=1, limit=len(data)+1, dtype=tf.float32)\n\nresult = tf.divide(tensor, indices)\n\n",
            "\narr = tf.constant([1, 0, 1, 1, 0, 1, 0, 1], dtype=tf.float32)\n\nindices = tf.range(start=1, limit=tf.size(arr) + 1, dtype=tf.float32)\n\nresult = tf.divide(arr, indices)\n\n",
            "\nlst = [1, 0, 1, 1, 0, 1, 0, 1]\n\ntensor = tf.reshape(lst, [2, 4])\n\ncol_indices = tf.range(tf.shape(tensor)[1], dtype=tensor.dtype)\n\nresult = tf.divide(tensor, col_indices + 1)\n\n",
            "\nlst = [1, 0, 1, 1, 0, 1, 0, 1]\n\ntensor = tf.constant(lst, dtype=tf.float32)\n\nindices = tf.range(start=1, limit=len(lst)+1, dtype=tf.float32)\n\nresult = tf.divide(tensor, indices)\n\n",
            "\ndata = [1, 0, 1, 1, 0, 1, 0, 1]\n\ntensor = tf.constant(data, dtype=tf.float32)\n\nindices = tf.range(start=1, limit=len(data)+1, dtype=tf.float32)\n\nresult = tf.divide(tensor, indices)\n\n",
            "\ninput = tf.constant([1, 0, 1, 1, 0, 1, 0, 1], dtype=tf.float32)\nindex = tf.range(start=1, limit=tf.size(input) + 1, dtype=tf.float32)\nresult = tf.divide(input, index)\n\noutput = result[0].numpy()\n",
            "\ninput_list = [1, 0, 1, 1, 0, 1, 0, 1]\n\ninput_tensor = tf.constant(input_list, dtype=tf.float32)\n\ncolumn_indices = tf.range(start=1, limit=len(input_list)+1, dtype=tf.float32)\n\noutput = tf.divide(input_tensor, column_indices)\n\n",
            "\nx = [1, 0, 1, 1, 0, 1, 0, 1]\n\nx_tensor = tf.convert_to_tensor(x, dtype=tf.float32)\n\nrange_tensor = tf.range(start=1, limit=len(x) + 1, dtype=tf.float32)\n\noutput = tf.divide(x_tensor, range_tensor)\n\n",
            "\ndef divide_by_column_index(input_data):\n    # Reshape the input into a 2D tensor\n    input_data = tf.reshape(input_data, (8, 1))\n    \n    # Create a tensor that represents the indices of each column\n    indices = tf.range(start=1, limit=9, dtype=tf.float32)\n    indices = tf.reshape(indices, (8, 1))\n\n    # Perform element-wise division\n    output = tf.divide(input_data, indices)\n    \n    return output\n",
            "\ndata = [1, 0, 1, 1, 0, 1, 0, 1]\n\ntensor = tf.constant(data, dtype=tf.float32)\n\nindices = tf.range(start=1, limit=len(data)+1, dtype=tf.float32)\n\nresult = tf.math.divide(tensor, indices)\n\nresult = tf.where(tf.math.is_inf(result), tensor, result)\n\n"
        ],
        "target-program": "tf.cast(tf.divide(in1, tf.add(in1, tf.range(8))), tf.float32)",
        "description": "divide each element by the column index",
        "tf_operators": {
            "tf.float32": 9,
            "tf.constant": 7,
            "tf.divide": 9,
            "tf.range": 10,
            "tf.size": 2,
            "tf.reshape": 2,
            "tf.shape": 1,
            "tf.convert_to_tensor": 1,
            "tf.where": 1,
            "tf.math.divide": 1,
            "tf.math.is_inf": 1
        },
        "coverage_percentage": 60.0,
        "total_in_target": 5,
        "total_covered": 3
    },
    {
        "task_id": "stackoverflow_37",
        "completions": [
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\n\nvector = tf.constant([1.0, 2.0, 3.5])\n\noutput = tf.tensordot(tensor, vector, axes=1)\n\n",
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([1.0, 2.0, 3.0])\n\ndot_product = tf.tensordot(tensor, vector, axes=1)\n\n",
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\n\nvector = tf.constant([1.5, 2.5, 3.5])\n\nresult = tf.tensordot(tensor, vector, axes=1)\n\n",
            "\ndef dot_product(tensor, vector):\n    return tf.tensordot(tensor, vector, axes=[[-1], [0]])\n\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([1.5, 2.0, 1.0])\noutput = dot_product(tensor, vector)\n",
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\n\nvector = tf.constant([1.0, 2.0, 3.0])\n\nresult = tf.tensordot(tensor, vector, axes=[[3],[0]])\n\n",
            "\ndef dot_product(tensor, vector):\n    return tf.tensordot(tensor, vector, axes=-1)\n\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([1.0, 1.5, 2.0])\nresult = dot_product(tensor, vector)\n",
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([0.5, 1.0, 1.5])\n\nresult = tf.tensordot(tensor, vector, axes=([-1], [0]))\n\n",
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([1.0, 1.5, 2.0])\n\nresult = tf.tensordot(tensor, vector, axes=[[3], [0]])\n\n",
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([1.5, 2.0, 2.5])\n\nresult = tf.tensordot(tensor, vector, axes=[-1, 0])\n\n",
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([1.5, 2.5, 3.5])\n\nresult = tf.tensordot(tensor, vector, axes=1)\n\n"
        ],
        "target-program": "tf.tensordot(in1, in2, 1)",
        "description": "dot product a vector with last dimension of a tensor",
        "tf_operators": {
            "tf.constant": 10,
            "tf.tensordot": 10
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_38",
        "completions": [
            "\ndef compute_product(input_data, mask):\n    input_tensor = tf.convert_to_tensor(input_data)\n    mask_tensor = tf.convert_to_tensor(mask)\n    masked_tensor = tf.boolean_mask(input_tensor, mask_tensor)\n    product = tf.reduce_prod(masked_tensor)\n    return product.numpy()\n",
            "\ndef compute_product(input_array, mask):\n    tensor = tf.constant(input_array, dtype=tf.int32)\n    mask_tensor = tf.constant(mask, dtype=tf.bool)\n    marked_elements = tf.boolean_mask(tensor, mask_tensor)\n    product = tf.reduce_prod(marked_elements)\n    return product.numpy()\n",
            "\ndef product_of_marked_elements(data, mask):\n    data_tensor = tf.convert_to_tensor(data)\n    mask_tensor = tf.convert_to_tensor(mask)\n    marked_elements = tf.boolean_mask(data_tensor, mask_tensor)\n    product = tf.reduce_prod(marked_elements)\n    return product.numpy()\n\n",
            "\ndef product_of_marked_elements(input_tensor, mask_tensor):\n    input_tensor = tf.constant(input_tensor)\n    mask_tensor = tf.constant(mask_tensor)\n    marked_elements = tf.multiply(input_tensor, mask_tensor)\n    product = tf.reduce_prod(marked_elements)\n    return product.numpy()\n\ninput_tensor = [9, 2, 5, 3, 7, 4]\nmask_tensor = [0, 0, 1, 0, 1, 0]\n\ninput_tensor = [[9, 2, 5, 3, 7, 4], [1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1]]\nmask_tensor = [[0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1]]\n",
            "\ndef product_of_marked_elements(elements, mask):\n    elements_tensor = tf.constant(elements, dtype=tf.int32)\n    mask_tensor = tf.constant(mask, dtype=tf.bool)\n    selected_elements = tf.boolean_mask(elements_tensor, mask_tensor)\n    product = tf.reduce_prod(selected_elements)\n    return product.numpy()\n",
            "\ndef compute_product(numbers, markers):\n    numbers_tensor = tf.constant(numbers, dtype=tf.float32)\n    markers_tensor = tf.constant(markers, dtype=tf.float32)\n    \n    marked_numbers = tf.multiply(numbers_tensor, markers_tensor)\n    product = tf.reduce_prod(marked_numbers)\n    \n    return product.numpy()\n\nnumbers = [9, 2, 5, 3, 7, 4]\nmarkers = [[0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1]]\n",
            "\ndef product_of_marked_elements(input_list, mask):\n    input_tensor = tf.constant(input_list, dtype=tf.int32)\n    mask_tensor = tf.constant(mask, dtype=tf.bool)\n    marked_elements = tf.boolean_mask(input_tensor, mask_tensor)\n    product = tf.reduce_prod(marked_elements)\n    return product.numpy()\n",
            "\ndef product_of_marked_elements(input, mask):\n    input_tensor = tf.convert_to_tensor(input)\n    mask_tensor = tf.convert_to_tensor(mask)\n    marked_elements = tf.boolean_mask(input_tensor, mask_tensor)\n    product = tf.reduce_prod(marked_elements)\n    return product.numpy()\n\ninput = [9, 2, 5, 3, 7, 4]\nmask = [0, 0, 1, 0, 1, 0]\n\ninput = [[0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1]]\nmask = [[0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1]]\n",
            "\ndef product_of_marked_elements(data, mask):\n    data_tf = tf.constant(data)\n    mask_tf = tf.constant(mask)\n    selected_elements = tf.boolean_mask(data_tf, mask_tf)\n    product = tf.reduce_prod(selected_elements)\n    return product.numpy()\n",
            "\ndef marked_product(elements, markers):\n    elements_tensor = tf.constant(elements, dtype=tf.float32)\n    markers_tensor = tf.constant(markers, dtype=tf.float32)\n    \n    marked_elements = tf.multiply(elements_tensor, markers_tensor)\n    product = tf.reduce_prod(marked_elements)\n    \n    return product.numpy()\n"
        ],
        "target-program": "tf.reduce_prod(tf.maximum(tf.reduce_max(in2), tf.multiply(in1, in2)), axis=1)",
        "description": "compute the product of marked elements",
        "tf_operators": {
            "tf.reduce_prod": 10,
            "tf.convert_to_tensor": 3,
            "tf.boolean_mask": 7,
            "tf.int32": 3,
            "tf.constant": 7,
            "tf.bool": 3,
            "tf.multiply": 3,
            "tf.float32": 2
        },
        "coverage_percentage": 50.0,
        "total_in_target": 4,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_39",
        "completions": [
            "\ndata = [[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]]\n\ntensor_data = tf.constant(data)\n\nresult = tf.where(tf.abs(tensor_data) < 1, 0, tf.square(tensor_data))\n\n",
            "\ndata = [[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]]\n\ntensor = tf.constant(data)\n\nresult = tf.where(tf.abs(tensor) < 1, 0, tf.square(tensor))\n\n",
            "\ndef process_tensor(input_list):\n    tensor = tf.convert_to_tensor(input_list, dtype=tf.float32)\n    abs_tensor = tf.math.abs(tensor)\n    result = tf.where(abs_tensor < 1, 0, tf.square(tensor))\n    return result.numpy().tolist()\n",
            "\ninput_tensor = tf.constant([[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]])\n\noutput_tensor = tf.where(tf.abs(input_tensor) < 1, 0, tf.square(input_tensor))\n\n",
            "\ndef process_array(arr):\n    tensor = tf.constant(arr, dtype=tf.float32)\n    result = tf.where(tf.abs(tensor) < 1, 0, tf.square(tensor))\n    return tf.reduce_sum(result, axis=1)\n",
            "\ndef process_data(input_data):\n    tensor_data = tf.convert_to_tensor(input_data, dtype=tf.float32)\n    mask = tf.less(tf.abs(tensor_data), 1)\n    result = tf.where(mask, 0, tf.square(tensor_data))\n    return result.numpy()\n",
            "\ndef process_data(input_data):\n    # Convert the input list to a TensorFlow tensor\n    input_tensor = tf.constant(input_data, dtype=tf.float32)\n\n    # Compute the absolute values of the tensor elements\n    abs_values = tf.abs(input_tensor)\n\n    # Create a condition tensor that is true where the absolute values are less than 1\n    condition = tf.less(abs_values, 1.0)\n\n    # Create a tensor of zeros with the same shape as the input tensor\n    zeros = tf.zeros_like(input_tensor)\n\n    # Compute the squares of the original tensor elements\n    squares = tf.square(input_tensor)\n\n    # Use tf.where to conditionally select elements from the zeros tensor or the squares tensor\n    output_tensor = tf.where(condition, zeros, squares)\n\n    # Convert the output tensor back to a list\n    output_data = output_tensor.numpy().tolist()\n\n    return output_data\n",
            "\ndata = [[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]]\n\ntensor = tf.constant(data)\n\nabs_tensor = tf.math.abs(tensor)\n\noutput = tf.where(abs_tensor < 1.0, 0.0, tf.square(tensor))\n\n",
            "\ndata = [[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]]\n\ntensor = tf.constant(data)\n\nabs_tensor = tf.abs(tensor)\n\nresult = tf.where(abs_tensor < 1, 0, tf.square(tensor))\n\n",
            "\ndata = [[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]]\n\ntensor = tf.constant(data)\n\nresult = tf.where(tf.abs(tensor) < 1, 0, tf.square(tensor))\n\n"
        ],
        "target-program": "tf.multiply(tf.square(in1), tf.cast(tf.cast(tf.cast(in1, tf.int32), tf.bool), tf.float32))",
        "description": "(\\'set to 0 the elements with absolute value less than 1, and square the other elements\\')",
        "tf_operators": {
            "tf.abs": 8,
            "tf.where": 10,
            "tf.constant": 8,
            "tf.square": 10,
            "tf.math.abs": 2,
            "tf.convert_to_tensor": 2,
            "tf.float32": 4,
            "tf.reduce_sum": 1,
            "tf.less": 2,
            "tf.zeros_like": 1
        },
        "coverage_percentage": 33.33333333333333,
        "total_in_target": 6,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_40",
        "completions": [
            "\ndef make_sparse_tensor(input):\n    values, indices = tf.nn.top_k(input, k=5)\n    sparse_tensor = tf.SparseTensor(indices=tf.expand_dims(indices, -1), values=values, dense_shape=[len(input)])\n    return sparse_tensor\n",
            "\ndef create_sparse_tensor(input_tensor, k):\n    values, indices = tf.nn.top_k(input_tensor, k)\n    sparse_tensor = tf.SparseTensor(indices, values, input_tensor.shape)\n    dense_tensor = tf.sparse.to_dense(sparse_tensor)\n    return dense_tensor\n",
            "\ndef make_sparse_tensor(input):\n    values, indices = tf.nn.top_k(input, k=5)\n    sparse_tensor = tf.SparseTensor(indices, values, dense_shape=tf.shape(input, out_type=tf.int64))\n    return sparse_tensor\n",
            "\ndef create_sparse_tensor(input_tensor):\n    # Find the top k=1 values and their indices\n    values, indices = tf.nn.top_k(input_tensor, k=1)\n    \n    # Create a sparse tensor using the indices and values\n    sparse_tensor = tf.SparseTensor(indices, values, dense_shape=tf.shape(input_tensor))\n    \n    return sparse_tensor\n",
            "\ndef top_k_to_sparse_tensor(input):\n    input_tensor = tf.constant(input, dtype=tf.int32)\n    values, indices = tf.nn.top_k(input_tensor, k=tf.size(input_tensor))\n    sparse_tensor = tf.sparse.SparseTensor(indices=tf.expand_dims(indices, -1), values=values, dense_shape=tf.shape(input_tensor))\n    output_tensor = tf.sparse.to_dense(sparse_tensor, validate_indices=False)\n    return output_tensor\n\ninput = [4, 5, 2, 7, 8, 6]\noutput = top_k_to_sparse_tensor(input)\n",
            "\ndef make_sparse_tensor(input_tensor):\n    values, indices = tf.nn.top_k(input_tensor, k=1)\n    sparse_tensor = tf.sparse.SparseTensor(indices, values, input_tensor.shape)\n    return tf.sparse.to_dense(sparse_tensor, validate_indices=False)\n",
            "\ndef top_k_to_sparse_tensor(input_tensor, k):\n    values, indices = tf.nn.top_k(input_tensor, k)\n    sparse_tensor = tf.SparseTensor(indices=tf.expand_dims(indices, -1), values=values, dense_shape=input_tensor.shape)\n    dense_tensor = tf.sparse.to_dense(sparse_tensor, default_value=0)\n    return dense_tensor\n",
            "\ndef make_sparse_tensor(input):\n    values, indices = tf.nn.top_k(input, k=5)\n    sparse_tensor = tf.sparse.SparseTensor(indices, values, dense_shape=tf.shape(input))\n    return sparse_tensor\n",
            "\ndef top_k_to_sparse_tensor(input_tensor, k=2):\n    top_k_values, top_k_indices = tf.nn.top_k(input_tensor, k)\n    sparse_tensor = tf.sparse.SparseTensor(top_k_indices, top_k_values, tf.shape(input_tensor, out_type=tf.int64))\n    dense_tensor = tf.sparse.to_dense(sparse_tensor)\n    return dense_tensor\n\ninput_tensor = tf.constant([4, 5, 2, 7, 8, 6])\noutput_tensor = top_k_to_sparse_tensor(input_tensor)\n",
            "\ndef create_sparse_tensor(input, k):\n    top_k_values, top_k_indices = tf.nn.top_k(input, k)\n    sparse_tensor = tf.SparseTensor(top_k_indices, top_k_values, tf.shape(input))\n    return sparse_tensor\n"
        ],
        "target-program": "tf.sparse.to_dense(tf.SparseTensor(tf.cast(in2, tf.int64), in1, (3, 5)))",
        "description": "use the output of tf.nn.top_k to make a sparse tensor",
        "tf_operators": {
            "tf.nn.top_k": 10,
            "tf.expand_dims": 3,
            "tf.SparseTensor": 6,
            "tf.sparse.to_dense": 5,
            "tf.int64": 2,
            "tf.shape": 6,
            "tf.int32": 1,
            "tf.sparse.SparseTensor": 4,
            "tf.constant": 2,
            "tf.size": 1
        },
        "coverage_percentage": 75.0,
        "total_in_target": 4,
        "total_covered": 3
    },
    {
        "task_id": "stackoverflow_41",
        "completions": [
            "\ndef get_element_at_index(lst, idx):\n    tensor = tf.constant(lst)\n    return tf.gather(tensor, idx).numpy()\n",
            "\ndef get_element(array, index):\n    tensor = tf.constant(array)\n    return tf.gather(tensor, index).numpy()\n",
            "\ndef copy_except_index(lst, idx):\n    indices = tf.range(len(lst), dtype=tf.int32)\n    indices = tf.boolean_mask(indices, indices != idx)\n    result = tf.gather(lst, indices)\n    return result\n\nlst = [5, 2, 8, 2, 4, 1, 1, 0, 2, 1]\nidx = 3\n",
            "\ndef copy_except_index(elements, index):\n    tensor = tf.constant(elements)\n    indices = tf.concat([tf.range(index), tf.range(index+1, tf.size(tensor))], 0)\n    result = tf.gather(tensor, indices)\n    return result\n\nelements = [5, 2, 8, 2, 4, 1, 1, 0, 2, 1]\nindex = 3\n",
            "\nlst = [5, 2, 8, 2, 4, 1, 1, 0, 2, 1]\n\ntf_lst = tf.constant(lst)\n\ndef get_element(index):\n  # Access the element at the given index\n  return tf_lst[index].numpy()\n\n",
            "\ndata = tf.constant([5, 2, 8, 2, 4, 1, 1, 0, 2, 1])\n\ndef get_element(index):\n    return tf.gather(data, index)\n\n",
            "\ndef get_element_at_index(input_list, index):\n    tensor_list = tf.constant(input_list)\n    return tf.gather(tensor_list, index).numpy()\n",
            "\ndef remove_element(tensor, index):\n    first_part = tf.slice(tensor, [0], [index])\n    second_part = tf.slice(tensor, [index+1], [tf.size(tensor) - index - 1])\n    result = tf.concat([first_part, second_part], 0)\n    return result\n\ntensor = tf.constant([5, 2, 8, 2, 4, 1, 1, 0, 2, 1], dtype=tf.int32)\nindex = 3\n",
            "\ndef get_element_at_index(input_list, index):\n    tensor_list = tf.constant(input_list)\n    return tf.gather(tensor_list, index)\n\ninput_list = [5, 2, 8, 2, 4, 1, 1, 0, 2, 1]\nindex = 3\n",
            "\ndef copy_except_index(lst, index):\n    tensor = tf.constant(lst)\n    indices = [i for i in range(tensor.shape[0]) if i != index]\n    result = tf.gather(tensor, indices)\n    return result\n\nlst = [5, 2, 8, 2, 4, 1, 1, 0, 2, 1]\nindex = 5\n"
        ],
        "target-program": "tf.boolean_mask(in1, tf.not_equal(tf.constant(in2), tf.range(10)))",
        "description": "copy all elements except at the given index",
        "tf_operators": {
            "tf.gather": 8,
            "tf.constant": 9,
            "tf.range": 2,
            "tf.boolean_mask": 1,
            "tf.int32": 2,
            "tf.size": 2,
            "tf.concat": 2,
            "tf.slice": 1
        },
        "coverage_percentage": 75.0,
        "total_in_target": 4,
        "total_covered": 3
    },
    {
        "task_id": "stackoverflow_42",
        "completions": [
            "\ndef max_one_hot(vector):\n    max_index = tf.argmax(vector)\n    one_hot_vector = tf.one_hot(max_index, len(vector), on_value=1)\n    return one_hot_vector.numpy()\n\nvector = tf.constant([4, 6, 2, 6, 7, 3, -3])\n",
            "\ndef create_binary_vector(input):\n    input_tensor = tf.constant(input, dtype=tf.int32)\n    max_value = tf.reduce_max(input_tensor)\n    binary_vector = tf.cast(tf.equal(input_tensor, max_value), tf.int32)\n    return binary_vector\n",
            "\ndef binary_vector(input_list):\n    # Convert the input list into a TensorFlow tensor\n    input_tensor = tf.constant(input_list)\n\n    # Calculate the maximum value of the tensor\n    max_value = tf.reduce_max(input_tensor)\n\n    # Compare each element of the tensor with the maximum value\n    binary_tensor = tf.equal(input_tensor, max_value)\n\n    # Convert the boolean tensor into a binary tensor\n    binary_vector = tf.cast(binary_tensor, tf.int32)\n\n    return binary_vector\n",
            "\ndef create_binary_vector(input_list):\n    tensor = tf.constant(input_list)\n    max_index = tf.math.argmax(tensor)\n    binary_vector = tf.one_hot(max_index, depth=len(input_list))\n    return binary_vector.numpy()\n\n",
            "\ndef binary_vector(input):\n    tensor = tf.convert_to_tensor(input)\n    max_index = tf.math.argmax(tensor)\n    zeros = tf.zeros_like(tensor)\n    return tf.tensor_scatter_nd_update(zeros, [[max_index]], [1]).numpy()\n",
            "\ndef binary_vector(input_list):\n    tensor = tf.constant(input_list)\n    max_val = tf.reduce_max(tensor)\n    binary_vector = tf.cast(tf.equal(tensor, max_val), tf.int32)\n    return binary_vector.numpy()\n\n",
            "\ndef binary_vector_max_one(lst):\n    max_index = tf.argmax(lst)\n    binary_vector = tf.one_hot(max_index, depth=len(lst))\n    return binary_vector.numpy()\n\nlst = [4, 6, 2, 6, 7, 3, -3]\n",
            "\ndef create_binary_vector(input_list):\n    tensor = tf.constant(input_list)\n    max_value = tf.math.reduce_max(tensor)\n    binary_vector = tf.where(tensor == max_value, 1, 0)\n    return binary_vector\n",
            "\ndef binary_vector(input_list):\n    max_element = tf.reduce_max(input_list)\n    result = tf.cond(max_element > 0, lambda: 1, lambda: 0)\n    return result\n",
            "\ndef create_binary_vector(input_array):\n    max_index = tf.argmax(input_array)\n    zeros_vector = tf.zeros_like(input_array)\n    indices = tf.reshape(max_index, [1, -1])\n    updates = tf.constant([1])\n    binary_vector = tf.tensor_scatter_nd_update(zeros_vector, indices, updates)\n    return binary_vector\n\ninput_array = tf.constant([4, 6, 2, 6, 7, 3, -3])\noutput = create_binary_vector(input_array)\n"
        ],
        "target-program": "tf.cast(tf.equal(in1, tf.reduce_max(in1)), tf.int32)",
        "description": "create a binary vector where the max element is 1",
        "tf_operators": {
            "tf.constant": 7,
            "tf.one_hot": 3,
            "tf.argmax": 3,
            "tf.equal": 3,
            "tf.int32": 3,
            "tf.cast": 3,
            "tf.reduce_max": 4,
            "tf.math.argmax": 2,
            "tf.convert_to_tensor": 1,
            "tf.zeros_like": 2,
            "tf.tensor_scatter_nd_update": 2,
            "tf.where": 1,
            "tf.math.reduce_max": 1,
            "tf.cond": 1,
            "tf.reshape": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 4,
        "total_covered": 4
    },
    {
        "task_id": "stackoverflow_43",
        "completions": [
            "\ndef extract_elements(tensor, indices):\n    tensor = tf.constant(tensor)\n    indices = tf.constant(indices)\n    gathered = tf.gather_nd(tensor, tf.stack((indices, tf.range(tf.size(indices))), axis=1))\n    return gathered\n",
            "\ndef extract_elements(tensor, indices):\n    tensor = tf.constant(tensor)\n    indices = [[indices[i], i] for i in range(len(indices))]\n    return tf.gather_nd(tensor, indices)\n",
            "\ntensor = tf.constant([[12, 34, 56, 78, 90, 10], [99, 88, 77, 55, 44, 33], [-1, -2, -3, -4, -5, -6]])\nindices = tf.constant([0, 1, 1, 0, 2, 0])\n\ngather_indices = tf.stack([indices, tf.range(tf.shape(indices)[0])], axis=1)\n\nresult = tf.gather_nd(tensor, gather_indices)\n",
            "\ntensor = tf.constant([[12, 34, 56, 78, 90, 10], [99, 88, 77, 55, 44, 33], [-1, -2, -3, -4, -5, -6]])\nindices = tf.constant([0, 1, 1, 0, 2, 0])\n\nindices_2d = tf.stack([indices, tf.range(tf.shape(indices)[0])], axis=1)\n\noutput = tf.gather_nd(tensor, indices_2d)\n",
            "\ndef extract_elements(data, indices):\n    tensor_data = tf.constant(data)\n    tensor_indices = tf.constant(indices)\n    return tf.gather_nd(tensor_data, tensor_indices)\n\ndata = [[12, 34, 56, 78, 90, 10], [99, 88, 77, 55, 44, 33], [-1, -2, -3, -4, -5, -6]]\nindices = [0, 1, 1, 0, 2, 0]\n",
            "\ntensor = tf.constant([[12, 34, 56, 78, 90, 10], [99, 88, 77, 55, 44, 33], [-1, -2, -3, -4, -5, -6]])\nindices = tf.constant([0, 1, 1, 0, 2, 0])\n\nindex_list = tf.stack([indices, tf.range(tf.size(indices))], axis=1)\n\nresult = tf.gather_nd(tensor, index_list)\n\n",
            "\ntensor = tf.constant([[12, 34, 56, 78, 90, 10], [99, 88, 77, 55, 44, 33], [-1, -2, -3, -4, -5, -6]])\nindices = tf.constant([0, 1, 1, 0, 2, 0])\n\nresult = tf.gather_nd(tensor, tf.stack((indices, tf.range(tf.size(indices))), axis=1))\n\n",
            "\nparams = tf.constant([[12, 34, 56, 78, 90, 10], [99, 88, 77, 55, 44, 33], [-1, -2, -3, -4, -5, -6]])\n\nindices = tf.constant([0, 1, 1, 0, 2, 0])\n\nindices_2d = tf.stack([indices, tf.range(tf.size(indices))], axis=1)\n\noutput = tf.gather_nd(params, indices_2d)\n",
            "\ntensor_2d = tf.constant([[12, 34, 56, 78, 90, 10], [99, 88, 77, 55, 44, 33], [-1, -2, -3, -4, -5, -6]])\n\nindices = tf.constant([0, 1, 1, 0, 2, 0])\n\npositions = tf.range(tf.shape(indices)[0])\n\nindices_tensor = tf.stack([indices, positions], axis=1)\n\noutput = tf.gather_nd(tensor_2d, indices_tensor)\n",
            "\ndef extract_elements(tensor, indices):\n    tensor = tf.constant(tensor)\n    indices = tf.constant(indices)\n    indices = tf.reshape(indices, (-1, 1))\n    result = tf.gather_nd(tensor, indices)\n    return result.numpy()[0]\n\n"
        ],
        "target-program": "tf.gather_nd(tf.transpose(in1), tf.expand_dims(in2, 1), batch_dims=1)",
        "description": "extract elements of a tensor given row indices",
        "tf_operators": {
            "tf.stack": 7,
            "tf.constant": 10,
            "tf.size": 4,
            "tf.range": 7,
            "tf.gather_nd": 10,
            "tf.shape": 3,
            "tf.reshape": 1
        },
        "coverage_percentage": 33.33333333333333,
        "total_in_target": 3,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_44",
        "completions": [
            "\ndata = [[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]]\n\ndata_tensor = tf.constant(data)\n\ndata_tensor_reshaped = tf.reshape(data_tensor, (-1, 2, 3))\n\npair_sums = tf.reduce_sum(data_tensor_reshaped, axis=1)\n\nresult = tf.reduce_sum(pair_sums, axis=1)\n",
            "\ndef sum_consecutive_pairs(data):\n    # Convert the data to a Tensor\n    data_tensor = tf.constant(data, dtype=tf.int32)\n    \n    # Reshape the tensor into pairs of consecutive rows\n    reshaped_tensor = tf.reshape(data_tensor, (-1, 2, data_tensor.shape[1]))\n    \n    # Sum across columns for each pair\n    sums = tf.reduce_sum(reshaped_tensor, axis=1)\n    \n    # Index the tensor with a step of 2, starting from the first element\n    result = sums[::2]\n    \n    return result.numpy().tolist()\n",
            "\ndata = [[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]]\n\ntensor_data = tf.constant(data)\n\nreshaped_data = tf.reshape(tensor_data, (-1, 2, tensor_data.shape[1]))\n\nresult = tf.reduce_sum(reshaped_data, axis=1)\n\n",
            "\ndef sum_consecutive_pairs(input_list):\n    tensor = tf.constant(input_list, dtype=tf.int32)\n    reshaped = tf.reshape(tensor, (-1, 2, 3))\n    summed = tf.reduce_sum(reshaped, axis=[1, 2])\n    return summed\n",
            "\ndef sum_consecutive_rows(input_list):\n    tensor = tf.constant(input_list)\n    reshaped_tensor = tf.reshape(tensor, (-1, 2, tensor.shape[1]))\n    sum_tensor = tf.reduce_sum(reshaped_tensor, axis=1)\n    return sum_tensor.numpy().tolist()\n\ninput_list = [[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]]\n",
            "\ndef sum_across_columns(input_list):\n    tensor = tf.convert_to_tensor(input_list)\n    reshaped_tensor = tf.reshape(tensor, (-1, 2, 3))\n    summed_tensor = tf.reduce_sum(reshaped_tensor, axis=1)\n    output_list = summed_tensor.numpy().tolist()\n    return output_list\n",
            "\ndata = [[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]]\n\ntensor = tf.constant(data)\n\nreshaped_tensor = tf.reshape(tensor, (-1, 2, tensor.shape[1]))\n\nsum_tensor = tf.reduce_sum(reshaped_tensor, axis=[1])\n\nresult = sum_tensor.numpy().tolist()\n\n",
            "\ndata = tf.constant([[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]])\n\nreshaped_data = tf.reshape(data, (-1, 2, 3))\n\noutput = tf.reduce_sum(reshaped_data, axis=[1, 2])\n\n",
            "\ndef sum_consecutive_pairs(input_list):\n    input_tensor = tf.convert_to_tensor(input_list)\n    reshaped_tensor = tf.reshape(input_tensor, (-1, 2))\n    sum_across_columns = tf.reduce_sum(reshaped_tensor, axis=1)\n    total_sum = tf.reduce_sum(sum_across_columns, axis=0)\n    return total_sum\n\ninput_list = [[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]]\n",
            "\ndata = [[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]]\n\ndata_tensor = tf.constant(data, dtype=tf.int32)\n\nreshaped_tensor = tf.reshape(data_tensor, [int(data_tensor.shape[0]/2), int(data_tensor.shape[1]*2)])\n\nresult = tf.reduce_sum(reshaped_tensor, axis=1)\n\n"
        ],
        "target-program": "tf.squeeze(tf.reduce_sum(tf.reshape(in1, (-1, 2, in1.shape[1])), axis=1))",
        "description": "sum across columns for pairs of consecutive rows",
        "tf_operators": {
            "tf.constant": 8,
            "tf.reduce_sum": 10,
            "tf.reshape": 10,
            "tf.int32": 3,
            "tf.convert_to_tensor": 2
        },
        "coverage_percentage": 66.66666666666666,
        "total_in_target": 3,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_45",
        "completions": [
            "\ndata = [[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]]\n\ntensor_data = tf.constant(data)\n\nresult = []\n\nfor i in range(tensor_data.shape[1]):\n    # If index is even, reverse the order of elements in the row\n    if i % 2 == 0:\n        result.append(tf.reverse(tensor_data[0][i], axis=[0]))\n    else:\n        result.append(tensor_data[0][i])\n\nresult = tf.stack(result)\n\n",
            "\ndata = tf.constant([[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]])\n\nmask = tf.constant([True, False, True, False, True])\n\nmasked_data = tf.boolean_mask(data, mask, axis=1)\n\nreversed_data = tf.reverse(masked_data, axis=[2])\n\noutput = tf.where(mask, reversed_data, data)\n\n",
            "\ninput_tensor = tf.constant([[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]])\n\noutput_tensor = tf.reverse(input_tensor, axis=[2])\n\n",
            "\ndata = [[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]]\n\ntensor = tf.constant(data)\n\nindices = tf.range(0, tf.shape(tensor)[1], 2)\n\nreversed_tensor = tf.tensor_scatter_nd_update(tensor, tf.expand_dims(indices, 1), tf.reverse(tensor[indices], [1]))\n\n",
            "\ninput_tensor = tf.constant([[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]])\n\noutput_tensor = tf.reverse(input_tensor, axis=[2])\n\n",
            "\ndata = [[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]]\n\ntensor = tf.constant(data)\n\nreversed_tensor = tf.reverse(tensor, axis=[-1])\n\noutput = reversed_tensor.numpy().tolist()\n\n",
            "\ndata = [[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]]\n\ntensor = tf.constant(data)\n\nmarked_rows = [0, 2, 4]\n\noutput = tf.tensor_scatter_nd_update(tensor, tf.reshape(tf.range(len(marked_rows)), [-1, 1]), tf.reverse(tensor[0, marked_rows], axis=[1]))\n\n",
            "\ninput_tensor = tf.constant([[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]])\n\noutput_tensor = tf.reverse(input_tensor, axis=[-1])\n\n",
            "\ndata = [[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]]\n\ntensor = tf.constant(data)\n\nresult = tf.reverse(tensor, axis=[2])\n\noutput = result.numpy().tolist()\n\n",
            "\ndef reverse_marked_rows(input_list):\n    # Convert the input list to a Tensorflow tensor\n    tensor = tf.constant(input_list)\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the rows of the tensor\n    for i in range(tensor.shape[1]):\n        # If the index is odd, reverse the order of elements in the row\n        if i % 2 == 0:\n            result.append(tf.reverse(tensor[0, i], axis=[0]).numpy().tolist())\n        else:\n            result.append(tensor[0, i].numpy().tolist())\n\n    return result\n"
        ],
        "target-program": "tf.where(tf.sequence_mask(in2), x=tf.roll(in1, 1, -1), y=in1)",
        "description": "reverse the order in the marked rows",
        "tf_operators": {
            "tf.stack": 1,
            "tf.constant": 10,
            "tf.reverse": 10,
            "tf.where": 1,
            "tf.boolean_mask": 1,
            "tf.shape": 1,
            "tf.expand_dims": 1,
            "tf.range": 2,
            "tf.tensor_scatter_nd_update": 2,
            "tf.reshape": 1
        },
        "coverage_percentage": 33.33333333333333,
        "total_in_target": 3,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_46",
        "completions": [
            "\ndef segment_lengths_to_ids(segment_lengths):\n    segment_ids = tf.cumsum(segment_lengths) - 1\n    return tf.gather(segment_ids, 0)\n\nsegment_lengths = tf.constant([3, 4, 1])\n",
            "\ndef segment_lengths_to_ids(lengths):\n    lengths = tf.constant(lengths, dtype=tf.int32)\n    ids = tf.cumsum(lengths) - 1\n    return ids\n\nlengths = [3, 4, 1]\nsegment_ids = segment_lengths_to_ids(lengths)\n",
            "\ndef segment_lengths_to_ids(lengths):\n    ids = tf.cumsum(lengths, exclusive=True)\n    return ids[0]\n\nlengths = tf.constant([3, 4, 1])\n",
            "\ndef convert_segment_lengths_to_ids(lengths):\n    segment_ids = tf.cumsum(lengths, exclusive=True) - 1\n    return segment_ids[0].numpy()\n\nlengths = tf.constant([3, 4, 1])\n",
            "\nsegment_lengths = tf.constant([3, 4, 1])\n\ncumulative_sum = tf.cumsum(segment_lengths)\n\nsegment_ids = cumulative_sum - 1\n\nsegment_id = segment_ids[0]\n\n",
            "\ndef segment_lengths_to_ids(lengths):\n    lengths_tensor = tf.constant(lengths, dtype=tf.int32)\n    segment_ids = tf.cumsum(lengths_tensor, exclusive=True)\n    return segment_ids\n\nlengths = [3, 4, 1]\nsegment_ids = segment_lengths_to_ids(lengths)\n",
            "\ndef segment_lengths_to_ids(lengths):\n    return tf.cumsum(lengths, exclusive=True) - 1\n",
            "\ndef segment_lengths_to_ids(lengths):\n    return tf.cumsum(lengths, exclusive=True) - 1\n\nlengths = tf.constant([3, 4, 1])\nsegment_ids = segment_lengths_to_ids(lengths)\n",
            "\ndef segment_lengths_to_ids(lengths):\n    return tf.cumsum(lengths, exclusive=True)\n\nlengths = [3, 4, 1]\n",
            "\ndef convert_segment_lengths_to_ids(lengths):\n    ids = tf.range(len(lengths))\n    segment_id = tf.reduce_sum(ids) - len(lengths)\n    return segment_id\n\nlengths = [3, 4, 1]\n"
        ],
        "target-program": "tf.cast(tf.where(tf.sequence_mask(in1))[:, 0], tf.int32)",
        "description": "convert segment lengths to segment ids",
        "tf_operators": {
            "tf.gather": 1,
            "tf.constant": 7,
            "tf.cumsum": 9,
            "tf.int32": 2,
            "tf.range": 1,
            "tf.reduce_sum": 1
        },
        "coverage_percentage": 25.0,
        "total_in_target": 4,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_47",
        "completions": [
            "\ndef sequence_mask(input):\n    # Convert boolean values into integer values\n    input_int = tf.cast(input, tf.int32)\n    \n    # Apply sequence mask to integer values\n    mask = tf.sequence_mask(input_int)\n    \n    # Convert mask tensor into list of integer values\n    output = tf.cast(mask, tf.int32)\n    \n    return output\n",
            "\ndef sequence_mask(values):\n    mask = tf.sequence_mask(values)\n    result = tf.reduce_sum(tf.cast(mask, tf.int32), axis=-1)\n    return result.numpy().tolist()\n",
            "\ndef generate_sequence_mask(input):\n    if isinstance(input[0], bool):\n        lengths = [len([x for x in sublist if x]) for sublist in input]\n    else:\n        lengths = input\n    return tf.sequence_mask(lengths, maxlen=4).numpy().tolist()\n",
            "\ndef sequence_mask(input):\n    if isinstance(input[0], bool):\n        return tf.reduce_sum(tf.cast(input, tf.int32), axis=1)\n    else:\n        mask = [True]*3 + [False]*(len(input)-3)\n        return tf.boolean_mask(input, mask)\n",
            "\nvalues = [[True, True, True, False, False], [True, True, False, False, False], [True, True, True, True, True], [True, True, True, True, False], [True, False, False, False, False], [True, True, False, False, False]]\n\nvalues_int = tf.cast(values, tf.int32)\n\nmask = tf.sequence_mask(values_int)\n\n",
            "\ninput1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\ninput1 = tf.reshape(input1, [1, -1])  # reshape into 2D\nlengths1 = tf.reduce_sum(tf.cast(tf.less(input1, 3), tf.int32), axis=1)  # count elements until 3\noutput1 = tf.sequence_mask(lengths1, 5)  # generate sequence mask\n\ninput2 = [[True, True, True, False, False], [True, True, False, False, False], [True, True, True, True, True], [True, True, True, True, False], [True, False, False, False, False], [True, True, False, False, False]]\nlengths2 = tf.reduce_sum(tf.cast(input2, tf.int32), axis=1)  # count True values in each list\noutput2 = tf.sequence_mask(lengths2, 5)  # generate sequence mask\n",
            "\nlengths = [1, 3, 2]\nmask = tf.sequence_mask(lengths, 5)\n",
            "\nx = [[True, True, True, False, False], [True, True, False, False, False], [True, True, True, True, True], [True, True, True, True, False], [True, False, False, False, False], [True, True, False, False, False]]\n\nlengths = tf.reduce_sum(tf.cast(x, tf.int32), axis=1)\n\nmask = tf.sequence_mask(lengths, maxlen=5)\n\noutput = tf.cast(mask, tf.int32)\n\n",
            "\ndef sequence_mask(values):\n    values = tf.cast(values, tf.int32)\n    lengths = tf.reduce_sum(values, axis=-1)\n    mask = tf.sequence_mask(lengths)\n    result = tf.reduce_sum(tf.cast(mask, tf.int32), axis=-1)\n    return result\n",
            "\ndef sequence_mask(values):\n    tensor = tf.constant(values, dtype=tf.int32)\n    mask = tf.sequence_mask(tensor)\n    result = tf.cast(mask, tf.int32)\n    return result.numpy()\n"
        ],
        "target-program": "tf.reshape(tf.gather(in1, tf.cumsum(tf.reshape(tf.cast(in2, tf.int32), [-1]), exclusive=True) * tf.reshape(tf.cast(in2, tf.int32), [-1])), in2.shape)",
        "description": "put given values into a sequence mask",
        "tf_operators": {
            "tf.sequence_mask": 9,
            "tf.cast": 8,
            "tf.int32": 8,
            "tf.reduce_sum": 5,
            "tf.boolean_mask": 1,
            "tf.reshape": 1,
            "tf.less": 1,
            "tf.constant": 1
        },
        "coverage_percentage": 60.0,
        "total_in_target": 5,
        "total_covered": 3
    },
    {
        "task_id": "stackoverflow_48",
        "completions": [
            "\ndef find_index(tensor, element):\n    return tf.where(tf.equal(tensor, element)).numpy()[0][0]\n\ntensor = tf.constant([32, 53, 45, 38, 29, 89, 64, 23])\nelement = tensor[0]\nindex = find_index(tensor, element)\n",
            "\ndef find_index(lst):\n    tensor = tf.constant(lst)\n    element = tensor[0]\n    indices = tf.where(tf.equal(tensor, element))\n    return indices[0][0].numpy()\n\n",
            "",
            "\ntensor = tf.constant([32, 53, 45, 38, 29, 89, 64, 23])\n\nvalue = 38\n\nindices = tf.where(tf.equal(tensor, value))\n\n",
            "\ndef find_indices(input_list):\n    indices = tf.range(len(input_list))\n    return indices\n",
            "\ndef find_indices(input_list, target=38):\n    tensor = tf.constant(input_list)\n    indices = tf.where(tf.equal(tensor, target))\n    return indices.numpy()[0][0]\n\nfind_indices([32, 53, 45, 38, 29, 89, 64, 23])  # Output: 3\nfind_indices([38, 53, 89, 38, 32, 64])  # Output: 1\n",
            "\ndef find_index(array, value):\n    tensor = tf.constant(array)\n    indices = tf.where(tf.equal(tensor, value))\n    return indices.numpy()[0][0]\n",
            "\ndef find_index(arr):\n  arr_tf = tf.constant(arr)\n  indices = tf.where(arr_tf == 38)\n  return indices[0][0] if indices.shape[0] > 0 else -1\n",
            "\ndef find_index(input_list, target):\n    tensor = tf.constant(input_list)\n    indices = tf.where(tf.equal(tensor, target))\n    first_index = tf.gather(indices, 0)\n    return first_index.numpy()[0]\n\ninput_list = [32, 53, 45, 38, 29, 89, 64, 23]\ntarget = 38\n",
            "\ndef find_indices(elements):\n    indices = tf.range(len(elements))\n    return indices\n"
        ],
        "target-program": "tf.cast(tf.argmax(tf.cast(tf.equal(in1, tf.expand_dims(in2, 1)), tf.int32), axis=1), tf.int32)",
        "description": "find the indices of all elements",
        "tf_operators": {
            "tf.where": 7,
            "tf.constant": 7,
            "tf.equal": 6,
            "tf.range": 2,
            "tf.gather": 1
        },
        "coverage_percentage": 20.0,
        "total_in_target": 5,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_49",
        "completions": [
            "\ntensor = tf.constant([[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], \n                      [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], \n                      [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]])\n\nscalars = tf.constant([2.0, 0.5, 1.0])\n\nscalars_reshaped = tf.reshape(scalars, (-1, 1, 1, 1))\n\nresult = tf.multiply(tensor, scalars_reshaped)\n",
            "\ninput_data = [[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]]\nscalars = [2.0, 0.5, 1.0]\n\ninput_tensor = tf.constant(input_data)\nscalars_tensor = tf.constant(scalars)\n\noutput_tensor = tf.multiply(input_tensor, scalars_tensor)\n\n",
            "\ntensors = tf.constant([[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]])\nscalars = tf.constant([2.0, 0.5, 1.0])\n\nscalars_reshaped = tf.reshape(scalars, (-1, 1, 1, 1))\n\nresult = tf.multiply(tensors, scalars_reshaped)\n\n",
            "\ndef multiply_tensors_by_scalars(tensors, scalars):\n    tensor_list = []\n    for i in range(len(tensors)):\n        tensor = tf.constant(tensors[i], dtype=tf.float32)\n        scalar = tf.constant(scalars[i], dtype=tf.float32)\n        multiplied_tensor = tf.multiply(tensor, scalar)\n        tensor_list.append(multiplied_tensor)\n    return tensor_list\n\ntensors = [[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]]\nscalars = [2.0, 0.5, 1.0]\nresult = multiply_tensors_by_scalars(tensors, scalars)\nfor tensor in result:\n    print(tensor.numpy())\n",
            "\ndef multiply_tensors_by_scalars(tensors, scalars):\n    # Reshape scalars to match the dimensions of tensors\n    scalars = tf.reshape(scalars, (-1, 1, 1, 1))\n    # Multiply tensors by scalars\n    result = tf.multiply(tensors, scalars)\n    return result\n",
            "\ntensor_4d = tf.constant([[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]])\ntensor_1d = tf.constant([2.0, 0.5, 1.0])\n\nresult = tf.multiply(tensor_4d, tensor_1d)\n\n",
            "\ndef multiply_tensors_by_scalars(tensors, scalars):\n    tensors = tf.convert_to_tensor(tensors)\n    scalars = tf.convert_to_tensor(scalars)\n    return tf.math.multiply(tensors, scalars)\n\ntensors = [[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]]\nscalars = [2.0, 0.5, 1.0]\n",
            "\ndef multiply_tensors(tensor1, tensor2):\n    tensor1 = tf.constant(tensor1, dtype=tf.float32)\n    tensor2 = tf.constant(tensor2, dtype=tf.float32)\n    result = tf.multiply(tensor1, tensor2)\n    return result\n",
            "\ndef multiply_tensors_by_scalars(tensors, scalars):\n    result = []\n    for i in range(len(tensors)):\n        result.append(tf.multiply(tensors[i], scalars[i]))\n    return result\n\ntensors = [[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]]\nscalars = [2.0, 0.5, 1.0]\n",
            "\ndef multiply_tensors_by_scalars(tensors, scalars):\n    result = []\n    for tensor, scalar in zip(tensors, scalars):\n        result.append(tf.multiply(tensor, scalar))\n    return result\n\ntensors = [[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]]\nscalars = [2.0, 0.5, 1.0]\n"
        ],
        "target-program": "tf.transpose(tf.multiply(in2, tf.transpose(in1)))",
        "description": "multiply tensors by scalars in a batched way",
        "tf_operators": {
            "tf.constant": 6,
            "tf.reshape": 3,
            "tf.multiply": 9,
            "tf.float32": 2,
            "tf.math.multiply": 1,
            "tf.convert_to_tensor": 1
        },
        "coverage_percentage": 50.0,
        "total_in_target": 2,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_50",
        "completions": [
            "\ndef create_binary_matrix(index, size):\n    return tf.one_hot(index, size)\n\nindex = 5\nsize = 6\nresult = create_binary_matrix(index, size)\n",
            "\ndef create_binary_matrix(index, size):\n    return tf.one_hot(indices=index, depth=size)\n\n",
            "\ndef create_binary_matrix(index):\n    return tf.one_hot(index, 6)\n\noutput = create_binary_matrix(5)\n",
            "\ndef create_binary_matrix(index, size):\n    return tf.one_hot(index, size).numpy().tolist()\n",
            "\ndef create_binary_matrix(index):\n    return tf.one_hot(indices=index, depth=6, on_value=1, off_value=0).numpy()\n",
            "\ndef create_binary_matrix(column, total_columns):\n    return tf.one_hot(indices=column, depth=total_columns)\n\n",
            "\nindex = 5\n\nzeros = tf.zeros([index+1], tf.int32)\n\nvar = tf.Variable(zeros)\n\nupdate = tf.scatter_update(var, index, 1)\n\ninit = tf.global_variables_initializer()\n\nwith tf.Session() as sess:\n    sess.run(init)\n    sess.run(update)\n    print(sess.run(var))\n",
            "\ndef set_one(index):\n    return tf.one_hot(index, 6)\n",
            "\ndef create_binary_matrix(index):\n    return tf.one_hot(index, 6)\n\n",
            "\ndef binary_matrix(column):\n    return tf.one_hot(column, 6)\n"
        ],
        "target-program": "tf.cast(tf.one_hot(tf.fill((in1,), in3), in2), tf.int32)",
        "description": "create a binary matrix where a specified column is set to one",
        "tf_operators": {
            "tf.one_hot": 9,
            "tf.global_variables_initializer": 1,
            "tf.int32": 1,
            "tf.zeros": 1,
            "tf.Variable": 1,
            "tf.scatter_update": 1,
            "tf.Session": 1
        },
        "coverage_percentage": 50.0,
        "total_in_target": 4,
        "total_covered": 2
    }
]