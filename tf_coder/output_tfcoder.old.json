[
    {
        "task_id": "google_01",
        "completions": [
            "\ndef convert_to_pairs(tensor):\n    return tf.reshape(tensor, (-1, 2))\n\ntensor = tf.constant([0, 0, 0, 1, 3, 3])\npairs = convert_to_pairs(tensor)\n",
            "\ndef convert_indices(indices):\n    indices = tf.constant(indices)\n    second_elements = tf.where(indices)\n    first_elements = tf.subtract(second_elements, 1)\n    index_pairs = tf.stack([first_elements, second_elements], axis=-1)\n    return index_pairs\n\nindices = [0, 0, 0, 1, 3, 3]\n",
            "\ntensor = tf.constant([0, 0, 0, 1, 3, 3])\n\nsorted_tensor = tf.sort(tensor)\nduplicates = tf.equal(sorted_tensor, tf.roll(sorted_tensor, shift=1))\n\nindices = tf.where(duplicates)\n\npairs = tf.gather(tensor, indices)\n\npairs = tf.squeeze(pairs)\n\n",
            "\ndef index_to_pairs(indices):\n    tensor = tf.constant(indices)\n    unique_indices, counts = tf.unique_with_counts(tensor)\n    pairs = tf.transpose(tf.stack([unique_indices, counts]))\n    return pairs\n",
            "\ndef convert_index_to_pairs(index_tensor):\n    unique, counts = tf.unique_with_counts(index_tensor)\n    indices = tf.where(counts > 1)\n    pairs = tf.gather(unique, indices)\n    return pairs\n",
            "\ndef index_to_pairs(index_tensor):\n    unique_elements, _ = tf.unique_with_counts(index_tensor)\n    return tf.reshape(unique_elements, (-1, 2))\n",
            "\ndef index_to_pairs(index_tensor):\n    unique, counts = tf.unique_with_counts(index_tensor)\n    return tf.transpose(tf.stack([unique, counts]))\n\nindex_tensor = tf.constant([0, 0, 0, 1, 3, 3])\n",
            "\ndef tensor_to_pairs(tensor):\n    return tf.reshape(tensor, [-1, 2])\n\ntensor = tf.constant([0, 0, 0, 1, 3, 3])\n",
            "\ndef convert_indices(input_tensor):\n    condition = tf.equal(input_tensor, input_tensor)\n    output = tf.where(condition)\n    return output\n",
            "\ndef index_to_pairs(indices):\n    indices = tf.constant(indices)\n    unique_indices, counts = tf.unique_with_counts(indices)\n    row_indices = tf.expand_dims(unique_indices, -1)\n    col_indices = tf.expand_dims(tf.range(tf.size(unique_indices)), -1)\n    pairs = tf.stack([row_indices, col_indices], axis=-1)\n    return pairs\n\nindices = [0, 0, 0, 1, 3, 3]\npairs = index_to_pairs(indices)\n"
        ],
        "target-program": "tf.cast(tf.where(tf.sequence_mask(tf.math.bincount(in1))), tf.int32)",
        "description": "Convert index tensor into pairs for SparseTensor indexing",
        "tf_operators": {
            "tf.constant": 7,
            "tf.reshape": 3,
            "tf.stack": 4,
            "tf.where": 4,
            "tf.subtract": 1,
            "tf.squeeze": 1,
            "tf.gather": 2,
            "tf.roll": 1,
            "tf.sort": 1,
            "tf.equal": 2,
            "tf.unique_with_counts": 5,
            "tf.transpose": 2,
            "tf.expand_dims": 1,
            "tf.range": 1,
            "tf.size": 1
        },
        "coverage_percentage": 20.0,
        "total_in_target": 5,
        "total_covered": 1
    },
    {
        "task_id": "google_02",
        "completions": [
            "\nx = tf.constant([[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]])\n\nrow_sum = tf.reshape(tf.reduce_sum(x, axis=1), (-1, 1))\n\nresult = tf.divide(x, row_sum)\n\n",
            "\ndata = [[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]]\n\ntensor = tf.constant(data)\n\nrow_sums = tf.reduce_sum(tensor, axis=1)\n\nrow_sums = tf.reshape(row_sums, [-1, 1])\n\noutput = tf.divide(tensor, row_sums)\n\n",
            "\ninput_tensor = tf.constant([[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]])\n\nrow_sums = tf.reduce_sum(input_tensor, axis=1, keepdims=True)\n\noutput_tensor = tf.divide(input_tensor, row_sums)\n\n",
            "\nlst = [[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]]\n\ntensor = tf.constant(lst)\n\nrow_sum = tf.reduce_sum(tensor, axis=1)\n\nrow_sum_expanded = tf.expand_dims(row_sum, axis=1)\n\noutput = tf.divide(tensor, row_sum_expanded)\n\n",
            "\ndata = tf.constant([[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]])\n\nrow_sums = tf.reduce_sum(data, axis=1)\n\nrow_sums = tf.reshape(row_sums, [-1, 1])\n\nnormalized_data = tf.divide(data, row_sums)\n\n",
            "\ndata = [[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]]\n\ndata_tf = tf.constant(data)\n\nrow_sum = tf.reduce_sum(data_tf, axis=1)\n\nrow_sum_reshaped = tf.reshape(row_sum, [-1, 1])\n\noutput = tf.divide(data_tf, row_sum_reshaped)\n\n",
            "\nmatrix = tf.constant([[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]])\n\nrow_sums = tf.reduce_sum(matrix, axis=1)\n\nrow_sums = tf.expand_dims(row_sums, axis=1)\n\nnormalized_matrix = tf.divide(matrix, row_sums)\n\n",
            "\ndef normalize_rows(input):\n    input_tensor = tf.constant(input)\n    row_sums = tf.reduce_sum(input_tensor, axis=1)\n    row_sums_reshaped = tf.reshape(row_sums, [-1, 1])\n    output = tf.divide(input_tensor, row_sums_reshaped)\n    return output\n\ninput = [[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]]\n",
            "\ndata = [[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]]\n\ntensor = tf.constant(data)\n\nrow_sums = tf.reduce_sum(tensor, axis=1)\n\nrow_sums_reshaped = tf.reshape(row_sums, [-1, 1])\n\nresult = tf.divide(tensor, row_sums_reshaped)\n\n",
            "\ndata = [[0.0, 1.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 1.0]]\n\ndata_tensor = tf.constant(data)\n\nrow_sum = tf.reduce_sum(data_tensor, axis=1)\n\nrow_sum_expanded = tf.expand_dims(row_sum, axis=1)\n\noutput = tf.divide(data_tensor, row_sum_expanded)\n\n"
        ],
        "target-program": "tf.divide(in1, tf.expand_dims(tf.reduce_sum(in1, axis=1), 1))",
        "description": "Divide each row by the sum of that row",
        "tf_operators": {
            "tf.reduce_sum": 10,
            "tf.divide": 10,
            "tf.reshape": 6,
            "tf.constant": 10,
            "tf.expand_dims": 3
        },
        "coverage_percentage": 100.0,
        "total_in_target": 3,
        "total_covered": 3
    },
    {
        "task_id": "google_03",
        "completions": [
            "def slice_sparse_tensor_8(sparse_tensor):\n    is_first_dim = tf.equal(sparse_tensor.indices[:, 0], 0)\n    new_indices = tf.boolean_mask(sparse_tensor.indices, is_first_dim)\n    new_values = tf.boolean_mask(sparse_tensor.values, is_first_dim)\n    new_shape = [1, sparse_tensor.dense_shape[1], sparse_tensor.dense_shape[2]]\n    return tf.SparseTensor(indices=new_indices, values=new_values, dense_shape=tf.constant(new_shape))",
            "def slice_sparse_tensor_7(sparse_tensor):\n    mask = tf.squeeze(tf.where(tf.equal(sparse_tensor.indices[:, 0], 0)), axis=1)\n    new_indices = tf.gather(sparse_tensor.indices, mask)\n    new_values = tf.gather(sparse_tensor.values, mask)\n    new_shape = tf.concat([[1], sparse_tensor.dense_shape[1:]], 0)\n    return tf.SparseTensor(indices=new_indices, values=new_values, dense_shape=new_shape)",
            "\ndef slice_first_dimension(sparse_tensor):\n    return tf.sparse.slice(sparse_tensor, start=[0, 0], size=[1, -1])\n",
            "\nindices = tf.constant([[0, 0], [1, 2]], dtype=tf.int64)\nvalues = tf.constant([1, 2], dtype=tf.int32)\ndense_shape = tf.constant([3, 4], dtype=tf.int64)\nsparse_tensor = tf.SparseTensor(indices, values, dense_shape)\n\nsliced_sparse_tensor = tf.sparse.slice(sparse_tensor, start=[0, 0], size=[1, -1])\n",
            "\nindices = tf.constant([[0, 0], [1, 2]])\nvalues = tf.constant([1, 2], dtype=tf.int32)\ndense_shape = tf.constant([3, 4])\nsparse_tensor = tf.SparseTensor(indices, values, dense_shape)\n\nstart = tf.constant([0, 0], dtype=tf.int64)\nsize = tf.constant([1, -1], dtype=tf.int64)\nsliced = tf.sparse.slice(sparse_tensor, start, size)\n",
            "\ndef slice_first_dim(char):\n    # Convert the character to a SparseTensor\n    indices = [[0, 0]]\n    values = [char]\n    dense_shape = [1, 1]\n    sparse_tensor = tf.SparseTensor(indices, values, dense_shape)\n\n    # Slice the first dimension\n    sliced = tf.sparse.slice(sparse_tensor, start=[0, 0], size=[1, 1])\n\n    # Convert back to dense and return the first element\n    return tf.sparse.to_dense(sliced)[0][0].numpy().decode()\n",
            "def slice_sparse_tensor_9(sparse_tensor):\n    mask = sparse_tensor.indices[:, 0] < 1\n    filtered_indices = tf.boolean_mask(sparse_tensor.indices, mask)\n    filtered_values = tf.boolean_mask(sparse_tensor.values, mask)\n    new_shape = tf.concat([[1], sparse_tensor.dense_shape[1:]], axis=0)\n    return tf.SparseTensor(indices=filtered_indices, values=filtered_values, dense_shape=new_shape)",
            "def slice_sparse_tensor_5(sparse_tensor):\n    condition = tf.equal(sparse_tensor.indices[:, 0], 0)\n    new_indices = tf.ragged.boolean_mask(sparse_tensor.indices, condition).to_tensor()\n    new_values = tf.boolean_mask(sparse_tensor.values, condition)\n    new_shape = tf.concat([[1], sparse_tensor.dense_shape[1:]], axis=0)\n    return tf.SparseTensor(indices=new_indices, values=new_values, dense_shape=new_shape)",
            "def slice_sparse_tensor_10(sparse_tensor):\n    mask = sparse_tensor.indices[:, 0] == 0\n    new_indices = sparse_tensor.indices[mask]\n    new_values = sparse_tensor.values[mask]\n    new_shape = tf.concat([[1], sparse_tensor.dense_shape[1:]], axis=0)\n    return tf.SparseTensor(indices=new_indices, values=new_values, dense_shape=new_shape)\n    output = tf.sparse.slice(sparse_tensor, start=[0], size=[1])\n"
        ],
        "target-program": "tf.divide(in1, tf.expand_dims(tf.reduce_sum(in1, axis=1), 1))",
        "description": "Slice the first dimension of a SparseTensor",
        "tf_operators": {
            "tf.sparse.slice": 7,
            "tf.constant": 2,
            "tf.int64": 2,
            "tf.SparseTensor": 3,
            "tf.int32": 2,
            "tf.sparse.to_dense": 1
        },
        "coverage_percentage": 0.0,
        "total_in_target": 3,
        "total_covered": 0
    },
    {
        "task_id": "google_04",
        "completions": [
            "\ninput_list = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\ntensor = tf.constant(input_list)\nreshaped_tensor = tf.reshape(tensor, [4, 3, 2])\n",
            "\ninput_list = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\n\ninput_tensor = tf.constant(input_list)\n\noutput_tensor = tf.reshape(input_tensor, [6, 4, 2])\n\n",
            "\ntensor = tf.constant([111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432])\n\nreshaped_tensor = tf.reshape(tensor, (6, 4, 2))\n\n",
            "\nlst = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\n\ntensor = tf.constant(lst)\n\nreshaped_tensor = tf.reshape(tensor, [3, 4, 2])\n\n",
            "\narr = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\n\ntensor = tf.constant(arr)\n\nreshaped_tensor = tf.reshape(tensor, [4, 3, 2])\n\n",
            "\nflat_array = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\n\ntensor = tf.constant(flat_array)\n\nreshaped_tensor = tf.reshape(tensor, [4, 3, 2])\n\n",
            "\narray = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\n\ntensor = tf.reshape(array, (-1, 3, 2))\n\n",
            "\nlst = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\n\ntensor = tf.constant(lst)\n\nreshaped_tensor = tf.reshape(tensor, (3, 3, 2))\n\n",
            "\ninput_array = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\n\ninput_tensor = tf.constant(input_array)\n\noutput_tensor = tf.reshape(input_tensor, (4, 3, 2))\n\n",
            "\nlst = [111, 112, 121, 122, 131, 132, 211, 212, 221, 222, 231, 232, 311, 312, 321, 322, 331, 332, 411, 412, 421, 422, 431, 432]\n\ntensor = tf.constant(lst)\n\nreshaped_tensor = tf.reshape(tensor, [4, 3, 2])\n\n"
        ],
        "target-program": "tf.reshape(in1, shape=(4, 3, 2))",
        "description": "Reshape a flat array into a rank 3 tensor",
        "tf_operators": {
            "tf.reshape": 10,
            "tf.constant": 9
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "google_05",
        "completions": [
            "\ninput = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\n\noutput = tf.repeat(input, repeats=6, axis=0)\n\n",
            "\ninput_tensor = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\n\noutput_tensor = tf.repeat(input_tensor, repeats=6, axis=0)\n\n",
            "\ninput_data = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\n\noutput_data = tf.repeat(input_data, repeats=6, axis=0)\n\n",
            "\ninput_tensor = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\noutput_tensor = tf.repeat(input_tensor, repeats=6, axis=0)\n\n",
            "\ninput_data = [[1, 2, 3, 4], [5, 6, 7, 8]]\n\ninput_tensor = tf.constant(input_data)\n\noutput = tf.repeat(input_tensor, repeats=6, axis=0)\n\n",
            "\ninput = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\noutput = tf.repeat(input, repeats=6, axis=0)\n",
            "\ninput_data = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\noutput = tf.repeat(input_data, repeats=6, axis=0)\n",
            "\ninput = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\noutput = tf.repeat(input, repeats=6, axis=0)\n\n",
            "\ndef repeat_entries(input):\n    return tf.repeat(input, repeats=6, axis=0)\n\ninput = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\noutput = repeat_entries(input)\n",
            "\ninput_data = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\n\noutput_data = tf.repeat(input_data, repeats=6, axis=0)\n\n"
        ],
        "target-program": "tf.tile(tf.expand_dims(in1, 1), (1, 6, 1))",
        "description": "Repeat each input entry 6 times",
        "tf_operators": {
            "tf.repeat": 10,
            "tf.constant": 10
        },
        "coverage_percentage": 0.0,
        "total_in_target": 2,
        "total_covered": 0
    },
    {
        "task_id": "google_06",
        "completions": [
            "\ndef max_group_element(input_list):\n    bincount = tf.math.bincount(input_list)\n    return tf.math.argmax(bincount).numpy()\n\n",
            "\ndef max_from_group(elements):\n    counts = tf.math.bincount(elements)\n    return tf.argmax(counts)\n\nelements = tf.constant([0, 1, 1, 2, 3, 3, 3, 3])\n\nelements = tf.constant([1, 3, 4, 5, 10, 8, 9, 4])\n",
            "\ndef max_from_each_group(elements):\n    # create a list of segment ids\n    segment_ids = []\n    current_id = 0\n    for i in range(len(elements)):\n        segment_ids.append(current_id)\n        if i + 1 < len(elements) and elements[i] != elements[i + 1]:\n            current_id += 1\n\n    # convert the elements and segment_ids to tensors\n    elements = tf.constant(elements)\n    segment_ids = tf.constant(segment_ids)\n\n    # use tf.math.segment_max to find the max of each group\n    return tf.math.segment_max(elements, segment_ids)\n",
            "\ndef max_in_segments(data, segment_ids):\n    return tf.math.segment_max(data, segment_ids)\n",
            "\ndef max_in_group(elements):\n    counts = tf.math.bincount(elements)\n    max_group = tf.argmax(counts)\n    return max_group.numpy()\n\n",
            "\ndef min_of_maxes(input):\n    # assuming segment_ids are 0, 1, 2, ..., n for n+1 unique elements in the array\n    segment_ids = tf.range(tf.reduce_max(input) + 1)\n    max_values = tf.math.segment_max(input, segment_ids)\n    return tf.reduce_min(max_values)\n",
            "\ndef max_from_groups(input):\n    counts = tf.math.bincount(input)\n    return tf.argmax(counts).numpy()\n\n",
            "\ndef max_frequency(arr):\n    count = tf.math.bincount(arr)\n    max_freq = tf.reduce_max(count)\n    return max_freq\n\n",
            "\ndef max_from_each_group(data):\n    return tf.math.segment_max(data, data)\n",
            "\ndef max_from_each_group(elements):\n    tensor = tf.constant(elements)\n    _, counts = tf.unique_with_counts(tensor)\n    max_count = tf.reduce_max(counts)\n    return max_count\n\n"
        ],
        "target-program": "tf.math.segment_max(in2, in1)",
        "description": "Take the max from each group of elements",
        "tf_operators": {
            "tf.math.bincount": 5,
            "tf.math.argmax": 1,
            "tf.constant": 3,
            "tf.argmax": 3,
            "tf.math.segment_max": 4,
            "tf.reduce_min": 1,
            "tf.range": 1,
            "tf.reduce_max": 3,
            "tf.unique_with_counts": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "google_07",
        "completions": [
            "\ndef argmax_of_elements(input):\n    tensor = tf.constant(input)\n    return tf.argmax(tensor).numpy()\n\n",
            "\ndef argmax_group(input):\n    return tf.argmax(input).numpy()\n\n",
            "\ndef max_index_of_groups(elements, group_size):\n    # Convert the list to a tensor\n    tensor = tf.constant(elements, dtype=tf.int32)\n\n    # Reshape the tensor to a 2D tensor where each row represents a group\n    tensor = tf.reshape(tensor, [-1, group_size])\n\n    # Use tf.argmax to find the maximum index in each group\n    indices = tf.argmax(tensor, axis=1)\n\n    # Return the maximum index\n    return tf.reduce_max(indices)\n",
            "\ndef find_argmax(input_list):\n    tensor = tf.constant(input_list)\n    max_index = tf.argmax(tensor)\n    return max_index.numpy()\n\n",
            "\ndef get_argmax_of_groups(elements):\n    tensor = tf.constant(elements)\n    reshaped_tensor = tf.reshape(tensor, (-1, 4))\n    argmax_indices = tf.argmax(reshaped_tensor, axis=1)\n    return tf.reduce_max(argmax_indices)\n\nelements = [0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 4, 4, 5, 5]\n\nelements = [4, 1, 8, 2, 5, 7, 9, 3, 7, 3, 1, 42, 1, 2, 4, 0]\n",
            "\ndef argmax_of_elements(input):\n    tensor = tf.constant(input)\n    return tf.math.argmax(tensor).numpy()\n",
            "\ndef get_mode(array):\n    counts = tf.math.bincount(array)\n    mode = tf.argmax(counts)\n    return mode\n\narray = tf.constant([0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 4, 4, 5, 5])\n\narray = tf.constant([4, 1, 8, 2, 5, 7, 9, 3, 7, 3, 1, 42, 1, 2, 4, 0])\n",
            "\ndef argmax_of_elements(elements):\n    tensor = tf.constant(elements)\n    return tf.argmax(tensor).numpy()\n\n",
            "\ndef find_argmax(input_list):\n    tensor = tf.constant(input_list)\n    max_index = tf.argmax(tensor)\n    return max_index.numpy()\n\n",
            "\ndef get_argmax_of_groups(data, group_size):\n    # Convert the input list to a TensorFlow tensor\n    data_tensor = tf.constant(data)\n\n    # Compute the number of groups\n    num_groups = len(data) // group_size\n\n    # Create a tensor of segment IDs\n    segment_ids = tf.repeat(tf.range(num_groups), group_size)\n\n    # Compute the maximum value in each segment\n    segment_max = tf.math.segment_max(data_tensor, segment_ids)\n\n    # Compute the index of the maximum value in each segment\n    argmax_indices = tf.argmax(segment_max)\n\n    return argmax_indices\n"
        ],
        "target-program": "tf.cast(tf.argmax((tf.sequence_mask(tf.cumsum(tf.math.bincount(in1)), dtype=tf.int32) - tf.sequence_mask(tf.cumsum(tf.math.bincount(in1), exclusive=True), dtype=tf.int32, maxlen=in1.shape[0])) * in2, axis=1), tf.int32) - tf.cumsum(tf.math.bincount(in1), exclusive=True)",
        "description": "Take the argmax of each group of elements",
        "tf_operators": {
            "tf.argmax": 9,
            "tf.constant": 9,
            "tf.reduce_max": 2,
            "tf.reshape": 2,
            "tf.int32": 1,
            "tf.math.argmax": 1,
            "tf.math.bincount": 1,
            "tf.math.segment_max": 1,
            "tf.range": 1,
            "tf.repeat": 1
        },
        "coverage_percentage": 50.0,
        "total_in_target": 6,
        "total_covered": 3
    },
    {
        "task_id": "google_08",
        "completions": [
            "\nlengths = tf.constant([3, 4, 2, 1])\nmask = tf.sequence_mask(lengths, maxlen=5)\nmask = tf.cast(mask, dtype=tf.int32)\nmask = tf.reshape(mask, [-1])\n",
            "\nlengths = tf.constant([3, 4, 2, 1])\nmask = tf.sequence_mask(lengths)\n",
            "\ndef create_mask(lengths):\n    sequence = tf.range(tf.reduce_max(lengths))\n    mask = tf.less(sequence, lengths)\n    return tf.cast(mask, tf.int32)\n\nlengths = tf.constant([3, 4, 2, 1])\n",
            "\ndef create_mask(lengths):\n    max_length = tf.reduce_max(lengths)\n    sequence = tf.range(max_length)\n    mask = tf.less(sequence, lengths)\n    return tf.cast(mask, tf.int32)\n",
            "\ndef create_mask(lengths):\n    max_length = tf.reduce_max(lengths)\n    mask = tf.less(tf.range(max_length), lengths)\n    mask = tf.cast(mask, tf.int32)\n    return mask\n\nlengths = tf.constant([3, 4, 2, 1])\nmask = create_mask(lengths)\n",
            "\ndef create_mask(lengths):\n    mask = tf.sequence_mask(lengths)\n    return tf.cast(mask, dtype=tf.int32)\n\nlengths = [3, 4, 2, 1]\n",
            "\nlengths = [3, 4, 2, 1]\nmask = tf.sequence_mask(lengths)\n",
            "\ndef create_mask(lengths):\n    mask = tf.sequence_mask(lengths, maxlen=tf.reduce_max(lengths))\n    mask = tf.reshape(mask, [-1])\n    return mask\n\nlengths = tf.constant([3, 4, 2, 1])\nmask = create_mask(lengths)\n",
            "\ndef create_mask(lengths):\n    total_length = tf.reduce_sum(lengths)\n    mask = tf.sequence_mask(lengths[0], total_length)\n    return tf.cast(mask, dtype=tf.int32)\n\nlengths = tf.constant([3, 4, 2, 1])\n",
            "\nsequence_lengths = tf.constant([3, 4, 2, 1])\nmask = tf.sequence_mask(sequence_lengths, 5)\nmask = tf.cast(mask, tf.int32)\nmask = tf.reshape(mask, [-1])\n\n"
        ],
        "target-program": "tf.cast(tf.greater(tf.expand_dims(in1, 1), tf.range(5)), tf.int32)",
        "description": "create a mask for sequences of the given lengths",
        "tf_operators": {
            "tf.sequence_mask": 7,
            "tf.reshape": 3,
            "tf.cast": 7,
            "tf.int32": 7,
            "tf.constant": 7,
            "tf.reduce_max": 4,
            "tf.range": 3,
            "tf.less": 3,
            "tf.reduce_sum": 1
        },
        "coverage_percentage": 60.0,
        "total_in_target": 5,
        "total_covered": 3
    },
    {
        "task_id": "google_09",
        "completions": [
            "\ndef sort_segments(input):\n    segments = tf.constant(input)\n    segment_ids = tf.range(tf.size(segments))\n    sums = tf.math.unsorted_segment_sum(segments, segment_ids, tf.size(segments))\n    sorted_sums = tf.argsort(sums)\n    return sums[sorted_sums[1]]\n",
            "\ndef count_segments(lst):\n    tensor = tf.constant(lst)\n    bincount = tf.math.bincount(tensor)\n    return tf.reduce_sum(bincount)\n\n",
            "\ndef max_segment_sum(arr):\n    arr = tf.constant(arr)\n    segment_ids = tf.argsort(arr)\n    segment_sum = tf.math.segment_sum(arr, segment_ids)\n    max_value = tf.reduce_max(segment_sum)\n    return max_value.numpy()\n\n",
            "\ndef sort_segments(input):\n    data = tf.ones_like(input)\n    segment_sum = tf.math.segment_sum(data, input)\n    return tf.reduce_max(segment_sum)\n",
            "\ndef max_segment_sum(data):\n    # Compute the sum of segments\n    segment_sums = tf.math.segment_sum(data, data)\n    # Find the maximum value\n    max_sum = tf.reduce_max(segment_sums)\n    return max_sum\n\n",
            "\ndef sort_segments(input):\n  sorted_tensor = tf.sort(input)\n  middle_index = len(input) // 2\n  return sorted_tensor[middle_index]\n\ninput = tf.constant([10, 20, 30, 14, 15, 26])\n",
            "\ndef sort_segments(input):\n    # Define the segment ids\n    segment_ids = tf.constant([0, 0, 0, 1, 1, 2], dtype=tf.int32)\n    \n    # Calculate the sum of the segments\n    segment_sums = tf.math.unsorted_segment_sum(input, segment_ids, 3)\n    \n    # Sort the segment sums\n    sorted_sums = tf.sort(segment_sums)\n    \n    # Return the second element of the sorted array\n    return sorted_sums[1]\n\ninput1 = tf.constant([1, 1, 1, 0, 0, 2], dtype=tf.int32)\n\ninput2 = tf.constant([10, 20, 30, 14, 15, 26], dtype=tf.int32)\n",
            "\ndef sort_segments(input):\n    segment_sums = tf.math.segment_sum(input, input)\n    sorted_sums = tf.sort(segment_sums)\n    return tf.gather(sorted_sums, 1)\n",
            "\ndef sort_and_get_middle_value(input_list):\n    sorted_list = tf.sort(input_list)\n    middle_index = tf.shape(sorted_list)[0] // 2\n    middle_value = tf.gather(sorted_list, middle_index)\n    return middle_value.numpy()\n\n",
            "\ndef sort_segments(arr):\n  arr = tf.constant(arr)\n  _, idx = tf.unique(arr)\n  segment_sums = tf.math.unsorted_segment_sum(arr, idx, tf.size(tf.unique(arr).y))\n  sorted_sums = tf.sort(segment_sums)\n  return sorted_sums[1].numpy()\n\n"
        ],
        "target-program": "tf.gather(in2, tf.argsort(in1, stable=True))",
        "description": "sort the segments",
        "tf_operators": {
            "tf.math.unsorted_segment_sum": 3,
            "tf.range": 1,
            "tf.size": 2,
            "tf.argsort": 2,
            "tf.constant": 6,
            "tf.reduce_sum": 1,
            "tf.math.bincount": 1,
            "tf.math.segment_sum": 4,
            "tf.reduce_max": 3,
            "tf.ones_like": 1,
            "tf.sort": 5,
            "tf.int32": 1,
            "tf.gather": 2,
            "tf.shape": 1,
            "tf.unique": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 2,
        "total_covered": 2
    },
    {
        "task_id": "google_10",
        "completions": [
            "\ndef gather_elements(list1, list2):\n    tensor1 = tf.constant(list1)\n    tensor2 = tf.constant(list2)\n    mask = tf.equal(tensor2, 1)\n    masked_tensor = tf.boolean_mask(tensor1, mask)\n    return tf.reduce_min(masked_tensor)\n",
            "\ndef gather_elements(data, mask):\n    data_tensor = tf.constant(data)\n    mask_tensor = tf.constant(mask)\n    mask_bool = tf.cast(mask_tensor, tf.bool)\n    result = tf.boolean_mask(data_tensor, mask_bool)\n    return result.numpy()\n\n",
            "\ndef gather_marked_elements(list1, list2):\n    tensor1 = tf.constant(list1)\n    tensor2 = tf.constant(list2, dtype=bool)\n    masked_tensor = tf.boolean_mask(tensor1, tensor2)\n    result = tf.gather(masked_tensor, 0)\n    return result\n\n",
            "\ndef gather_marked_elements(input_list):\n    tensor = tf.constant(input_list)\n    mask = tf.not_equal(tensor, 0)\n    non_zero_elements = tf.boolean_mask(tensor, mask)\n    return tf.gather(non_zero_elements, 0)\n\n",
            "\nlist = tf.constant([10, 20, 0, 40, 0, 30])\n\nmask = tf.constant([1, 1, 0, 1, 0, 1])\n\nmasked_list = tf.boolean_mask(list, mask)\n\noutput = tf.gather(masked_list, tf.where(masked_list > 0))\n\n",
            "\ndef gather_elements(numbers, mask):\n    numbers_tensor = tf.constant(numbers)\n    mask_tensor = tf.constant(mask, dtype=bool)\n    gathered_elements = tf.boolean_mask(numbers_tensor, mask_tensor)\n    return gathered_elements\n\nnumbers = [10, 20, 0, 40, 0, 30]\nmask = [1, 1, 0, 1, 0, 1]\nresult = gather_elements(numbers, mask)\n\nnumbers = [10, 20, 0, 40, 0, 30]\nmask = [1, 0, 0, 0, 0, 0]\nresult = gather_elements(numbers, mask)\n",
            "\ndef gather_marked_elements(values, mask):\n    values_tensor = tf.constant(values)\n    mask_tensor = tf.constant(mask, dtype=tf.bool)\n    return tf.boolean_mask(values_tensor, mask_tensor)\n",
            "\ndef gather_elements(input_list):\n    tensor = tf.constant(input_list)\n    marked_indices = [0, 3]  # Indices of the marked elements\n    gathered_elements = tf.gather(tensor, marked_indices)\n    return gathered_elements.numpy()\n\n",
            "\ndef gather_elements(data, mask):\n    data = tf.constant(data)\n    mask = tf.constant(mask)\n    mask = tf.equal(mask, 1)\n    gathered = tf.boolean_mask(data, mask)\n    return gathered.numpy()\n\n",
            "\ndef gather_marked_elements(input_list, marker_list):\n    # Create a Tensor from the input list\n    input_tensor = tf.constant(input_list)\n\n    # Create a boolean mask from the marker list\n    mask = tf.constant(marker_list, dtype=tf.bool)\n\n    # Gather the marked elements\n    gathered_elements = tf.boolean_mask(input_tensor, mask)\n\n    return gathered_elements.numpy()[0]  # Return the first element\n\n"
        ],
        "target-program": "tf.boolean_mask(in1, tf.cast(in2, tf.bool))",
        "description": "gather the marked elements",
        "tf_operators": {
            "tf.boolean_mask": 9,
            "tf.reduce_min": 1,
            "tf.equal": 2,
            "tf.constant": 10,
            "tf.bool": 3,
            "tf.cast": 1,
            "tf.gather": 4,
            "tf.not_equal": 1,
            "tf.where": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 3,
        "total_covered": 3
    },
    {
        "task_id": "google_11",
        "completions": [
            "\ndef count_elements_greater_than_zero(input):\n    tensor = tf.constant(input)\n    greater_than_zero = tf.greater(tensor, 0)\n    int_tensor = tf.cast(greater_than_zero, tf.int32)\n    count_per_row = tf.reduce_sum(int_tensor, axis=1)\n    total_count = tf.reduce_sum(count_per_row)\n    return total_count\n\ninput = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\n",
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\n\ntensor = tf.constant(data)\n\ngreater_than_zero = tf.math.greater(tensor, 0)\n\ncount = tf.math.count_nonzero(greater_than_zero, axis=1)\n\n",
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\n\ntensor = tf.constant(data)\n\ngreater_than_zero = tf.greater(tensor, 0)\n\ngreater_than_zero_int = tf.cast(greater_than_zero, tf.int32)\n\ncount = tf.reduce_sum(greater_than_zero_int, axis=1)\n\n",
            "\nlst = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\n\ntensor = tf.constant(lst)\n\nbool_tensor = tf.greater(tensor, 0)\n\nint_tensor = tf.cast(bool_tensor, tf.int32)\n\nrow_sums = tf.reduce_sum(int_tensor, axis=1)\n\ntotal_count = tf.reduce_sum(row_sums)\n\n",
            "\ndef count_greater_than_zero(input_tensor):\n  greater_than_zero = tf.math.greater(input_tensor, 0)\n  count = tf.math.count_nonzero(greater_than_zero, axis=1)\n  total_count = tf.reduce_sum(count)\n  return total_count\n\ninput_tensor = tf.constant([[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]])\noutput = count_greater_than_zero(input_tensor)\n",
            "\narray = tf.constant([[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]])\n\nmask = tf.greater(array, 0)\n\nmask_int = tf.cast(mask, tf.int32)\n\ncount = tf.reduce_sum(mask_int, axis=1)\n\n",
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\n\ntensor = tf.constant(data)\n\ngreater_than_zero = tf.math.greater(tensor, 0)\n\ncount = tf.math.count_nonzero(greater_than_zero, axis=1)\n",
            "\ndef count_elements_greater_than_zero(input_list):\n    tensor = tf.constant(input_list)\n    greater_than_zero = tf.greater(tensor, 0)\n    int_tensor = tf.cast(greater_than_zero, tf.int32)\n    count_per_row = tf.reduce_sum(int_tensor, axis=1)\n    total_count = tf.reduce_sum(count_per_row)\n    return total_count\n\ninput_list = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\n",
            "\ninput_list = [[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]]\n\ninput_tensor = tf.constant(input_list)\n\nboolean_mask = tf.greater(input_tensor, 0)\n\ninteger_mask = tf.cast(boolean_mask, tf.int32)\n\ncounts = tf.reduce_sum(integer_mask, axis=1)\n\n",
            "\ninput_tensor = tf.constant([[1.0, 0.3, -4.2, 0.0, 2.1, 0.4], [-0.1, 0.0, 1.4, -1.0, 0.4, 0.0], [0.1, 0.0, 0.7, -0.3, 0.5, -0.1], [1.4, 2.5, 0.3, 0.01, 0.0, 1.2]])\n\nbool_tensor = tf.greater(input_tensor, 0)\n\nint_tensor = tf.cast(bool_tensor, tf.int32)\n\nresult = tf.reduce_sum(int_tensor, axis=1)\n\n"
        ],
        "target-program": "tf.reduce_sum(tf.cast(tf.greater(in1, 0), tf.int32), axis=1)",
        "description": "count the number of elements greater than 0 in each row",
        "tf_operators": {
            "tf.cast": 7,
            "tf.int32": 7,
            "tf.reduce_sum": 8,
            "tf.greater": 7,
            "tf.constant": 10,
            "tf.math.greater": 3,
            "tf.math.count_nonzero": 3
        },
        "coverage_percentage": 100.0,
        "total_in_target": 4,
        "total_covered": 4
    },
    {
        "task_id": "google_12",
        "completions": [
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1], [-0.1, 0.0, 1.4, -1.0, 0.4], [0.1, 0.0, 0.7, -0.3, 0.5], [1.4, 2.5, 0.3, -0.1, 0.0]]\n\ntensor = tf.constant(data)\n\ngreater_than_zero = tf.greater(tensor, 0)\nless_than_one = tf.less(tensor, 1)\n\nbetween_zero_and_one = tf.logical_and(greater_than_zero, less_than_one)\n\nresult = tf.cast(between_zero_and_one, tf.int32)\n\n",
            "\ndef count_elements_between_zero_and_one(input_list):\n    tensor = tf.constant(input_list, dtype=tf.float32)\n    mask = tf.logical_and(tf.greater(tensor, 0), tf.less(tensor, 1))\n    mask_int = tf.cast(mask, tf.int32)\n    result = tf.reduce_sum(mask_int, axis=1)\n    return result\n\ninput_list = [[1.0, 0.3, -4.2, 0.0, 2.1], [-0.1, 0.0, 1.4, -1.0, 0.4], [0.1, 0.0, 0.7, -0.3, 0.5], [1.4, 2.5, 0.3, -0.1, 0.0]]\n",
            "\ndef identify_elements_between_0_and_1(input_list):\n    tensor = tf.constant(input_list, dtype=tf.float32)\n    mask = tf.logical_and(tf.greater(tensor, 0), tf.less(tensor, 1))\n    return tf.cast(mask, tf.int32)\n",
            "\ndef count_elements_between_0_and_1(lst):\n    tensor = tf.constant(lst)\n    mask = tf.logical_and(tensor > 0, tensor < 1)\n    mask_int = tf.cast(mask, tf.int32)\n    result = tf.reduce_sum(mask_int, axis=-1)\n    return result.numpy()\n\nlst = [[1.0, 0.3, -4.2, 0.0, 2.1], [-0.1, 0.0, 1.4, -1.0, 0.4], [0.1, 0.0, 0.7, -0.3, 0.5], [1.4, 2.5, 0.3, -0.1, 0.0]]\n",
            "\ninput_list = [[1.0, 0.3, -4.2, 0.0, 2.1], [-0.1, 0.0, 1.4, -1.0, 0.4], [0.1, 0.0, 0.7, -0.3, 0.5], [1.4, 2.5, 0.3, -0.1, 0.0]]\n\ninput_tensor = tf.constant(input_list)\n\ngreater_than_zero = tf.greater(input_tensor, 0)\nless_than_one = tf.less(input_tensor, 1)\n\nbetween_zero_and_one = tf.logical_and(greater_than_zero, less_than_one)\n\noutput = tf.cast(between_zero_and_one, tf.int32)\n\n",
            "\ndef identify_elements_between_0_and_1(input_data):\n    tensor = tf.constant(input_data)\n    greater_than_0 = tf.greater(tensor, 0)\n    less_than_1 = tf.less(tensor, 1)\n    between_0_and_1 = tf.logical_and(greater_than_0, less_than_1)\n    contains_element_between_0_and_1 = tf.reduce_any(between_0_and_1, axis=1)\n    return tf.cast(contains_element_between_0_and_1, tf.int32).numpy().tolist()\n",
            "\ninput = tf.constant([[1.0, 0.3, -4.2, 0.0, 2.1], [-0.1, 0.0, 1.4, -1.0, 0.4], [0.1, 0.0, 0.7, -0.3, 0.5], [1.4, 2.5, 0.3, -0.1, 0.0]])\n\nbool_mask = tf.logical_and(input > 0, input < 1)\n\nint_mask = tf.cast(bool_mask, tf.int32)\n\noutput = tf.reduce_sum(int_mask, axis=1)\n\n",
            "\ndata = [[1.0, 0.3, -4.2, 0.0, 2.1], [-0.1, 0.0, 1.4, -1.0, 0.4], [0.1, 0.0, 0.7, -0.3, 0.5], [1.4, 2.5, 0.3, -0.1, 0.0]]\n\ntensor = tf.constant(data)\n\nmask = tf.logical_and(tf.greater_equal(tensor, 0), tf.less(tensor, 1))\n\nresult = tf.cast(mask, tf.int32)\n\nresult = tf.reshape(result, [-1])\n\n",
            "\ninput_tensor = tf.constant([[1.0, 0.3, -4.2, 0.0, 2.1], [-0.1, 0.0, 1.4, -1.0, 0.4], [0.1, 0.0, 0.7, -0.3, 0.5], [1.4, 2.5, 0.3, -0.1, 0.0]])\n\nbetween_0_and_1 = tf.logical_and(input_tensor > 0, input_tensor < 1)\n\noutput_tensor = tf.cast(between_0_and_1, tf.int32)\n\n",
            "\ndata = tf.constant([[1.0, 0.3, -4.2, 0.0, 2.1], [-0.1, 0.0, 1.4, -1.0, 0.4], [0.1, 0.0, 0.7, -0.3, 0.5], [1.4, 2.5, 0.3, -0.1, 0.0]])\n\nresult = tf.cast(tf.logical_and(tf.greater_equal(data, 0), tf.less_equal(data, 1)), tf.int32)\n\n"
        ],
        "target-program": "tf.cast(tf.logical_and(0 <= in1, in1 <= 1), tf.int32)",
        "description": "identify elements between 0 and 1",
        "tf_operators": {
            "tf.logical_and": 10,
            "tf.cast": 10,
            "tf.int32": 10,
            "tf.greater": 5,
            "tf.less": 6,
            "tf.constant": 10,
            "tf.float32": 2,
            "tf.reduce_sum": 3,
            "tf.reduce_any": 1,
            "tf.reshape": 1,
            "tf.greater_equal": 2,
            "tf.less_equal": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 3,
        "total_covered": 3
    },
    {
        "task_id": "google_13",
        "completions": [
            "\ndef concat_sequences(sequences):\n    return tf.concat(sequences, axis=0)\n\nsequences = [[1, 2], [3, 4, 5]]\noutput = concat_sequences(sequences)\n",
            "\ndef concatenate_sequences(input):\n    return tf.concat(input, axis=0)\n",
            "\ndef concatenate_sequences(sequences):\n    return tf.concat(sequences, axis=0)\n\n",
            "\ndef concat_sequences(input_sequences):\n    return tf.concat(input_sequences, axis=0)\n\ninput_sequences = [[1, 2], [10, 20]]\n\ninput_sequences = [[3, 4, 5], [30, 40, 50]]\n",
            "\ndef concatenate_sequences(seq1, seq2):\n    tensor1 = tf.constant(seq1)\n    tensor2 = tf.constant(seq2)\n    result = tf.concat([tensor1, tensor2], 0)\n    return result.numpy().tolist()\n\n",
            "\ndef concatenate_sequences(sequences):\n    return tf.concat(sequences, axis=0)\n",
            "\ndef concatenate_sequences(input_list):\n    return tf.concat(input_list, 0)\n\ninput_list = [[1, 2], [10, 20]]\n\ninput_list = [[3, 4, 5], [30, 40, 50]]\n",
            "\nsequences = [[1, 2], [10, 20]]\n\nresult = tf.concat(sequences, axis=0)\n\n",
            "\ndef concatenate_sequences(input):\n    tensor_input = tf.constant(input)\n    tensor_output = tf.concat(tensor_input, axis=0)\n    output = tensor_output.numpy().tolist()\n    return output\n",
            "\ndef concat_batches(batches):\n    return tf.concat(batches, axis=0)\n\nbatches = [[1, 2], [10, 20]]\n"
        ],
        "target-program": "tf.concat([in1, in2], axis=1)",
        "description": "Concatenate batches of sequences",
        "tf_operators": {
            "tf.concat": 10,
            "tf.constant": 2
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "google_14",
        "completions": [
            "\ndef circular_buffer(input_tensor):\n    return tf.roll(input_tensor, shift=1, axis=0)[-1]\n\ninput_tensor = tf.constant([[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]])\noutput_tensor = circular_buffer(input_tensor)\n",
            "\ndef circular_buffer(arr):\n    return tf.roll(arr, shift=1, axis=-1)\n\narr = tf.constant([[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]])\n",
            "\ndata = [[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]]\n\ntensor = tf.constant(data)\n\noutput = tf.roll(tensor, shift=-1, axis=0)\n\n",
            "\ndef circular_buffer(data):\n    buffer = tf.zeros(shape=[5], dtype=tf.int32)\n    for sublist in data:\n        non_zero = tf.where(tf.not_equal(sublist, 0))[0, 0]\n        buffer = tf.roll(buffer, shift=-1, axis=0)\n        buffer = tf.tensor_scatter_nd_update(buffer, [[4]], [sublist[non_zero]])\n    return buffer\n\ndata = [[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]]\n",
            "\ndef circular_buffer(input):\n    input_tensor = tf.constant(input)\n    output_tensor = tf.roll(input_tensor, shift=1, axis=1)\n    return output_tensor.numpy().tolist()\n\n",
            "\ndef circular_buffer(input):\n    return tf.roll(input[0], shift=1, axis=-1)\n",
            "\ndef circular_buffer(input):\n    buffer_size = len(input[0])\n    buffer = tf.zeros(buffer_size, dtype=tf.int32)\n    for i, list in enumerate(input):\n        buffer = tf.roll(buffer, shift=-i, axis=0)\n        buffer = tf.tensor_scatter_nd_update(buffer, tf.reshape(tf.range(buffer_size), (-1, 1)), list)\n    return buffer.numpy().tolist()\n\ninput = [[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]]\n",
            "\ndata = [[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]]\n\ntensor_data = tf.constant(data)\n\nsum_data = tf.reduce_sum(tensor_data, axis=0)\n\ncircular_buffer = tf.roll(sum_data, shift=1, axis=0)\n\n",
            "\ndef circular_buffer(input):\n    tensor = tf.constant(input)\n    sum_tensor = tf.reduce_sum(tensor, axis=0)\n    result = tf.roll(sum_tensor, shift=1, axis=0)\n    return result\n\ninput = [[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]]\n",
            "\ndef circular_buffer(input):\n    return tf.roll(input, shift=1, axis=1)\n\ninput = tf.constant([[1, 3, 2, 0, 0], [4, 6, 5, 0, 0], [8, 7, 9, 0, 0]])\noutput = circular_buffer(input)\n"
        ],
        "target-program": "tf.roll(in1, 1, 1)",
        "description": "circular buffer",
        "tf_operators": {
            "tf.roll": 10,
            "tf.constant": 7,
            "tf.where": 1,
            "tf.int32": 2,
            "tf.zeros": 2,
            "tf.tensor_scatter_nd_update": 2,
            "tf.not_equal": 1,
            "tf.reshape": 1,
            "tf.range": 1,
            "tf.reduce_sum": 2
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "google_15",
        "completions": [
            "\ndata = [[1, 3, 5, 7], [2, 4, 6, 8]]\n\ntensor = tf.constant(data)\n\npaddings = tf.constant([[0, 0], [0, 1]])\n\npadded_tensor = tf.pad(tensor, paddings, \"CONSTANT\")\n\n",
            "\ninput = tf.constant([[1, 3, 5, 7], [2, 4, 6, 8]])\n\noutput = tf.pad(input, [[0, 0], [0, 1]])\n\n",
            "\ndata = [[1, 3, 5, 7], [2, 4, 6, 8]]\n\ntensor = tf.constant(data)\n\npadded_tensor = tf.pad(tensor, paddings=[[0, 0], [0, 1]], mode='CONSTANT', constant_values=0)\n\n",
            "\ndata = [[1, 3, 5, 7], [2, 4, 6, 8]]\n\ntensor = tf.constant(data)\n\npaddings = tf.constant([[0, 0], [0, 1]])\n\nresult = tf.pad(tensor, paddings, \"CONSTANT\")\n\n",
            "\ndef pad_zero_column(lst):\n    tensor = tf.constant(lst)\n    paddings = tf.constant([[0, 0], [0, 1]])\n    padded_tensor = tf.pad(tensor, paddings, \"CONSTANT\")\n    return padded_tensor.numpy().tolist()\n\nlst = [[1, 3, 5, 7], [2, 4, 6, 8]]\n",
            "\ninput_list = [[1, 3, 5, 7], [2, 4, 6, 8]]\n\ntensor = tf.constant(input_list)\n\noutput = tf.pad(tensor, [[0, 0], [0, 1]])\n\n",
            "\ntensor = tf.constant([[1, 3, 5, 7], [2, 4, 6, 8]])\n\npaddings = tf.constant([[0, 0], [0, 1]])\n\nresult = tf.pad(tensor, paddings, \"CONSTANT\")\n\n",
            "\ninput_data = [[1, 3, 5, 7], [2, 4, 6, 8]]\n\ntensor = tf.constant(input_data)\n\npadded_tensor = tf.pad(tensor, paddings=[[0, 0], [0, 1]])\n\n",
            "\narray = [[1, 3, 5, 7], [2, 4, 6, 8]]\n\ntensor = tf.constant(array)\n\npaddings = [[0, 0], [0, 1]]\n\npadded_tensor = tf.pad(tensor, paddings, \"CONSTANT\")\n\n",
            "\narr = [[1, 3, 5, 7], [2, 4, 6, 8]]\n\ntensor = tf.constant(arr)\n\npaddings = tf.constant([[0, 0], [0, 1]])\n\nresult = tf.pad(tensor, paddings)\n\n"
        ],
        "target-program": "tf.pad(in1, [[0, 0], [0, 1]], 'CONSTANT')",
        "description": "pad a zero column",
        "tf_operators": {
            "tf.pad": 10,
            "tf.constant": 10
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "google_16",
        "completions": [
            "\ndef min_repeats(arr):\n    _, _, count = tf.unique_with_counts(arr)\n    return tf.reduce_min(count)\n\n",
            "\ndef min_repeats(input_list):\n    _, _, count = tf.unique_with_counts(input_list)\n    return tf.reduce_min(count)\n\n",
            "\ndef replicate_elements(input_list):\n    counts = tf.math.bincount(input_list)\n    non_zero_counts = tf.boolean_mask(counts, counts > 0)\n    min_count = tf.reduce_min(non_zero_counts)\n    return min_count\n\n",
            "\ninput_list = [1, 2, 0, 3]\n\nrepeats = 2\n\ninput_tensor = tf.constant(input_list)\n\noutput = tf.repeat(input_tensor, repeats)\n\n",
            "\ndef replicate_elements(input, repeat_times):\n    return tf.repeat(input, repeat_times)\n\ninput = tf.constant([1, 2, 0, 3])\nrepeat_times = 1\noutput = replicate_elements(input, repeat_times)\n",
            "\ndef replicate_elements(arr):\n    counts = tf.math.bincount(arr)\n    max_count = tf.reduce_max(counts)\n    return max_count\n\narr = tf.constant([2, 1, 2, 3])\n",
            "\ndef count_unique_elements(lst):\n    unique_elements = tf.unique_with_counts(lst).y\n    return tf.shape(unique_elements)[0]\n\nlst = tf.constant([1, 2, 0, 3])\n\nlst = tf.constant([2, 1, 2, 3])\n",
            "\ninput_tensor = tf.constant([1, 2, 0, 3])\noutput_tensor = tf.repeat(input_tensor, 1)\n\n",
            "\ndef replicate_elements(lst):\n    _, _, count = tf.unique_with_counts(lst)\n    return tf.reduce_min(count)\n\nlst = tf.constant([1, 2, 0, 3])\n",
            "\ndef most_frequent_element_count(lst):\n    _, _, count = tf.unique_with_counts(lst)\n    max_count = tf.reduce_max(count)\n    return max_count\n\nlst = tf.constant([1, 2, 0, 3])\n\nlst = tf.constant([2, 1, 2, 3])\n"
        ],
        "target-program": "tf.gather(in1, tf.where(tf.sequence_mask(in2))[:, 0])",
        "description": "replicate elements a given number of times",
        "tf_operators": {
            "tf.unique_with_counts": 5,
            "tf.reduce_min": 4,
            "tf.math.bincount": 2,
            "tf.boolean_mask": 1,
            "tf.repeat": 3,
            "tf.constant": 7,
            "tf.reduce_max": 2,
            "tf.shape": 1
        },
        "coverage_percentage": 0.0,
        "total_in_target": 3,
        "total_covered": 0
    },
    {
        "task_id": "google_17",
        "completions": [
            "\nbool_tensor = tf.constant([True, False, False, True, False])\ntrue_count = tf.math.count_nonzero(bool_tensor)\n\nnum_tensor = tf.constant([1, 2, 3, 4, 5])\nneg_sum = tf.math.negative(tf.reduce_sum(num_tensor))\n",
            "\nbool_tensor = tf.constant([True, False, False, True, False])\ncount_true = tf.math.count_nonzero(bool_tensor)\n\ntensor = tf.constant([1, 2, 3, 4, 5])\nneg_sum = tf.reduce_sum(tf.math.negative(tensor))\n",
            "\nbool_array = tf.constant([True, False, False, True, False])\ncount_true = tf.math.count_nonzero(bool_array)\n\nint_array = tf.constant([1, 2, 3, 4, 5])\nproduct = tf.reduce_prod(int_array)\n\n",
            "\nbool_tensor = tf.constant([True, False, False, True, False])\nresult = tf.math.count_nonzero(bool_tensor)\n",
            "\ndef sum_elements(input, condition):\n    input_tensor = tf.constant(input)\n    condition_tensor = tf.constant(condition)\n    mask = tf.boolean_mask(input_tensor, condition_tensor)\n    sum_elements = tf.reduce_sum(mask)\n    if tf.reduce_any(tf.math.logical_not(condition_tensor)):\n        sum_elements = tf.math.negative(sum_elements)\n    return sum_elements\n",
            "\nbool_tensor = tf.constant([True, False, False, True, False])\nint_tensor = tf.constant([1, 2, 3, 4, 5])\n\nresult_tensor = tf.where(bool_tensor, int_tensor, 0)\n",
            "\nbool_tensor = tf.constant([True, False, False, True, False])\nint_tensor = tf.cast(bool_tensor, tf.int32)\nsum_of_trues = tf.reduce_sum(int_tensor)\n",
            "\ninput_tensor = tf.constant([True, False, False, True, False])\n\noutput = tf.math.count_nonzero(input_tensor)\n\n",
            "\ndef check_tensor(bool_tensor, num_list):\n    bool_tensor = tf.constant(bool_tensor)\n    num_tensor = tf.constant(num_list)\n    \n    if tf.reduce_all(bool_tensor):\n        return 1\n    else:\n        return tf.math.negative(tf.reduce_sum(num_tensor))\n\n",
            "\ndef process_input(input):\n    tensor = tf.constant(input)\n    tensor = tf.cast(tensor, tf.int32)\n    sum = tf.reduce_sum(tensor)\n    return tf.math.negative(sum)\n"
        ],
        "target-program": "tf.where(in1, in2, tf.multiply(in2, -10))",
        "description": "use bool tensor as condition",
        "tf_operators": {
            "tf.math.negative": 5,
            "tf.math.count_nonzero": 4,
            "tf.reduce_sum": 5,
            "tf.constant": 8,
            "tf.reduce_prod": 1,
            "tf.boolean_mask": 1,
            "tf.reduce_any": 1,
            "tf.math.logical_not": 1,
            "tf.where": 1,
            "tf.reduce_all": 1,
            "tf.cast": 1,
            "tf.int32": 1
        },
        "coverage_percentage": 50.0,
        "total_in_target": 2,
        "total_covered": 1
    },
    {
        "task_id": "google_18",
        "completions": [
            "\ndef sum_partitioned_by_second_tensor(tensor1, tensor2):\n    num_segments = tf.reduce_max(tensor2) + 1\n    result = tf.math.unsorted_segment_sum(tensor1, tensor2, num_segments)\n    total_sum = tf.reduce_sum(result)\n    return total_sum\n\ntensor1 = tf.constant([5, 7, -12, 10, 20])\ntensor2 = tf.constant([1, 2, 3, 1, 2])\noutput = sum_partitioned_by_second_tensor(tensor1, tensor2)\n",
            "\ndef sum_partitioned_elements(tensor1, tensor2):\n    return tf.math.unsorted_segment_sum(tensor1, tensor2, tf.reduce_max(tensor2) + 1)\n\ntensor1 = tf.constant([5, 7, -12, 10, 20])\ntensor2 = tf.constant([0, 0, 1, 1, 1])\n\ntensor1 = tf.constant([1, 2, 3, 1, 2])\ntensor2 = tf.constant([0, 0, 0, 0, 0])\n",
            "\ndef sum_partitioned_by_second_tensor(tensor1, tensor2):\n    return tf.math.unsorted_segment_sum(tensor1, tensor2, tf.reduce_max(tensor2) + 1)\n\ntensor1 = tf.constant([5, 7, -12, 10, 20])\ntensor2 = tf.constant([1, 2, 3, 1, 2])\n",
            "\ndef sum_partitioned_elements(tensor1, tensor2):\n    num_segments = tf.reduce_max(tensor2) + 1\n    return tf.math.unsorted_segment_sum(tensor1, tensor2, num_segments)\n\ntensor1 = tf.constant([5, 7, -12, 10, 20])\ntensor2 = tf.constant([1, 2, 3, 1, 2])\n\n",
            "\ntensor1 = tf.constant([5, 7, -12, 10, 20])\ntensor2 = tf.constant([1, 2, 3, 1, 2])\n\nresult = tf.math.unsorted_segment_sum(tensor1, tensor2, tf.reduce_max(tensor2) + 1)\n\ntotal = tf.reduce_sum(result)\n\n",
            "\ndef segmented_sum(data, segments):\n    data_tf = tf.constant(data)\n    segments_tf = tf.constant(segments)\n    num_segments = tf.reduce_max(segments_tf) + 1\n    return tf.reduce_sum(tf.math.unsorted_segment_sum(data_tf, segments_tf, num_segments))\n\n",
            "\ndef sum_partitioned_elements(tensor1, tensor2):\n    return tf.reduce_sum(tf.math.unsorted_segment_sum(tensor1, tensor2, tf.reduce_max(tensor2) + 1))\n\ntensor1 = tf.constant([5, 7, -12, 10, 20])\ntensor2 = tf.constant([0, 1, 2, 0, 1])\n\n",
            "\ndef sum_elements_partitioned(data, segments):\n    return tf.math.unsorted_segment_sum(data, segments, tf.reduce_max(segments)+1)\n\ndata = tf.constant([5, 7, -12, 10, 20])\nsegments = tf.constant([1, 2, 3, 1, 2])\nresult = sum_elements_partitioned(data, segments)\n\ndata = tf.constant([1, 2, 3, 1, 2])\nsegments = tf.constant([1, 2, 3, 1, 2])\nresult = sum_elements_partitioned(data, segments)\n",
            "\ndef sum_partitioned_elements(tensor1, tensor2):\n    num_segments = tf.reduce_max(tensor2) + 1\n    return tf.math.unsorted_segment_sum(tensor1, tensor2, num_segments)\n\ntensor1 = tf.constant([5, 7, -12, 10, 20])\ntensor2 = tf.constant([0, 1, 0, 1, 0])\n\ntensor1 = tf.constant([1, 2, 3, 1, 2])\ntensor2 = tf.constant([0, 0, 0, 0, 0])\n",
            "\ndef sum_partitioned_elements(tensor1, tensor2):\n    num_segments = tf.reduce_max(tensor2) + 1\n    return tf.math.unsorted_segment_sum(tensor1, tensor2, num_segments)\n\ntensor1 = tf.constant([5, 7, -12, 10, 20])\ntensor2 = tf.constant([0, 0, 0, 0, 0])\n\ntensor1 = tf.constant([1, 2, 3, 1, 2])\ntensor2 = tf.constant([0, 0, 0, 0, 0])\n"
        ],
        "target-program": "tf.linalg.matvec(tf.cast(tf.equal(in2[:, None], in2), tf.int32), in1)",
        "description": "(\\'sum of elements in the first tensor but partitioned by the second tensor\\')",
        "tf_operators": {
            "tf.math.unsorted_segment_sum": 10,
            "tf.constant": 10,
            "tf.reduce_max": 10,
            "tf.reduce_sum": 4
        },
        "coverage_percentage": 0.0,
        "total_in_target": 4,
        "total_covered": 0
    },
    {
        "task_id": "google_19",
        "completions": [
            "\ndef scatter_tensor(input_tensor, output_indices):\n    return tf.gather(input_tensor, output_indices, axis=1)\n\ninput_tensor = tf.constant([[11, 12, 13], [30, 20, 10], [77, 88, 99]])\noutput_indices = tf.constant([[2, 0, 1], [1, 0, 2], [0, 2, 1]])\n\nresult = scatter_tensor(input_tensor, output_indices)\n",
            "\ndef rearrange_elements(input_tensor, indices_tensor):\n    return tf.map_fn(lambda x: tf.gather(x[0], x[1]), (input_tensor, indices_tensor), dtype=tf.int32)\n\ninput_tensor = tf.constant([[11, 12, 13], [30, 20, 10], [77, 88, 99]])\nindices_tensor = tf.constant([[2, 0, 1], [1, 0, 2], [0, 2, 1]])\n\noutput_tensor = rearrange_elements(input_tensor, indices_tensor)\n",
            "\ndef scatter_tensor(data_tensor, index_tensor):\n    result = []\n    for i in range(len(data_tensor)):\n        result.append(tf.gather(data_tensor[i], index_tensor[i]))\n    return result\n\ndata_tensor = tf.constant([[11, 12, 13], [30, 20, 10], [77, 88, 99]])\nindex_tensor = tf.constant([[2, 0, 1], [1, 0, 2], [0, 2, 1]])\n\noutput = scatter_tensor(data_tensor, index_tensor)\n",
            "\ntensor = tf.constant([[11, 12, 13], [30, 20, 10], [77, 88, 99]])\nindices = tf.constant([[2, 0, 1], [1, 0, 2], [0, 2, 1]])\n\noutput = tf.map_fn(lambda x: tf.gather(x[0], x[1]), (tensor, indices), dtype=tf.int32)\n\n",
            "\ndef scatter_tensor(input1, input2):\n    flat_input1 = tf.reshape(input1, [-1])\n    flat_input2 = tf.reshape(input2, [-1])\n    return tf.gather(flat_input2, flat_input1)\n\ninput1 = tf.constant([[11, 12, 13], [30, 20, 10], [77, 88, 99]])\ninput2 = tf.constant([[2, 0, 1], [1, 0, 2], [0, 2, 1]])\noutput = scatter_tensor(input1, input2)\n",
            "\ndef rearrange_elements(tensor, indices):\n    result = []\n    for i in range(tf.shape(tensor)[0]):\n        result.append(tf.gather(tensor[i], indices[i]))\n    return tf.stack(result)\n\ntensor = tf.constant([[11, 12, 13], [30, 20, 10], [77, 88, 99]])\nindices = tf.constant([[2, 0, 1], [1, 0, 2], [0, 2, 1]])\n\n",
            "\ndef scatter_tensor(tensor, indices):\n    tensor = tf.constant(tensor)\n    indices = tf.constant(indices)\n    return tf.gather(tensor, indices, axis=1)\n\ntensor = [[11, 12, 13], [30, 20, 10], [77, 88, 99]]\nindices = [[2, 0, 1], [1, 0, 2], [0, 2, 1]]\n",
            "\ndef scatter_tensor(tensor, indices):\n    tensor = tf.constant(tensor)\n    indices = tf.constant(indices)\n    result = tf.gather(tensor, indices)\n    return result.numpy()\n\ntensor = [[11, 12, 13], [30, 20, 10], [77, 88, 99]]\nindices = [[2, 0, 1], [1, 0, 2], [0, 2, 1]]\n",
            "\ndef scatter_2d_tensor(values, indices):\n    return tf.gather(values, indices, axis=1)\n\nvalues = tf.constant([[11, 12, 13], [30, 20, 10], [77, 88, 99]])\nindices = tf.constant([[2, 0, 1], [1, 0, 2], [0, 2, 1]])\n\noutput = scatter_2d_tensor(values, indices)\noutput\n",
            "\ndef scatter_tensor(input_list, indices_list):\n    input_tensor = tf.constant(input_list, dtype=tf.int32)\n    indices_tensor = tf.constant(indices_list, dtype=tf.int32)\n    output_list = []\n    for i in range(input_tensor.shape[0]):\n        output_list.append(tf.gather(input_tensor[i], indices_tensor[i]))\n    output_tensor = tf.stack(output_list)\n    return output_tensor\n\ninput_list = [[11, 12, 13], [30, 20, 10], [77, 88, 99]]\nindices_list = [[2, 0, 1], [1, 0, 2], [0, 2, 1]]\n"
        ],
        "target-program": "tf.gather(in1, tf.argsort(in2, axis=1), batch_dims=1)",
        "description": "scatter a 2-D tensor with indices",
        "tf_operators": {
            "tf.gather": 10,
            "tf.constant": 10,
            "tf.int32": 3,
            "tf.map_fn": 2,
            "tf.reshape": 1,
            "tf.shape": 1,
            "tf.stack": 2
        },
        "coverage_percentage": 50.0,
        "total_in_target": 2,
        "total_covered": 1
    },
    {
        "task_id": "google_20",
        "completions": [
            "\ntensor = tf.constant([10, 7, 4, 3, 2, 8])\n\nsorted_indices = tf.argsort(tensor)\n\n",
            "\ninput_tensor = tf.constant([10, 7, 4, 3, 2, 8])\n\nsorted_indices = tf.argsort(input_tensor, axis=0)\n\n",
            "\ntensor = tf.constant([10, 7, 4, 3, 2, 8])\n\nsorted_indices = tf.argsort(tensor)\n\n",
            "\ntensor = tf.constant([10, 7, 4, 3, 2, 8])\n\nsorted_indices = tf.argsort(tensor)\n\nresult = tf.argsort(sorted_indices)\n\n",
            "\ntensor = tf.constant([10, 7, 4, 3, 2, 8])\n\nsorted_indices = tf.argsort(tensor)\n\n",
            "\ntensor = tf.constant([10, 7, 4, 3, 2, 8])\n\nsorted_indices = tf.argsort(tensor)\n\n",
            "\ninput_tensor = tf.constant([10, 7, 4, 3, 2, 8])\n\nsorted_indices = tf.argsort(input_tensor)\n\nsorted_index_in_original_order = tf.argsort(sorted_indices)\n\n",
            "\ntensor = tf.constant([10, 7, 4, 3, 2, 8])\n\nsorted_index = tf.argsort(tensor)\n\n",
            "\ndef sort_tensor_get_indices(t):\n    sorted_indices = tf.argsort(t)\n    sorted_indices_original_order = tf.argsort(sorted_indices)\n    return sorted_indices_original_order\n\nt = tf.constant([10, 7, 4, 3, 2, 8])\n",
            "\ntensor = tf.constant([10, 7, 4, 3, 2, 8])\n\nsorted_indices = tf.argsort(tensor)\n\n"
        ],
        "target-program": "tf.cast(tf.argsort(tf.argsort(in1)), tf.int32)",
        "description": "sort a tensor and return sorted index in original order",
        "tf_operators": {
            "tf.argsort": 10,
            "tf.constant": 10
        },
        "coverage_percentage": 33.33333333333333,
        "total_in_target": 3,
        "total_covered": 1
    },
    {
        "task_id": "google_21",
        "completions": [
            "\ntensor = tf.constant([0, 2, -2, 4, 5])\n\nindices = tf.constant([[4], [-1], [6], [-3], [8]])\n\nupdates = tf.constant([7, 8, -2, 10, -4])\n\nupdated_tensor = tf.tensor_scatter_nd_update(tensor, indices, updates)\n",
            "\ntensor = tf.constant([0, 2, -2, 4, 5])\nindices = tf.constant([4, -1, 6, -3, 8])\nupdates = tf.constant([7, 8, -2, 10, -4])\n\nindices = tf.expand_dims(indices, axis=-1)\nupdated_tensor = tf.tensor_scatter_nd_update(tensor, indices, updates)\n\n",
            "\ntensor = tf.constant([0, 2, -2, 4, 5])\n\nindices = tf.constant([[4], [-1], [6], [-3], [8]])\n\nupdates = tf.constant([7, 8, -2, 10, -4])\n\nupdated_tensor = tf.tensor_scatter_nd_update(tensor, indices, updates)\n",
            "\ntensor = tf.constant([0, 2, -2, 4, 5])\nindices = tf.constant([4, -1, 6, -3, 8])\nupdates = tf.constant([7, 8, -2, 10, -4])\n\nindices = tf.reshape(indices, [-1, 1])\n\nupdated_tensor = tf.tensor_scatter_nd_update(tensor, indices, updates)\n",
            "\ntensor = tf.constant([0, 2, -2, 4, 5])\nindices = tf.constant([[4], [-1], [6], [-3], [8]])\nupdates = tf.constant([7, 8, -2, 10, -4])\n\nupdated_tensor = tf.tensor_scatter_nd_update(tensor, indices, updates)\n",
            "\ntensor = tf.constant([0, 2, -2, 4, 5])\nindices = tf.constant([[4], [-1], [6], [-3], [8]])\nupdates = tf.constant([7, 8, -2, 10, -4])\n\nupdated_tensor = tf.tensor_scatter_nd_update(tensor, indices, updates)\n",
            "\ntensor = tf.constant([0, 2, -2, 4, 5])\n\nindices = tf.constant([[4], [-1], [6], [-3], [8]])\n\nupdates = tf.constant([7, 8, -2, 10, -4])\n\nupdated_tensor = tf.tensor_scatter_nd_update(tensor, indices, updates)\n",
            "\ntensor = tf.constant([0, 2, -2, 4, 5])\nindices = tf.constant([[4], [-1], [6], [-3], [8]])\nupdates = tf.constant([7, 8, -2, 10, -4])\n\nupdated_tensor = tf.tensor_scatter_nd_update(tensor, indices, updates)\n",
            "\ntensor = tf.constant([0, 2, -2, 4, 5])\nindices = tf.constant([[4], [-1], [6], [-3], [8]])\nupdates = tf.constant([7, 8, -2, 10, -4])\n\nupdated_tensor = tf.tensor_scatter_nd_update(tensor, indices, updates)\n",
            "\ntensor = tf.constant([0, 2, -2, 4, 5])\nindices = tf.constant([[4], [-1], [6], [-3], [8]])\nupdates = tf.constant([7, 8, -2, 10, -4])\n\nupdated_tensor = tf.tensor_scatter_nd_update(tensor, indices, updates)\n"
        ],
        "target-program": "tf.tensor_scatter_nd_update(tensor, indices, tf.reshape(updates, (-1,)))",
        "description": "update a tensor at the given indices",
        "tf_operators": {
            "tf.tensor_scatter_nd_update": 10,
            "tf.constant": 10,
            "tf.expand_dims": 1,
            "tf.reshape": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 2,
        "total_covered": 2
    },
    {
        "task_id": "google_22",
        "completions": [
            "\ndata = [[0, 2], [1, 3], [2, 4]]\n\ntensor = tf.constant(data)\n\nindices = tf.where(tf.range(tf.shape(tensor)[0]) == tensor[:, 0])\n\noutput = indices[:, 0]\n\n",
            "\ndef pair_with_row_index(data):\n    data = tf.constant(data)\n    indices = tf.range(tf.shape(data)[0])\n    indices = tf.tile(indices, [tf.shape(data)[1]])\n    indices = tf.reshape(indices, tf.shape(data))\n    return indices\n\ndata = [[0, 2], [1, 3], [2, 4]]\n",
            "\ndata = [[0, 2], [1, 3], [2, 4]]\n\ntensor = tf.constant(data)\n\noutput = tf.argmin(tensor, axis=1)\n\n",
            "\ndef pair_with_row_index(input):\n    return tf.argmin(input, axis=1)\n\ninput = tf.constant([[0, 2], [1, 3], [2, 4]])\noutput = pair_with_row_index(input)\n",
            "\ninput_tensor = tf.constant([[0, 2], [1, 3], [2, 4]])\n\nindices = tf.where(tf.ones_like(input_tensor))\n\nrow_indices = indices[:, 0]\n\nrow_indices_list = row_indices.numpy().tolist()\n\n",
            "\ndata = tf.constant([[0, 2], [1, 3], [2, 4]])\n\ncondition = tf.ones_like(data, dtype=tf.bool)\n\nindices = tf.where(condition)\n\nrow_indices = indices[:, 0]\n\n",
            "\ndata = tf.constant([[0, 2], [1, 3], [2, 4]])\n\nfirst_column = tf.slice(data, [0, 0], [-1, 1])\n\nrow_indices = tf.range(tf.shape(data)[0])\n\ncondition = tf.equal(tf.squeeze(first_column), row_indices)\n\noutput = tf.where(condition)\n\n",
            "\ndef pair_with_row_index(arr):\n    return tf.argmax(arr, axis=1)\n",
            "\ndef pair_with_row_index(matrix):\n    row_indices = tf.range(tf.shape(matrix)[0])\n    row_indices = tf.tile(row_indices[:, tf.newaxis], [1, tf.shape(matrix)[1]])\n    pairs = tf.stack([row_indices, matrix], axis=-1)\n    return pairs\n\nmatrix = tf.constant([[0, 2], [1, 3], [2, 4]])\n",
            "\ndef pair_with_row_index(arr):\n    indices = tf.range(tf.shape(arr)[0])\n    indices = tf.tile(indices[:, tf.newaxis], [1, tf.shape(arr)[1]])\n    return tf.stack([indices, arr], axis=-1)\n\narr = tf.constant([[0, 2], [1, 3], [2, 4]])\n"
        ],
        "target-program": "tf.cast(tf.where(tf.reduce_max(tf.one_hot(in1, tf.reduce_max(in1) + 1), axis=1)), tf.int32)",
        "description": "pair with row index",
        "tf_operators": {
            "tf.shape": 5,
            "tf.where": 4,
            "tf.range": 5,
            "tf.constant": 9,
            "tf.tile": 3,
            "tf.reshape": 1,
            "tf.argmin": 2,
            "tf.ones_like": 2,
            "tf.bool": 1,
            "tf.squeeze": 1,
            "tf.equal": 1,
            "tf.slice": 1,
            "tf.argmax": 1,
            "tf.newaxis": 2,
            "tf.stack": 2
        },
        "coverage_percentage": 20.0,
        "total_in_target": 5,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_01",
        "completions": [
            "\ndata = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n\ntensor = tf.constant(data)\n\nfirst_column = tf.gather(tensor, indices=[0], axis=1)\n\nreshaped_column = tf.reshape(first_column, shape=[-1, 1])\n\noutput = tf.concat([reshaped_column, reshaped_column], axis=1)\n\n",
            "\ndata = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n\ntensor = tf.constant(data)\n\nshape = tf.shape(tensor)\n\nnew_shape = [shape[0], shape[1]*2]\n\nreshaped_tensor = tf.reshape(tensor, new_shape)\n\n",
            "\ninput_list = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n\ninput_tensor = tf.constant(input_list)\n\nreshaped_tensor = tf.reshape(input_tensor[:,0], (-1, 1))\n\noutput = tf.repeat(reshaped_tensor, 2, axis=1)\n\n",
            "\ndef reshape_tensor(input_tensor):\n    first_column = tf.slice(input_tensor, [0, 0], [-1, 1])\n    reshaped_tensor = tf.reshape(first_column, [-1, 2])\n    return reshaped_tensor\n\ninput_tensor = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\noutput_tensor = reshape_tensor(input_tensor)\n",
            "\ndata = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\ntensor = tf.constant(data)\n\nreshaped_tensor = tf.reshape(tensor[:, 0], shape=(-1, 1))\n\noutput = tf.tile(reshaped_tensor, multiples=[1, 2])\n\n",
            "\ndef reshape_and_duplicate(input):\n    tensor = tf.constant(input)\n    first_column = tf.reshape(tensor[:, 0], shape=(-1, 1))\n    duplicated_first_column = tf.repeat(first_column, repeats=[2], axis=1)\n    return duplicated_first_column.numpy().tolist()\n\ninput = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\noutput = reshape_and_duplicate(input)\n",
            "\ndef reshape_tensor(input):\n    input = tf.constant(input)\n    first_column = input[:, 0] # get the first column\n    first_column = tf.expand_dims(first_column, axis=-1) # add a new dimension\n    output = tf.tile(first_column, [1, 2]) # duplicate the column\n    return output\n\ninput = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n",
            "\ndef reshape_input(input):\n    tensor = tf.constant(input)\n    columns = tf.unstack(tensor, axis=1)\n    output = tf.stack([columns[0], columns[0]], axis=1)\n    return output\n\ninput = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n",
            "\ninput_tensor = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\n\nfirst_column = tf.gather(input_tensor, indices=[0], axis=1)\n\noutput = tf.reshape(first_column, tf.shape(input_tensor))\n\n",
            "\ndata = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n\ntensor = tf.constant(data)\n\nreshaped_tensor = tf.reshape(tf.tile(tf.expand_dims(tensor[:, 0], axis=-1), [1, 2]), tf.shape(tensor))\n\n"
        ],
        "target-program": "tf.transpose(tf.cast((in1, in1), tf.float32))",
        "description": "reshape by separating and duplicating columns",
        "tf_operators": {
            "tf.gather": 2,
            "tf.concat": 1,
            "tf.reshape": 8,
            "tf.constant": 10,
            "tf.shape": 3,
            "tf.repeat": 2,
            "tf.slice": 1,
            "tf.tile": 3,
            "tf.expand_dims": 2,
            "tf.unstack": 1,
            "tf.stack": 1
        },
        "coverage_percentage": 0.0,
        "total_in_target": 3,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_02",
        "completions": [
            "\nvalues = tf.constant([5, 1, 0, 3, 0, -1, 2, -10, 2])\nclipped_values = tf.clip_by_value(values, clip_value_min=-tf.float32.max, clip_value_max=1)\n",
            "\ninput_tensor = tf.constant([5, 1, 0, 3, 0, -1, 2, -10, 2], dtype=tf.float32)\n\noutput_tensor = tf.clip_by_value(input_tensor, clip_value_min=-tf.float32.max, clip_value_max=1)\n\n",
            "\ninput_list = [5, 1, 0, 3, 0, -1, 2, -10, 2]\n\ninput_tensor = tf.constant(input_list, dtype=tf.float32)\n\noutput_tensor = tf.clip_by_value(input_tensor, clip_value_min=tf.float32.min, clip_value_max=1)\n\n",
            "\ninput_tensor = tf.constant([5, 1, 0, 3, 0, -1, 2, -10, 2], dtype=tf.float32)\n\noutput_tensor = tf.clip_by_value(input_tensor, clip_value_min=float('-inf'), clip_value_max=1)\n\n",
            "\ntensor = tf.constant([5, 1, 0, 3, 0, -1, 2, -10, 2], dtype=tf.float32)\n\nclipped_tensor = tf.clip_by_value(tensor, clip_value_min=tf.float32.min, clip_value_max=1)\n\n",
            "\ndef clip_values(tensor):\n    return tf.clip_by_value(tensor, clip_value_min=-tf.float32.max, clip_value_max=1)\n\ntensor = tf.constant([5, 1, 0, 3, 0, -1, 2, -10, 2], dtype=tf.float32)\n",
            "\ninput_tensor = tf.constant([5, 1, 0, 3, 0, -1, 2, -10, 2])\n\noutput_tensor = tf.clip_by_value(input_tensor, clip_value_min=-tf.float32.max, clip_value_max=1)\n\n",
            "import numpy as np\n\ninput_tensor = tf.constant([5, 1, 0, 3, 0, -1, 2, -10, 2])\n\noutput_tensor = tf.clip_by_value(input_tensor, -np.inf, 1)\n\n",
            "\ninput_list = [5, 1, 0, 3, 0, -1, 2, -10, 2]\n\ninput_tensor = tf.constant(input_list)\n\noutput_tensor = tf.clip_by_value(input_tensor, clip_value_min=float('-inf'), clip_value_max=1)\n\n",
            "\ninput_tensor = tf.constant([5, 1, 0, 3, 0, -1, 2, -10, 2])\n\noutput_tensor = tf.clip_by_value(input_tensor, clip_value_min=-1e10, clip_value_max=1)\n\n"
        ],
        "target-program": "tf.minimum(in1, tf.constant(1))",
        "description": "clip values that are greater than 1",
        "tf_operators": {
            "tf.float32.max": 4,
            "tf.clip_by_value": 10,
            "tf.constant": 10,
            "tf.float32": 5,
            "tf.float32.min": 2
        },
        "coverage_percentage": 50.0,
        "total_in_target": 2,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_03",
        "completions": [
            "\ntensor1 = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\n\ntensor2 = tf.constant([[-6, -5], [14, 15]])\n\nindices = tf.constant([[0, 3], [0, 4], [1, 3], [1, 4]])\n\nupdated_tensor = tf.tensor_scatter_nd_update(tensor1, indices, tf.reshape(tensor2, [-1]))\n\n",
            "\ntensor1 = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\n\nindices = tf.constant([[0,3], [0,4], [1,3], [1,4]])\nupdates = tf.constant([-6, -5, 14, 15])\n\ntensor1_updated = tf.tensor_scatter_nd_update(tensor1, indices, updates)\n\n",
            "\ntensor1 = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\n\ntensor2 = tf.constant([[-6, -5], [14, 15]])\n\nindices = tf.constant([[0, 3], [0, 4], [1, 3], [1, 4]])\n\nupdates = tf.reshape(tensor2, [-1])\n\noutput = tf.tensor_scatter_nd_update(tensor1, indices, updates)\n\n",
            "\ntensor1 = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\ntensor2 = tf.constant([[-6, -5], [14, 15]])\n\nindices = tf.constant([[0, 3], [0, 4], [1, 3], [1, 4]])\n\nupdates = tf.gather_nd(tensor2, [[0, 0], [0, 1], [1, 0], [1, 1]])\n\noutput = tf.tensor_scatter_nd_update(tensor1, indices, updates)\n\n",
            "\na = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\nb = tf.constant([[-6, -5], [14, 15]])\n\nindices = tf.constant([[0,3],[0,4],[1,3],[1,4]])\n\nupdates = tf.reshape(b, [-1])\n\nresult = tf.tensor_scatter_nd_update(a, indices, updates)\n\n",
            "\ntensor1 = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\ntensor2 = tf.constant([[-6, -5], [14, 15]])\n\nindices = tf.constant([[0, 3], [0, 4], [1, 3], [1, 4]])\n\nupdates = tf.reshape(tensor2, [-1])\n\nresult = tf.tensor_scatter_nd_update(tensor1, indices, updates)\n\n",
            "\ntensor1 = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\ntensor2 = tf.constant([[1, 2, 3, -6, -5, 6, 7], [10, 20, 30, 14, 15, 40, 50]])\n\nindices = tf.constant([[0, 3], [0, 4], [1, 3], [1, 4]])\n\nupdates = tf.gather_nd(tensor2, indices)\n\noutput = tf.tensor_scatter_nd_update(tensor1, indices, updates)\n\n",
            "\ntensor1 = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\n\ntensor2 = tf.constant([[-6, -5], [14, 15]])\n\nindices = tf.constant([[0, 3], [0, 4], [1, 3], [1, 4]])\n\nresult = tf.tensor_scatter_nd_update(tensor1, indices, tf.reshape(tensor2, [-1]))\n\n",
            "\ntensor1 = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\ntensor2 = tf.constant([[-6, -5], [14, 15]])\n\nindices = tf.constant([[0,3],[0,4],[1,3],[1,4]])\n\nupdates = tf.gather(tensor2, [0, 1], axis=1)\n\noutput = tf.tensor_scatter_nd_update(tensor1, indices, updates)\n\n",
            "\ntensor = tf.constant([[11, 22, 33, 44, 55, 66, 77], [70, 60, 50, 40, 30, 20, 10]])\n\nupdates = tf.constant([[-6, -5], [14, 15]])\n\nindices = tf.constant([[0, 3], [0, 4], [1, 3], [1, 4]])\n\nupdates = tf.reshape(updates, [-1])\n\nresult = tf.tensor_scatter_nd_update(tensor, indices, updates)\n"
        ],
        "target-program": "tf.reduce_sum(tf.one_hot(tf.range(3, 5), depth=in1.shape[1], dtype=tf.int32), axis=0) * in2 + (1 - tf.reduce_sum(tf.one_hot(tf.range(3, 5), depth=in1.shape[1], dtype=tf.int32), axis=0)) * in1",
        "description": "replace certain columns with columns from the other tensor",
        "tf_operators": {
            "tf.reshape": 6,
            "tf.tensor_scatter_nd_update": 10,
            "tf.constant": 10,
            "tf.gather_nd": 2,
            "tf.gather": 1
        },
        "coverage_percentage": 0.0,
        "total_in_target": 4,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_04",
        "completions": [
            "\ndef gather_index_zero(tensor):\n    indices = tf.constant([0, 0])\n    result = tf.gather(tensor, indices, axis=1)\n    return result\n\ntensor = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\n",
            "\ninput_tensor = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\n\nfirst_column = tf.gather(input_tensor, [0], axis=1)\n\noutput_tensor = tf.stack([first_column, first_column], axis=2)\n\noutput_tensor = tf.squeeze(output_tensor, axis=1)\n\n",
            "\ntensor = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\n\nindices = tf.constant([0, 0])\n\nresult = tf.gather(tensor, indices, axis=1)\n\n",
            "\ninput_tensor = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\n\nindices = tf.constant([0])\n\noutput = tf.gather(input_tensor, indices, axis=1)\n\noutput = tf.repeat(output, 2, axis=1)\n\n",
            "\ndata = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n\ntensor = tf.constant(data)\n\nindices = tf.stack([tf.range(tf.shape(tensor)[0]), tf.ones_like(tensor[:, 0], dtype=tf.int32)], axis=1)\n\nresult = tf.tensor_scatter_nd_update(tensor, indices, tensor[:, 0])\n\n",
            "\ntensor = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\n\nindices = tf.constant([[0, 1], [1, 1], [2, 1]])\n\nupdates = tf.gather_nd(tensor, tf.constant([[0, 0], [1, 0], [2, 0]]))\n\nresult = tf.tensor_scatter_nd_update(tensor, indices, updates)\n",
            "\ndef index_into_tensor(input):\n    tensor = tf.constant(input)\n    output = tf.gather(tensor, [0, 0], axis=1)\n    return output\n\ninput = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n",
            "\ninput_list = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n\ninput_tensor = tf.constant(input_list)\n\nindices = tf.constant([0])\n\ngathered_elements = tf.gather(input_tensor, indices, axis=1)\n\noutput = tf.stack([gathered_elements, gathered_elements], axis=2)\n\noutput = tf.reshape(output, tf.shape(input_tensor))\n\n",
            "\ntensor = tf.constant([[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]])\n\nresult = tf.gather(tensor, [0, 0], axis=1)\n\n",
            "\ndef index_into_tensor(input_tensor):\n    tensor = tf.constant(input_tensor)\n    indices = tf.stack([tf.range(tf.shape(tensor)[0]), tf.ones(tf.shape(tensor)[0], dtype=tf.int32)], axis=1)\n    updates = tensor[:, 0]\n    output = tf.tensor_scatter_nd_update(tensor, indices, updates)\n    return output\n\ninput_tensor = [[5.0, 2.0], [1.0, 3.0], [0.0, -1.0]]\n"
        ],
        "target-program": "tf.gather_nd(in1, tf.stack((in2, in3), axis=-1))",
        "description": "index into the tensor",
        "tf_operators": {
            "tf.gather": 7,
            "tf.constant": 10,
            "tf.squeeze": 1,
            "tf.stack": 4,
            "tf.repeat": 1,
            "tf.int32": 2,
            "tf.range": 2,
            "tf.shape": 3,
            "tf.ones_like": 1,
            "tf.tensor_scatter_nd_update": 3,
            "tf.gather_nd": 1,
            "tf.reshape": 1,
            "tf.ones": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 2,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_05",
        "completions": [
            "\ndef tensor_multiply(tensor1, tensor2):\n    return tf.tensordot(tensor1, tensor2, axes=[[1],[0]])\n\ntensor1 = tf.constant([[4, 3, 1], [6, 5, 2]])\ntensor2 = tf.constant([[1, 2], [3, 4], [5, 6]])\n\ntensor1 = tf.constant([[[5, 5]], [[1, 5]], [[6, 0]]])\ntensor2 = tf.constant([[1, 2], [3, 4]])\n",
            "\ndef tensor_multiplication(tensor1, tensor2):\n    result = tf.tensordot(tensor1, tensor2, axes=1)\n    return result\n\ntensor1 = tf.constant([[4, 3, 1], [6, 5, 2]])\ntensor2 = tf.constant([[5, 5]], tf.int32)\n\n",
            "\ndef tensor_multiplication(input):\n    a = tf.constant(input)\n    b = tf.constant([[1], [2], [3]])\n    result = tf.tensordot(a, b, axes=1)\n    return result.numpy().tolist()\n\n",
            "\ntensor1 = tf.constant([[4, 3, 1], [6, 5, 2]])\ntensor2 = tf.constant([[1, 2], [3, 4], [5, 6]])\nresult = tf.tensordot(tensor1, tensor2, axes=1)\n\ntensor1 = tf.constant([[[5, 5]], [[1, 5]], [[6, 0]]])\ntensor2 = tf.constant([[1, 2], [3, 4], [5, 6]])\nresult = tf.tensordot(tensor1, tensor2, axes=1)\n",
            "\na = tf.constant([[4, 3, 1], [6, 5, 2]])\nb = tf.constant([[5, 5]], shape=(1, 2, 3))\n\nresult = tf.tensordot(a, b, axes=1)\n\n",
            "\ndef tensor_multiplication(input):\n    return tf.tensordot(input, input, axes=1)\n\ninput = [[4, 3, 1], [6, 5, 2]]\noutput = tensor_multiplication(input)\n\ninput = [[[5, 5]], [[1, 5]], [[6, 0]]]\noutput = tensor_multiplication(input)\n",
            "\ndef tensor_multiplication(input):\n    tensor = tf.constant(input)\n    result = tf.tensordot(tensor, tensor, axes=1)\n    return result.numpy().tolist()\n\n",
            "\ndef tensor_multiplication(input):\n    tensor = tf.constant(input)\n    result = tf.tensordot(tensor, tf.transpose(tensor), axes=1)\n    return result.numpy().tolist()\n\n",
            "\ndef tensor_multiplication(input):\n    tensor = tf.constant(input)\n    result = tf.tensordot(tensor, tensor, axes=[[1], [0]])\n    return result.numpy().tolist()\n\n",
            "\ndef tensor_multiplication(input):\n    tensor_a = tf.constant(input)\n    tensor_b = tf.constant([[1], [2], [3]])\n    result = tf.tensordot(tensor_a, tensor_b, axes=1)\n    return result.numpy()\n"
        ],
        "target-program": "tf.tensordot(in1, in2, 1)",
        "description": "tensor multiplication like np.tensordot",
        "tf_operators": {
            "tf.tensordot": 10,
            "tf.constant": 9,
            "tf.int32": 1,
            "tf.transpose": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_06",
        "completions": [
            "\ndef binary_tensor_from_vector(vector):\n    first_element = vector[0]\n    equal_to_first = tf.equal(vector, first_element)\n    binary_tensor = tf.cast(equal_to_first, tf.float32)\n    return binary_tensor\n\nvector = tf.constant([3, 5, 0, 2, 3, 3, 0])\noutput = binary_tensor_from_vector(vector)\n",
            "\nvec = tf.constant([3, 5, 0, 2, 3, 3, 0])\n\nequal_to_first = tf.equal(vec, vec[0])\n\nbinary_tensor = tf.cast(equal_to_first, tf.float32)\n\n",
            "\nvector = tf.constant([3, 5, 0, 2, 3, 3, 0])\n\nbinary_tensor = tf.equal(vector, vector[0])\n\nbinary_tensor = tf.cast(binary_tensor, tf.float32)\n\n",
            "\ndef binary_tensor_from_vector(vector):\n    tensor = tf.constant(vector)\n    first_element = tensor[0]\n    binary_tensor = tf.cast(tf.equal(tensor, first_element), tf.float32)\n    return binary_tensor\n",
            "\ndef binary_tensor_from_vector(vector):\n    tensor = tf.constant(vector)\n    binary_tensor = tf.cast(tf.equal(tensor, tensor[0]), tf.float32)\n    return binary_tensor\n",
            "\ndef binary_tensor_from_vector(vector):\n    tensor = tf.constant(vector)\n    first_element = tensor[0]\n    equal_to_first = tf.equal(tensor, first_element)\n    binary_tensor = tf.cast(equal_to_first, tf.float32)\n    return binary_tensor\n",
            "\ndef binary_tensor_from_vector(vector):\n    tensor = tf.constant(vector)\n    binary_tensor = tf.cast(tf.equal(tensor, tensor[0]), tf.float32)\n    return binary_tensor\n\nvector = [3, 5, 0, 2, 3, 3, 0]\n",
            "\ndef binary_tensor_from_vector(vector):\n    tensor = tf.constant(vector)\n    binary_tensor = tf.cast(tf.equal(tensor, tensor[0]), tf.float32)\n    return binary_tensor\n\nvector = [3, 5, 0, 2, 3, 3, 0]\n",
            "\ndef binary_tensor_from_vector(vector):\n    first_element = tf.constant(vector[0])\n    equals_first_element = tf.equal(vector, first_element)\n    binary_tensor = tf.cast(equals_first_element, tf.float32)\n    return binary_tensor\n\nvector = [3, 5, 0, 2, 3, 3, 0]\n",
            "\ndef binary_tensor_from_vector(vector):\n    first_element = vector[0]\n    binary_tensor = tf.cast(tf.equal(vector, first_element), tf.float32)\n    return binary_tensor\n\nvector = [3, 5, 0, 2, 3, 3, 0]\n"
        ],
        "target-program": "tf.cast(tf.equal(in1, tf.expand_dims(in1, 1)), tf.float32)",
        "description": "binary tensor from vector indicating if elements are equal",
        "tf_operators": {
            "tf.cast": 10,
            "tf.equal": 10,
            "tf.float32": 10,
            "tf.constant": 9
        },
        "coverage_percentage": 75.0,
        "total_in_target": 4,
        "total_covered": 3
    },
    {
        "task_id": "stackoverflow_07",
        "completions": [
            "\ndef swap_dimensions(tensor):\n    return tf.transpose(tensor, perm=[1, 0, 2])[0]\n\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\noutput = tf.transpose(tensor, [1, 0, 2])\n\n",
            "\ndef swap_dimensions(tensor):\n    return tf.transpose(tensor, perm=[1, 0, 2])[0]\n\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\noutput = tf.transpose(tensor, perm=[1, 0, 2])\n\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\nswapped_tensor = tf.transpose(tensor, perm=[1, 0, 2])\n\noutput = swapped_tensor[0]\n\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\nswapped_tensor = tf.transpose(tensor, perm=[1, 0, 2])\n\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\noutput = tf.transpose(tensor, perm=[1, 0, 2])\n\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\nresult = tf.transpose(tensor, perm=[1, 0, 2])\n\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\nswapped_tensor = tf.transpose(tensor, perm=[1, 0, 2])\n\noutput = swapped_tensor[0]\n",
            "\ntensor = tf.constant([[[8, 4, 6], [2, 12, 3]], [[11, 12, 5], [9, 12, 12]], [[9, 2, 13], [7, 0, 7]], [[2, 10, 5], [7, 1, 2]]])\n\ntransposed_tensor = tf.transpose(tensor, perm=[1, 0, 2])\n\noutput = transposed_tensor[0]\n"
        ],
        "target-program": "tf.cast(tf.unstack(in1, axis=1), tf.int32)",
        "description": "swap the first two dimensions of the tensor",
        "tf_operators": {
            "tf.constant": 10,
            "tf.transpose": 10
        },
        "coverage_percentage": 0.0,
        "total_in_target": 3,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_08",
        "completions": [
            "\ntensor1 = tf.constant([12, 3, 45, 6, 7, 8, 9, 87, 65, 4, 32])\ntensor2 = tf.range(tf.size(tensor1))\n\nmask = tf.greater(tensor1, 1)\n\nselected_values = tf.boolean_mask(tensor2, mask)\n\n",
            "\ntensor1 = tf.constant([-1, 0, -3, 2, 1, 3, 5, -1, -9, 2, 10])\n\ntensor2 = tf.constant([12, 3, 45, 6, 7, 8, 9, 87, 65, 4, 32])\n\nmask = tf.greater(tensor1, 1)\n\nresult = tf.boolean_mask(tensor2, mask)\n\n",
            "\ndef select_values(tensor1, tensor2):\n    tensor1 = tf.constant(tensor1)\n    tensor2 = tf.constant(tensor2)\n    \n    mask = tf.greater(tensor1, 1)\n    selected = tf.boolean_mask(tensor2, mask)\n    \n    return tf.shape(selected)[0]\n",
            "\ndef select_values(tensor1, tensor2):\n    tensor1 = tf.constant(tensor1)\n    tensor2 = tf.constant(tensor2)\n    mask = tf.greater(tensor1, 1)\n    selected_values = tf.boolean_mask(tensor2, mask)\n    return tf.shape(selected_values)[0]\n",
            "\ndef select_values(tensor1, tensor2):\n    mask = tf.greater(tensor1, 1)\n    selected_values = tf.boolean_mask(tensor2, mask)\n    return tf.size(selected_values)\n\ntensor1 = tf.constant([-1, 0, -3, 2, 1, 3, 5, -1, -9, 2, 10])\ntensor2 = tf.constant([12, 3, 45, 6, 7, 8, 9, 87, 65, 4, 32])\n",
            "\ndef select_values(tensor1, tensor2):\n    mask = tf.greater(tensor1, 1)\n    result = tf.boolean_mask(tensor2, mask)\n    return result\n\ntensor1 = tf.constant([-1, 0, -3, 2, 1, 3, 5, -1, -9, 2, 10])\ntensor2 = tf.range(tf.size(tensor1))\noutput = select_values(tensor1, tensor2)\n\ntensor1 = tf.constant([12, 3, 45, 6, 7, 8, 9, 87, 65, 4, 32])\ntensor2 = tf.range(tf.size(tensor1))\noutput = select_values(tensor1, tensor2)\n",
            "\ndef select_values(tensor):\n    tensor1 = tf.constant(tensor)\n    tensor2 = tf.range(len(tensor))\n\n    mask = tf.greater(tensor1, 1)\n    output = tf.boolean_mask(tensor2, mask)\n\n    return output.numpy().size\n\n",
            "\ndef select_values(tensor1, tensor2):\n    tensor1 = tf.constant(tensor1)\n    tensor2 = tf.constant(tensor2)\n    mask = tf.greater(tensor1, 1)\n    selected_values = tf.boolean_mask(tensor2, mask)\n    return selected_values\n",
            "\ndef select_values(input_values):\n    tensor1 = tf.constant(input_values)\n    tensor2 = tf.range(tf.size(input_values))\n\n    mask = tf.greater(tensor1, 1)\n    masked_tensor = tf.boolean_mask(tensor2, mask)\n\n    return tf.shape(masked_tensor)[0]\n",
            "\ndef select_values(tensor1, tensor2):\n    mask = tf.greater(tensor1, 1)\n    return tf.boolean_mask(tensor2, mask)\n"
        ],
        "target-program": "tf.boolean_mask(in2, tf.greater(in1, tf.constant(1)))",
        "description": "(\\'select the values in the second tensor where the first tensor is greater than 1\\')",
        "tf_operators": {
            "tf.range": 4,
            "tf.size": 4,
            "tf.boolean_mask": 10,
            "tf.greater": 10,
            "tf.constant": 9,
            "tf.shape": 3
        },
        "coverage_percentage": 100.0,
        "total_in_target": 3,
        "total_covered": 3
    },
    {
        "task_id": "stackoverflow_09",
        "completions": [
            "\ndef group_items_by_value(input):\n    _, idx, _ = tf.unique_with_counts(input)\n    return idx\n\ninput = tf.constant([37, 42, 42, 37, 28, 15, 42, 15])\noutput = group_items_by_value(input)\n",
            "\ninput_list = [37, 42, 42, 37, 28, 15, 42, 15]\n\ninput_tensor = tf.constant(input_list)\n\n_, _, indices = tf.unique_with_counts(input_tensor)\n\n",
            "\ninput_list = [37, 42, 42, 37, 28, 15, 42, 15]\n\ntensor = tf.constant(input_list)\n\n_, indices = tf.unique_with_counts(tensor)\n\n",
            "\ndef get_most_frequent_group_index(input):\n    _, _, count = tf.unique_with_counts(input)\n    index = tf.argmax(count)\n    return index.numpy()\n\ninput = [37, 42, 42, 37, 28, 15, 42, 15]\n",
            "\ndef group_items_by_value_and_get_indices(x):\n    _, idx, _ = tf.unique_with_counts(x)\n    return idx\n\nx = tf.constant([37, 42, 42, 37, 28, 15, 42, 15])\n",
            "\narr = tf.constant([37, 42, 42, 37, 28, 15, 42, 15])\noutput = tf.math.bincount(arr)\n",
            "\ndef group_items(input_list):\n    _, idx = tf.unique_with_counts(input_list)\n    return idx\n\ninput_list = [37, 42, 42, 37, 28, 15, 42, 15]\n",
            "\ninput_list = [37, 42, 42, 37, 28, 15, 42, 15]\n\ntensor = tf.constant(input_list)\n\nunique, idx, count = tf.unique_with_counts(tensor)\n\nindices = tf.where(tf.equal(tensor, unique[0]))\n\n",
            "\ndef group_items(input):\n    _, idx, _ = tf.unique_with_counts(input)\n    return idx\n\ninput = [37, 42, 42, 37, 28, 15, 42, 15]\n",
            "\ndef group_items(input):\n    y, idx, count = tf.unique_with_counts(input)\n    return idx.numpy()\n\ninput = tf.constant([37, 42, 42, 37, 28, 15, 42, 15])\n"
        ],
        "target-program": "tf.unique_with_counts(in1)[1]",
        "description": "group items by value and get the group indices",
        "tf_operators": {
            "tf.unique_with_counts": 9,
            "tf.constant": 7,
            "tf.argmax": 1,
            "tf.math.bincount": 1,
            "tf.equal": 1,
            "tf.where": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_10",
        "completions": [
            "\nmatrix1 = tf.constant([[15, 10], [20, -5]])\nmatrix2 = tf.constant([[2, 3, 1], [-2, 5, 0]])\n\nresult = tf.matmul(matrix1, matrix2)\n",
            "A = tf.constant([[15, 10], [20, -5]], dtype=tf.float32)\nB = tf.constant([[...]], dtype=tf.float32)\nC = tf.matmul(A, B)",
            "\nmatrix1 = tf.constant([[15, 10], [20, -5]])\nmatrix2 = tf.constant([[1, 2], [3, 4]])\n\nresult = tf.matmul(matrix1, matrix2)\n",
            "\nmatrix1 = tf.constant([[15, 10], [20, -5]])\n\nmatrix2 = tf.eye(2, 2)\n\nresult = tf.matmul(matrix1, matrix2)\n\n",
            "\nmatrix1 = tf.constant([[15, 10], [20, -5]])\nmatrix2 = tf.constant([[2, 3, 1], [-2, 5, 0]])\n\nresult = tf.matmul(matrix1, matrix2)\n\n",
            "\ninput_matrix = tf.constant([[15, 10], [20, -5]])\n\nsecond_matrix = tf.constant([[2,3,1], [1,1,1]])\n\noutput_matrix = tf.matmul(input_matrix, second_matrix)\n",
            "\nmatrix1 = tf.constant([[15, 10], [20, -5]])\nmatrix2 = tf.constant([[2], [3]])\n\nresult = tf.matmul(matrix1, matrix2)\n\n",
            "A = tf.constant([[15, 10], [20, -5]], dtype=tf.float32)\nB = tf.constant([[1, 2, 3], [4, 5, 6]], dtype=tf.float32)\nC = tf.matmul(A, B)",
            "\nmatrix1 = tf.constant([[15, 10], [20, -5]])\nmatrix2 = tf.constant([[2, 3], [1, -2]])\n\nresult = tf.matmul(matrix1, matrix2)\n\n",
            "\nmatrix1 = tf.constant([[15, 10], [20, -5]])\nmatrix2 = tf.constant([[2, 3, 1], [-2, 5, 0]])\n\nresult = tf.matmul(matrix1, matrix2)\n\n"
        ],
        "target-program": "tf.matmul(tf.expand_dims(in1, -1), tf.expand_dims(in2, 1))",
        "description": "perform matrix multiplication",
        "tf_operators": {
            "tf.matmul": 8,
            "tf.constant": 8,
            "tf.eye": 1
        },
        "coverage_percentage": 50.0,
        "total_in_target": 2,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_11",
        "completions": [
            "\ndef count_occurrences(input_list):\n    input_tensor = tf.constant(input_list)\n    count = tf.math.bincount(input_tensor)\n    return count\n\ninput_list = [4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1]\n",
            "\nx = [4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1]\n\ncounts = tf.math.bincount(x)\n\n",
            "\narr = [4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1]\n\narr_tensor = tf.constant(arr)\n\ncounts = tf.math.bincount(arr_tensor)\n\n",
            "\narr = [4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1]\n\narr_tensor = tf.constant(arr)\n\ncount = tf.math.bincount(arr_tensor)\n\n",
            "\ninput_list = [4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1]\n\ninput_tensor = tf.constant(input_list)\n\noutput = tf.math.bincount(input_tensor)\n\n",
            "\ninput_list = tf.constant([4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1])\n\noutput = tf.math.bincount(input_list)\n\n",
            "\narr = [4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1]\n\ntensor_arr = tf.constant(arr)\n\nbincount = tf.math.bincount(tensor_arr)\n\n",
            "\ninput_list = tf.constant([4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1])\noutput = tf.math.bincount(input_list)\n\n",
            "\narr = tf.constant([4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1])\ncount = tf.math.bincount(arr)\n",
            "\ninput_list = [4, 0, 1, 1, 0, 4, 0, 0, 3, 4, 1]\n\ninput_tensor = tf.constant(input_list)\n\n_, _, count = tf.unique_with_counts(input_tensor)\n\n"
        ],
        "target-program": "tf.math.bincount(in1)",
        "description": "count the number of occurences of each distinct number",
        "tf_operators": {
            "tf.math.bincount": 9,
            "tf.constant": 9,
            "tf.unique_with_counts": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_12",
        "completions": [
            "\ntensor = tf.constant([[12, 34, 56], [33, 22, 11]])\n\nindices = [0, 2]\n\nresult = tf.gather(tensor, indices, axis=1)\n\n",
            "\ntensor = tf.constant([[12, 34, 56], [33, 22, 11]])\n\nresult = tf.gather(tensor, [0, 2], axis=1)\n\n",
            "\ndata = [[12, 34, 56], [33, 22, 11]]\n\ntensor = tf.constant(data)\n\nresult = tf.gather(tensor, [0, 2], axis=1)\n\n",
            "\ntensor = tf.constant([[12, 34, 56], [33, 22, 11]])\n\nindices = [0, 2]\n\nresult = tf.gather(tensor, indices, axis=1)\n\n",
            "\ntensor = tf.constant([[12, 34, 56], [33, 22, 11]])\n\nfirst_column = tf.slice(tensor, [0, 0], [2, 1])\nthird_column = tf.slice(tensor, [0, 2], [2, 1])\n\nresult = tf.concat([first_column, third_column], 1)\n\n",
            "\ntensor = tf.constant([[12, 34, 56], [33, 22, 11]])\n\nindices = [0, 2]\n\nresult = tf.gather(tensor, indices, axis=1)\n\n",
            "\ndata = tf.convert_to_tensor([[12, 34, 56], [33, 22, 11]])\n\nresult = tf.gather(data, [0, 2], axis=1)\n\n",
            "\ndata = [[12, 34, 56], [33, 22, 11]]\n\ntensor = tf.constant(data)\n\ncolumns = tf.unstack(tensor, axis=1)\n\ndel columns[1]\n\noutput = tf.stack(columns, axis=1)\n\n",
            "\ntensor = tf.constant([[12, 34, 56], [33, 22, 11]])\n\nindices = [0, 2]\n\noutput = tf.gather(tensor, indices, axis=1)\n\n",
            "\ntensor = tf.constant([[12, 34, 56], [33, 22, 11]])\n\nindices = [0, 2]\n\nresult = tf.gather(tensor, indices, axis=1)\n\n"
        ],
        "target-program": "tf.gather(in1, (0, 2), axis=1, batch_dims=0)",
        "description": "remove a column from the tensor",
        "tf_operators": {
            "tf.gather": 8,
            "tf.constant": 9,
            "tf.concat": 1,
            "tf.slice": 1,
            "tf.convert_to_tensor": 1,
            "tf.unstack": 1,
            "tf.stack": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_13",
        "completions": [
            "\ntensor = tf.constant([[2, 4], [3, 10]])\n\nvector1 = tf.constant([[3, 5], [10, 2]])\nvector2 = tf.constant([[[1, 0], [5, 4]], [[3, 10], [2, -2]]])\n\noutput1 = tf.multiply(vector1, tensor)\noutput2 = tf.multiply(vector2, tensor)\n\n",
            "\ninput_vector = tf.constant([[3, 5], [10, 2]])\n\ntensor = tf.constant([[2, 4], [3, 5]])\n\noutput = tf.matmul(input_vector, tensor)\n\n",
            "\ndef multiply_tensors(input_tensor):\n    fixed_tensor = tf.constant([[7, 4], [1, 10]])\n    return tf.multiply(input_tensor, fixed_tensor)\n",
            "\ntensor = tf.constant([[4, 2], [3, 4]])\n\nvector1 = tf.constant([[3, 5], [10, 2]])\nvector2 = tf.constant([[[1, 0], [5, 4]], [[3, 10], [2, -2]]])\n\noutput1 = tf.matmul(vector1, tensor)\noutput2 = tf.matmul(vector2, tensor)\n",
            "\ndef multiply_tensors(input_tensor):\n    constant_tensor = tf.constant([[4, 7], [1, 10]])\n    return tf.multiply(constant_tensor, input_tensor)\n",
            "\ninput_tensor = tf.constant(input_tensor)\n\nvector = tf.constant(vector)\n\noutput = tf.multiply(input_tensor, vector)\n",
            "\ndef multiply_tensors(input_tensor):\n    tensor_ones = tf.ones_like(input_tensor)\n    output_tensor = tf.matmul(input_tensor, tensor_ones, transpose_b=True)\n    return output_tensor\n",
            "\ndef multiply_vectors_by_tensor(input):\n    tensor = tf.constant([[2, 4], [3, 4]])\n    return tf.matmul(input, tensor)\n\ninput = tf.constant([[3, 5], [10, 2]])\n\ninput = tf.constant([[[1, 0], [5, 4]], [[3, 10], [2, -2]]])\n",
            "\ndef multiply_tensors(input_tensor):\n    constant_tensor = tf.constant([[7, 4], [4, 10]])\n    result = tf.multiply(input_tensor, constant_tensor)\n    return result\n",
            "\ninput_tensor = tf.constant([[3, 5], [10, 2]])\n\nmultiply_tensor = tf.constant([[4, 2], [3, 5]])\n\noutput_tensor = tf.multiply(input_tensor, multiply_tensor)\n\n"
        ],
        "target-program": "tf.tensordot(in1, in2, (1, 1))",
        "description": "multiply vectors by tensor",
        "tf_operators": {
            "tf.multiply": 6,
            "tf.constant": 9,
            "tf.matmul": 4,
            "tf.ones_like": 1
        },
        "coverage_percentage": 0.0,
        "total_in_target": 1,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_14",
        "completions": [
            "\ndef check_any_true(input):\n    return tf.reduce_any(input, axis=2)\n\ninput = tf.constant([[[False, False, True], [False, False, False], [True, False, True], [False, True, False], [False, False, False], [True, True, True], [True, True, False]]])\noutput = check_any_true(input)\n",
            "\ndef check_any_true(input):\n    return tf.reduce_any(input, axis=2)\n\ninput = tf.constant([[[False, False, True], [False, False, False], [True, False, True], [False, True, False], [False, False, False], [True, True, True], [True, True, False]]])\noutput = check_any_true(input)\n",
            "\ndef check_true_in_row(tensor):\n    return tf.reduce_any(tensor, axis=2)\n\ntensor = tf.constant([[[False, False, True], [False, False, False], [True, False, True], [False, True, False], [False, False, False], [True, True, True], [True, True, False]]])\noutput = check_true_in_row(tensor)\n",
            "\ndef check_any_true(input_tensor):\n    return tf.reduce_any(input_tensor, axis=1)\n\ninput_tensor = tf.constant([[[False, False, True], [False, False, False], [True, False, True], [False, True, False], [False, False, False], [True, True, True], [True, True, False]]])\n",
            "\ndef any_true_in_row(input_tensor):\n    return tf.reduce_any(input_tensor, axis=1)\n",
            "\ndef check_row_values(input):\n    tensor = tf.constant(input)\n    result = tf.reduce_any(tensor, axis=2)\n    return result\n",
            "\ndef any_true_in_row(input_tensor):\n    return tf.reduce_any(input_tensor, axis=2)\n",
            "\ntensor = tf.constant([[[False, False, True], [False, False, False], [True, False, True], [False, True, False], [False, False, False], [True, True, True], [True, True, False]]])\n\nresult = tf.reduce_any(tensor, axis=1)\n\n",
            "\ndef check_true_in_row(input_tensor):\n    return tf.reduce_any(input_tensor, axis=2)\n",
            "\ndef any_true_in_row(input_tensor):\n    return tf.reduce_any(input_tensor, axis=1)\n\ninput_tensor = tf.constant([[[False, False, True], [False, False, False], [True, False, True], [False, True, False], [False, False, False], [True, True, True], [True, True, False]]])\noutput = any_true_in_row(input_tensor)\n"
        ],
        "target-program": "tf.reduce_any(in1, axis=-1)",
        "description": "choose True if any value in a row is True, False otherwise",
        "tf_operators": {
            "tf.reduce_any": 10,
            "tf.constant": 7
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_15",
        "completions": [
            "\nlst = [3, 1, 2, 0, 1, -1, 10, 1, -10]\n\ntensor = tf.constant(lst)\n\noutput = tf.where(tensor!=1, tensor, tf.zeros_like(tensor))\n\n",
            "\ninput_tensor = tf.constant([3, 1, 2, 0, 1, -1, 10, 1, -10])\n\noutput_tensor = tf.where(tf.equal(input_tensor, 1), 0, input_tensor)\n\n",
            "\ndef replace_ones_with_zeros(input_list):\n    tensor = tf.constant(input_list)\n    output = tf.where(tf.equal(tensor, 1), 0, tensor)\n    return output\n\ninput_list = [3, 1, 2, 0, 1, -1, 10, 1, -10]\noutput = replace_ones_with_zeros(input_list)\n",
            "\ninput_list = tf.constant([3, 1, 2, 0, 1, -1, 10, 1, -10])\n\noutput_list = tf.where(tf.equal(input_list, 1), 0, input_list)\n\n",
            "\ninput_tensor = tf.constant([3, 1, 2, 0, 1, -1, 10, 1, -10])\n\noutput_tensor = tf.where(tf.equal(input_tensor, 1), 0, input_tensor)\n",
            "\ninput = tf.constant([3, 1, 2, 0, 1, -1, 10, 1, -10])\noutput = tf.where(tf.equal(input, 1), 0, input)\n",
            "\ntensor = tf.constant([3, 1, 2, 0, 1, -1, 10, 1, -10])\n\noutput = tf.where(tf.not_equal(tensor, 1), tensor, tf.zeros_like(tensor))\n\n",
            "\ninput_tensor = tf.constant([3, 1, 2, 0, 1, -1, 10, 1, -10])\n\noutput_tensor = tf.where(tf.not_equal(input_tensor, 1), input_tensor, 0)\n",
            "\nlst = tf.constant([3, 1, 2, 0, 1, -1, 10, 1, -10])\n\ncondition = tf.equal(lst, 1)\n\nzeros = tf.zeros_like(lst)\n\noutput = tf.where(condition, zeros, lst)\n",
            "\nx = tf.constant([3, 1, 2, 0, 1, -1, 10, 1, -10])\n\noutput = tf.where(tf.not_equal(x, 1), x, 0)\n\n"
        ],
        "target-program": "tf.subtract(in1, tf.cast(tf.equal(in1, tf.constant(1)), tf.int32))",
        "description": "set all instances of 1 to 0",
        "tf_operators": {
            "tf.where": 10,
            "tf.zeros_like": 3,
            "tf.constant": 10,
            "tf.equal": 6,
            "tf.not_equal": 3
        },
        "coverage_percentage": 40.0,
        "total_in_target": 5,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_16",
        "completions": [
            "\ndef multiply_tensors(input_tensor):\n    result = tf.reduce_prod(input_tensor, axis=0)\n    return result\n",
            "\ndef multiply_tensors(input_tensor):\n    product = tf.reduce_prod(input_tensor, axis=0)\n    return product\n\ninput_tensor = tf.constant([[2, 5], [3, 0], [8, -7]], dtype=tf.int32)\noutput_tensor = multiply_tensors(input_tensor)\n",
            "\ndef multiply_tensors(input):\n    result = tf.reduce_prod(input, axis=0)\n    return result\n",
            "\ndef multiply_tensors(input_tensor):\n    tensor = tf.constant(input_tensor)\n    result = tf.reduce_prod(tensor, axis=0)\n    return result.numpy().tolist()\n",
            "\ndef multiply_tensors(input):\n    return tf.reduce_prod(input, 0)\n\n",
            "\ndef multiply_tensors(input_tensor):\n    return tf.reduce_prod(input_tensor, axis=0)\n\ninput_tensor = tf.constant([[2, 5], [3, 0], [8, -7]])\noutput = multiply_tensors(input_tensor)\n",
            "\ndef multiply_tensors(input):\n    return tf.reduce_prod(input, axis=0)\n\n",
            "\ndef multiply_tensors(input):\n    tensor = tf.constant(input)\n    result = tf.reduce_prod(tensor, 0)\n    return result.numpy().tolist()\n\n",
            "\ndef multiply_tensors(input_tensor):\n    return tf.reduce_prod(input_tensor, axis=0)\n\ninput_tensor = tf.constant([[2, 5], [3, 0], [8, -7]])\noutput_tensor = multiply_tensors(input_tensor)\n",
            "\ndef multiply_tensors(tensors):\n    return tf.reduce_prod(tensors, axis=0)\n\ntensors = tf.constant([[2, 5], [3, 0], [8, -7]])\n"
        ],
        "target-program": "tf.multiply(in1, tf.expand_dims(in2, 1))",
        "description": "multiply tensors across the first axis",
        "tf_operators": {
            "tf.reduce_prod": 10,
            "tf.int32": 1,
            "tf.constant": 6
        },
        "coverage_percentage": 0.0,
        "total_in_target": 2,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_17",
        "completions": [
            "\ntensor = tf.constant([17, -32, 99])\n\noutput = tf.repeat(tensor, repeats=2)\n\n",
            "\ntensor = tf.constant([17, -32, 99])\n\noutput = tf.repeat(tensor, repeats=2)\n\n",
            "\ninput_tensor = tf.constant([17, -32, 99])\n\noutput_tensor = tf.repeat(input_tensor, repeats=2)\n\n",
            "\ntensor = tf.constant([17, -32, 99])\n\nduplicated_tensor = tf.repeat(tensor, repeats=2)\n\n",
            "\ninput_tensor = tf.constant([17, -32, 99])\n\noutput_tensor = tf.repeat(input_tensor, repeats=2)\n\n",
            "\ntensor = tf.constant([17, -32, 99])\n\noutput = tf.repeat(tensor, repeats=2)\n\n",
            "\ntensor = tf.constant([17, -32, 99])\n\noutput = tf.repeat(tensor, repeats=2)\n\n",
            "\ntensor = tf.constant([17, -32, 99])\n\nresult = tf.repeat(tensor, repeats=2)\n\n",
            "\ninput_list = [17, -32, 99]\n\ninput_tensor = tf.constant(input_list)\n\noutput_tensor = tf.repeat(input_tensor, repeats=2)\n\n",
            "\nx = tf.constant([17, -32, 99])\n\nresult = tf.repeat(x, repeats=2)\n\n"
        ],
        "target-program": "tf.stack((in1, in1), axis=1)",
        "description": "duplicate each element of a tensor",
        "tf_operators": {
            "tf.repeat": 10,
            "tf.constant": 10
        },
        "coverage_percentage": 0.0,
        "total_in_target": 1,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_18",
        "completions": [
            "\ntensor_3d = tf.constant([[[1, 1, 1], [1, 0, 1]], [[1, 2, 3], [4, 5, 6]]])\n\ntensor_2d = tf.constant([[1, 1, 1, 1], [1, 2, 3, 4], [5, 6, 7, 8]])\n\ntensor = tf.constant([[100, 200, 300, 400], [100, 200, 300, 400]])\n\ntensor_3d_reshaped = tf.reshape(tensor_3d, [tensor_3d.shape[0]*tensor_3d.shape[1], tensor_3d.shape[2]])\n\nresult = tf.matmul(tensor_3d_reshaped, tensor_2d)\n\nresult = tf.add(result, tensor)\n\n",
            "\ninput_data = [[[1, 1, 1], [1, 0, 1]], [[1, 2, 3], [4, 5, 6]]]\n\ntensor_3d = tf.constant(input_data)\n\ntensor_2d = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\n\nresult = tf.tensordot(tensor_3d, tensor_2d, axes=1)\n\nanother_tensor = tf.constant([[100, 200, 300, 400], [5, 6, 7, 8]])\n\nfinal_result = tf.add(result, another_tensor)\n\n",
            "\ntensor_3d = tf.constant([[[1, 1, 1], [1, 0, 1]], [[1, 2, 3], [4, 5, 6]]])\ntensor_2d = tf.constant([[1, 1, 1, 1], [1, 2, 3, 4], [5, 6, 7, 8]])\ntensor_add = tf.constant([[100, 200, 300, 400], [100, 200, 300, 400]])\n\nresult = tf.matmul(tensor_3d, tensor_2d)\n\nresult = tf.reduce_sum(result, axis=1)\n\nresult = tf.add(result, tensor_add)\n",
            "\ntensor1 = tf.constant([[[1, 1, 1], [1, 0, 1]], [[1, 2, 3], [4, 5, 6]]], dtype=tf.int32)\ntensor2 = tf.constant([[1, 1, 1, 1], [1, 2, 3, 4], [5, 6, 7, 8]], dtype=tf.int32)\ntensor3 = tf.constant([100, 200, 300, 400], dtype=tf.int32)\n\nresult = tf.add(tf.matmul(tensor1, tensor2), tensor3)\n\n",
            "\nt1 = tf.constant([[[1, 1, 1], [1, 0, 1]], [[1, 2, 3], [4, 5, 6]]])\nt2 = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]])\nt3 = tf.constant([[100, 200, 300, 400], [100, 200, 300, 400]])\n\nresult = tf.add(tf.tensordot(t1, t2, axes=1), t3)\n\n",
            "\ndef multiply_and_add_tensors(tensor_3d, tensor_2d, tensor_to_add):\n    result = []\n    for tensor in tensor_3d:\n        result.append(tf.matmul(tensor, tensor_2d))\n    result = tf.add(result, tensor_to_add)\n    return result\n",
            "\ntensor1 = tf.constant([[[1, 1, 1], [1, 0, 1]], [[1, 2, 3], [4, 5, 6]]], dtype=tf.int32)\ntensor2 = tf.constant([[1, 1, 1, 1], [1, 2, 3, 4], [5, 6, 7, 8]], dtype=tf.int32)\ntensor3 = tf.constant([100, 200, 300, 400], dtype=tf.int32)\n\nresult = tf.tensordot(tensor1, tensor2, axes=[[2], [0]])\n\nresult = tf.add(result, tensor3)\n\n",
            "\ntensor_3d = tf.constant([[[1, 1, 1], [1, 0, 1]], [[1, 2, 3], [4, 5, 6]]])\n\ntensor_2d = tf.constant([[1, 1, 1, 1], [1, 2, 3, 4], [5, 6, 7, 8]])\n\nmul_result = tf.tensordot(tensor_3d, tensor_2d, axes=[2, 1])\n\nadd_tensor = tf.constant([1, 2, 3, 4])\nresult = tf.add(mul_result, add_tensor)\n\n",
            "\ntensor3D = tf.constant([[[1, 1, 1], [1, 0, 1]], [[1, 2, 3], [4, 5, 6]]], dtype=tf.float32)\ntensor2D = tf.constant([[1, 1, 1, 1], [1, 2, 3, 4], [5, 6, 7, 8]], dtype=tf.float32)\ntensor_to_add = tf.constant([[100, 200, 300, 400]], dtype=tf.float32)\n\nresult = tf.matmul(tensor3D, tensor2D)\n\nresult = tf.add(result, tensor_to_add)\n\n",
            "\ntensor_3d = tf.constant([[[1, 1, 1], [1, 0, 1]], [[1, 2, 3], [4, 5, 6]]])\ntensor_2d = tf.constant([[1, 1, 1, 1], [1, 2, 3, 4], [5, 6, 7, 8]])\ntensor_to_add = tf.constant([[100, 200, 300, 400]])\n\ntensor_mul = tf.tensordot(tensor_3d, tensor_2d, axes=1)\n\nresult = tf.add(tensor_mul, tensor_to_add)\n\n"
        ],
        "target-program": "tf.add(in3, tf.matmul(in1, in2))",
        "description": "multiply 3D tensor and 2D tensor and add another tensor",
        "tf_operators": {
            "tf.add": 10,
            "tf.reshape": 1,
            "tf.matmul": 5,
            "tf.constant": 9,
            "tf.tensordot": 5,
            "tf.reduce_sum": 1,
            "tf.int32": 2,
            "tf.float32": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 2,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_19",
        "completions": [
            "\ntensor = tf.constant([[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]])\n\nsorted_indices = tf.argsort(tensor[:, :2], axis=0, stable=True)\n\nsorted_tensor = tf.gather(tensor, sorted_indices[:, 0])\n\noutput = sorted_tensor[0]\n\n",
            "\ndata = [[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]]\n\ntensor = tf.constant(data)\n\nsorted_indices = tf.argsort(tensor, axis=0)\n\nsorted_tensor = tf.gather(tensor, sorted_indices[:, 0])\n\nfirst_row = sorted_tensor[0]\n\n",
            "\nx = tf.constant([[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]])\n\nindices = tf.argsort(x[:, 0])\n\nindices = tf.argsort(x[indices, 1])\n\nsorted_x = tf.gather(x, indices)\n\n",
            "\ndata = [[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]]\n\ntensor = tf.constant(data)\n\nindices = tf.argsort(tensor[:, :2], axis=0, stable=True)\n\nsorted_tensor = tf.gather(tensor, indices[:, 0])\n\noutput = sorted_tensor[0]\n\n",
            "\ndata = [[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]]\n\ntensor = tf.constant(data)\n\nmax_val = tf.reduce_max(tensor[:, 1])\n\nconcat_tensor = tensor[:, 0] * max_val + tensor[:, 1]\n\nsorted_indices = tf.argsort(concat_tensor)\n\nsorted_tensor = tf.gather(tensor, sorted_indices)\n\noutput = sorted_tensor[0]\n\n",
            "\ntensor = tf.constant([[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]], dtype=tf.float32)\n\nsort_tensor = tensor[:, 0] + 1e-10 * tensor[:, 1]\n\nindices = tf.argsort(sort_tensor)\n\nsorted_tensor = tf.gather(tensor, indices)\n\noutput = sorted_tensor[0]\n\n",
            "\nlst = [[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]]\n\ntensor = tf.constant(lst)\n\ncombined = tf.cast(tensor[:, 0], tf.float32) + 1e-10 * tf.cast(tensor[:, 1], tf.float32)\n\nsorted_indices = tf.argsort(combined)\n\nsorted_tensor = tf.gather(tensor, sorted_indices)\n\n",
            "\ndata = [[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]]\n\ntensor = tf.constant(data)\n\nsorted_indices = tf.argsort(tensor)\n\nsorted_tensor = tf.gather(tensor, sorted_indices)\n\noutput = sorted_tensor[0]\n",
            "\ninput_data = [[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]]\n\ntensor = tf.constant(input_data)\n\nsorted_indices = tf.argsort(tf.argsort(tensor[:, 0], stable=True) + tf.argsort(tensor[:, 1], stable=True))\n\nsorted_tensor = tf.gather(tensor, sorted_indices)\n\n",
            "\ntensor = tf.constant([[3, 1, 2], [1, 0, 4], [1, 2, 3], [0, 5, 1], [1, 1, 2], [2, 3, 1], [2, 1, 0]])\n\nindices = tf.argsort(tf.argsort(tensor[:, 1]), direction='ASCENDING')\nsorted_tensor = tf.gather(tensor, indices)\n\noutput = sorted_tensor[0]\n\n"
        ],
        "target-program": "tf.gather(tf.gather(in1, tf.argsort(in1[:, 1], stable=True)), tf.argsort(tf.gather(in1, tf.argsort(in1[:, 1], stable=True))[:, 0], stable=True))",
        "description": "(\\'sort a tensor considering the first column, breaking ties using the second column\\')",
        "tf_operators": {
            "tf.argsort": 10,
            "tf.gather": 10,
            "tf.constant": 10,
            "tf.reduce_max": 1,
            "tf.float32": 2,
            "tf.cast": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 2,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_20",
        "completions": [
            "\ndata = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\n\ntensor = tf.constant(data)\n\nargmax_indices = tf.argmax(tensor, axis=1)\n\nindices = tf.stack([tf.range(tf.shape(argmax_indices)[0]), argmax_indices], axis=1)\n\nnew_tensor = tf.zeros_like(tensor)\n\nresult = tf.tensor_scatter_nd_update(new_tensor, indices, tf.ones(tf.shape(argmax_indices), dtype=tensor.dtype))\n\n",
            "\ninput_tensor = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\n\nargmax_tensor = tf.argmax(input_tensor, axis=1)\n\noutput_tensor = tf.one_hot(argmax_tensor, depth=3)\n\noutput_array = output_tensor.numpy()\n\n",
            "\ndata = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\n\ntensor = tf.constant(data)\n\nindices = tf.argmax(tensor, axis=1)\n\nzeros = tf.zeros([len(data), len(data[0])], tf.int32)\n\nresult = tf.tensor_scatter_nd_update(zeros, tf.reshape(indices, [-1, 1]), tf.ones([len(indices)], tf.int32))\n\n",
            "\ndef set_argmax_to_one(input):\n    tensor = tf.constant(input)\n    max_indices = tf.argmax(tensor, axis=1)\n    result = tf.one_hot(max_indices, depth=tensor.shape[1])\n    return result\n\ninput = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\n",
            "\ndef set_argmax_to_one(input):\n    tensor = tf.constant(input)\n    argmax_indices = tf.argmax(tensor, axis=1)\n    one_hot = tf.one_hot(argmax_indices, depth=tensor.shape[1])\n    return one_hot\n\ninput = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\n",
            "\ndef compute_argmax_and_set_to_one(input_list):\n    tensor = tf.constant(input_list)\n    max_indices = tf.argmax(tensor, axis=1)\n    one_hot = tf.one_hot(max_indices, tf.shape(input_list)[1])\n    output = tf.reduce_sum(one_hot, axis=0)\n    return tf.cast(output, dtype=tf.int32)\n\ninput_list = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\n",
            "\ndata = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\n\ndata_tensor = tf.constant(data)\n\nmax_indices = tf.argmax(data_tensor, axis=1)\n\none_hot_tensor = tf.one_hot(max_indices, depth=data_tensor.shape[1])\n\nresult = tf.reduce_sum(one_hot_tensor, axis=0)\n\n",
            "\ndef set_argmax_to_one(tensor):\n    indices = tf.argmax(tensor, axis=1)\n    one_hot = tf.one_hot(indices, depth=tensor.shape[1])\n    return one_hot\n\ntensor = tf.constant([[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]])\noutput = set_argmax_to_one(tensor)\n",
            "\ndef set_argmax_to_one(input_list):\n    tensor = tf.constant(input_list)\n    max_indices = tf.argmax(tensor, axis=1)\n    one_hot = tf.one_hot(max_indices, depth=tensor.shape[1])\n    return one_hot\n\ninput_list = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\noutput = set_argmax_to_one(input_list)\n",
            "\ndef set_argmax_to_one(input):\n    tensor = tf.constant(input)\n    argmax = tf.argmax(tensor, axis=1)\n    one_hot = tf.one_hot(argmax, depth=tensor.shape[1], on_value=1, off_value=0)\n    output = one_hot.numpy().tolist()\n    return output\n\ninput = [[0.7, 0.2, 0.1], [0.4, 0.5, 0.1], [0.4, 0.4, 0.2], [0.3, 0.4, 0.3], [0.0, 0.0, 1.0]]\n"
        ],
        "target-program": "tf.cast(tf.one_hot(tf.argmax(in1, axis=1), 3), tf.int32)",
        "description": "compute argmax in each tensor and set it to 1",
        "tf_operators": {
            "tf.ones": 2,
            "tf.stack": 1,
            "tf.range": 1,
            "tf.argmax": 10,
            "tf.shape": 2,
            "tf.tensor_scatter_nd_update": 2,
            "tf.zeros_like": 1,
            "tf.constant": 9,
            "tf.one_hot": 8,
            "tf.reshape": 1,
            "tf.int32": 2,
            "tf.zeros": 1,
            "tf.cast": 1,
            "tf.reduce_sum": 2
        },
        "coverage_percentage": 100.0,
        "total_in_target": 4,
        "total_covered": 4
    },
    {
        "task_id": "stackoverflow_21",
        "completions": [
            "\nindices = tf.constant([[2], [0], [1], [0]])\nparams = tf.constant([[0.2, 0.5, 0.3], [0.1, 0.3, 0.6], [0.1, 0.6, 0.3], [0.7, 0.0, 0.3]])\n\noutput = tf.gather(params, indices, axis=1)\n",
            "\ndef gather_elements(tensor, indices):\n    return tf.gather(tensor, indices, axis=1)\n\ntensor = tf.constant([[0.2, 0.5, 0.3], [0.1, 0.3, 0.6], [0.1, 0.6, 0.3], [0.7, 0.0, 0.3]])\nindices = tf.constant([[2], [0], [1], [0]])\n",
            "\ndata = tf.constant([[0.2, 0.5, 0.3], [0.1, 0.3, 0.6], [0.1, 0.6, 0.3], [0.7, 0.0, 0.3]])\nindices = tf.constant([[2], [0], [1], [0]])\n\noutput = tf.gather(data, indices, axis=1)\n\n",
            "\ndef gather_elements(input_tensor, indices):\n    return tf.gather_nd(input_tensor, indices)\n",
            "\nparams = tf.constant([[0.2, 0.5, 0.3], [0.1, 0.3, 0.6], [0.1, 0.6, 0.3], [0.7, 0.0, 0.3]])\n\nindices = tf.constant([[2], [0], [1], [0]])\n\nresult = tf.gather(params, indices, axis=1)\n\n",
            "\ntensor = tf.constant([[0.2, 0.5, 0.3], [0.1, 0.3, 0.6], [0.1, 0.6, 0.3], [0.7, 0.0, 0.3]])\nindices = tf.constant([[0], [0], [1], [0]])\n\noutput = tf.gather_nd(tensor, indices)\n\n",
            "\ninput_data = tf.constant([[0.2, 0.5, 0.3], [0.1, 0.3, 0.6], [0.1, 0.6, 0.3], [0.7, 0.0, 0.3]])\nindices = tf.constant([[2], [0], [1], [0]])\n\noutput = tf.gather(input_data, indices, axis=1)\n\n",
            "\ndef gather_elements(input_tensor, indices):\n    return tf.gather(input_tensor, indices, axis=1)\n\ninput_tensor = tf.constant([[0.2, 0.5, 0.3], [0.1, 0.3, 0.6], [0.1, 0.6, 0.3], [0.7, 0.0, 0.3]])\nindices = tf.constant([[2], [0], [1], [0]])\n\noutput = gather_elements(input_tensor, indices)\n",
            "\nparams = tf.constant([0.3, 0.1, 0.7])\n\nindices = tf.constant([[2], [0], [1], [0]])\n\nresult = tf.gather(params, indices)\n\n",
            "\ndef gather_elements(tensor, indices):\n    return tf.gather(tensor, indices, axis=1)\n\ntensor = tf.constant([[0.2, 0.5, 0.3], [0.1, 0.3, 0.6], [0.1, 0.6, 0.3], [0.7, 0.0, 0.3]])\nindices = tf.constant([[2], [0], [1], [0]])\n"
        ],
        "target-program": "tf.gather(in2, in1, axis=1, batch_dims=1)",
        "description": "gather elements in a tensor along axis 1",
        "tf_operators": {
            "tf.gather": 8,
            "tf.constant": 9,
            "tf.gather_nd": 2
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_22",
        "completions": [
            "\ndef multiply_vector_matrix(vector, matrix):\n    return tf.tensordot(vector, matrix, axes=1)\n",
            "\nv = tf.constant([3, 1, 10], dtype=tf.float32)\n\nm = tf.constant([[0.6, 0.4], [0.5, 1.0], [3.0, 4.0]], dtype=tf.float32)\n\nresult = tf.tensordot(v, m, axes=[-1, 1])\n\n",
            "\ndef multiply_vector_matrix(vector, matrix):\n    return tf.tensordot(vector, matrix, axes=1)\n\nvector = tf.constant([3, 1, 10], dtype=tf.float32)\nmatrix = tf.constant([[0.6, 0.4], [0.5, 1.0], [3.0, 4.0]], dtype=tf.float32)\nresult = multiply_vector_matrix(vector, matrix)\n",
            "\nvector = tf.constant([3, 1, 10], dtype=tf.float32)\nmatrix = tf.constant([[0.6, 0.4], [0.5, 1.0], [3.0, 4.0]], dtype=tf.float32)\n\nresult = tf.linalg.matvec(matrix, vector)\n\n",
            "\nvector = tf.constant([3, 1, 10], dtype=tf.float32)\n\nmatrix = tf.constant([[0.6, 0.4], [0.5, 1.0], [3.0, 4.0]], dtype=tf.float32)\n\nresult = tf.linalg.matvec(matrix, vector)\n\n",
            "\nv = tf.constant([3, 1, 10])\n\nm = tf.constant([[0.6, 0.4], [0.5, 1.0], [3.0, 4.0]])\n\nresult = tf.tensordot(v, m, axes=0)\n\n",
            "\ndef multiply_vector_matrix(vector, matrix):\n    return tf.tensordot(vector, matrix, axes=1)\n\nvector = tf.constant([3, 1, 10], dtype=tf.float32)\nmatrix = tf.constant([[0.6, 0.4], [0.5, 1.0], [3.0, 4.0]], dtype=tf.float32)\n\noutput = multiply_vector_matrix(vector, matrix)\n",
            "\nvector = tf.constant([3, 1, 10])\nmatrix = tf.constant([[0.6, 0.4], [0.5, 1.0], [3.0, 4.0]])\n\nresult = tf.tensordot(vector, matrix, axes=[[0], [0]])\n\n",
            "\nvector = tf.constant([3, 1, 10], dtype=tf.float32)\nmatrix = tf.constant([[0.6, 0.4], [0.5, 1.0], [3.0, 4.0]], dtype=tf.float32)\n\nresult = tf.tensordot(vector, matrix, axes=1)\n\n",
            "\ndef multiply_vector_matrix(vector, matrix):\n    return tf.tensordot(vector, matrix, [[0], [1]])\n\nvector = tf.constant([3, 1, 10], dtype=tf.float32)\nmatrix = tf.constant([[0.6, 0.4], [0.5, 1.0], [3.0, 4.0]], dtype=tf.float32)\n\noutput = multiply_vector_matrix(vector, matrix)\n"
        ],
        "target-program": "tf.tensordot(tf.cast(in1, tf.float32), in2, 1)",
        "description": "multiply a vector with a matrix without reshaping the vector",
        "tf_operators": {
            "tf.tensordot": 8,
            "tf.float32": 7,
            "tf.constant": 9,
            "tf.linalg.matvec": 2
        },
        "coverage_percentage": 66.66666666666666,
        "total_in_target": 3,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_23",
        "completions": [
            "\ndef place_ones(indices):\n    indices = tf.constant(indices)\n    updates = tf.ones(tf.shape(indices)[0], dtype=tf.int32)\n    shape = tf.reduce_max(indices) + 1\n    tensor = tf.scatter_nd(indices, updates, [shape])\n    tensor = tf.reshape(tensor, [-1])\n    return tensor\n\nindices = [[0, 5, 2], [3, 1, 4], [5, 1, 5]]\n",
            "\ndef place_ones_at_indices(input):\n    tensor = tf.constant(input)\n    flat_tensor = tf.reshape(tensor, [-1])\n    counts = tf.math.bincount(flat_tensor)\n    mask = tf.greater(counts, 0)\n    result = tf.cast(mask, tf.int32)\n    return result\n\ninput = [[0, 5, 2], [3, 1, 4], [5, 1, 5]]\n",
            "\ndef one_hot_indices(input_tensor):\n    flat_input = tf.reshape(input_tensor, [-1])\n    depth = tf.reduce_max(flat_input) + 1\n    one_hot_tensor = tf.one_hot(flat_input, depth)\n    return tf.reduce_sum(one_hot_tensor, axis=0)\n\ninput_tensor = tf.constant([[0, 5, 2], [3, 1, 4], [5, 1, 5]])\noutput_tensor = one_hot_indices(input_tensor)\n",
            "\ndef place_ones_at_indices(indices):\n    indices = tf.reshape(indices, [-1, 1])\n    updates = tf.ones(tf.shape(indices)[0], dtype=tf.int32)\n    shape = [tf.reduce_max(indices) + 1]\n    result = tf.scatter_nd(indices, updates, shape)\n    return result\n\nindices = tf.constant([[0, 5, 2], [3, 1, 4], [5, 1, 5]])\n",
            "\ndef place_ones_at_indices(input_tensor):\n    indices = tf.reshape(input_tensor, [-1, 1])\n    updates = tf.ones_like(indices, dtype=tf.float32)\n    max_element = tf.reduce_max(input_tensor)\n    output = tf.scatter_nd(indices, updates, [max_element + 1])\n    return output\n\ninput_tensor = tf.constant([[0, 5, 2], [3, 1, 4], [5, 1, 5]])\noutput = place_ones_at_indices(input_tensor)\n",
            "\ndef place_ones_at_indices(input_tensor):\n    max_index = tf.reduce_max(input_tensor)\n    tensor = tf.zeros([max_index + 1], dtype=tf.int32)\n    updates = tf.ones_like(input_tensor)\n    tensor = tf.tensor_scatter_nd_update(tensor, input_tensor, updates)\n    return tf.reshape(tensor, [-1])\n\ninput_tensor = tf.constant([[0, 5, 2], [3, 1, 4], [5, 1, 5]])\noutput_tensor = place_ones_at_indices(input_tensor)\n",
            "\ndef place_ones(indices):\n    flat_indices = tf.reshape(indices, [-1])\n    depth = tf.reduce_max(flat_indices) + 1\n    one_hot = tf.one_hot(flat_indices, depth, on_value=1, off_value=0)\n    output = tf.reduce_max(one_hot, axis=0)\n    return output\n\nindices = tf.constant([[0, 5, 2], [3, 1, 4], [5, 1, 5]])\n",
            "\ndef place_ones_at_indices(input_tensor):\n    max_val = tf.reduce_max(input_tensor)\n    zeros_tensor = tf.zeros(max_val+1, dtype=tf.int32)\n    flat_indices = tf.reshape(input_tensor, [-1, 1])\n    ones_updates = tf.ones_like(flat_indices, dtype=tf.int32)\n    output_tensor = tf.tensor_scatter_nd_update(zeros_tensor, flat_indices, ones_updates)\n    return output_tensor\n\ninput_tensor = tf.constant([[0, 5, 2], [3, 1, 4], [5, 1, 5]])\n",
            "\ndef place_ones_at_indices(input):\n    flat_indices = tf.constant([item for sublist in input for item in sublist])\n    max_index = tf.reduce_max(flat_indices)\n    initial_tensor = tf.zeros(max_index + 1, dtype=tf.int32)\n    indices = tf.reshape(flat_indices, [-1, 1])\n    updates = tf.ones_like(flat_indices, dtype=tf.int32)\n    output = tf.tensor_scatter_nd_update(initial_tensor, indices, updates)\n    return output\n\ninput = [[0, 5, 2], [3, 1, 4], [5, 1, 5]]\n",
            "\ndef place_ones_at_indices(input_tensor):\n    max_val = tf.reduce_max(input_tensor)\n    zeros = tf.zeros([max_val+1], tf.int32)\n    indices = tf.reshape(input_tensor, [-1, 1])\n    updates = tf.ones(tf.shape(indices)[0], tf.int32)\n    result = tf.tensor_scatter_nd_update(zeros, indices, updates)\n    return result\n\ninput_tensor = tf.constant([[0, 5, 2], [3, 1, 4], [5, 1, 5]])\noutput = place_ones_at_indices(input_tensor)\n"
        ],
        "target-program": "tf.cast(tf.reduce_max(tf.one_hot(in1, 9), axis=1), tf.int32)",
        "description": "place 1 at the indices in the input tensor",
        "tf_operators": {
            "tf.ones": 3,
            "tf.reduce_max": 9,
            "tf.reshape": 10,
            "tf.int32": 7,
            "tf.scatter_nd": 3,
            "tf.shape": 3,
            "tf.constant": 10,
            "tf.cast": 1,
            "tf.greater": 1,
            "tf.math.bincount": 1,
            "tf.reduce_sum": 1,
            "tf.one_hot": 2,
            "tf.float32": 1,
            "tf.ones_like": 4,
            "tf.zeros": 4,
            "tf.tensor_scatter_nd_update": 4
        },
        "coverage_percentage": 100.0,
        "total_in_target": 4,
        "total_covered": 4
    },
    {
        "task_id": "stackoverflow_24",
        "completions": [
            "\ndef custom_divide(input_list):\n    numerator = tf.constant(input_list)\n    denominator = tf.constant([0.5, 0.0, -2.0, 0.0, 1.0, -1.0, 0.0, 2.0])\n    result = tf.math.divide_no_nan(numerator, denominator)\n    result = tf.subtract(numerator, result)\n    return tf.reduce_sum(result).numpy()\n\n",
            "\ndef safe_divide(numerator, denominator):\n    result = tf.math.divide_no_nan(numerator, denominator)\n    return result * denominator + numerator * tf.cast(tf.equal(denominator, 0), numerator.dtype)\n",
            "\ndef safe_divide(x, y):\n    y = tf.where(tf.equal(y, 0), x, y)\n    return tf.math.divide_no_nan(x, y)\n",
            "\ndef safe_divide(x, y):\n    return tf.math.divide_no_nan(x, y)\n",
            "\ndef safe_division(numerator, denominator):\n    numerator_tensor = tf.constant(numerator)\n    denominator_tensor = tf.constant(denominator)\n    result = tf.math.divide_no_nan(numerator_tensor, denominator_tensor)\n    return tf.reduce_sum(result).numpy()\n\n",
            "\ndef divide_no_nan_sum(list1, list2):\n    tensor1 = tf.constant(list1)\n    tensor2 = tf.constant(list2)\n    division_result = tf.math.divide_no_nan(tensor1, tensor2)\n    return tf.reduce_sum(division_result)\n",
            "\ndef safe_divide(numerator, denominator):\n    division = tf.math.divide_no_nan(numerator, denominator)\n    return tf.where(denominator == 0, numerator, division)\n\nnumerator = tf.constant([3.0, 1.0, 4.0, 5.0, 2.0, 8.0, -6.0, -7.0])\ndenominator = tf.constant([0.5, 0.0, -2.0, 0.0, 1.0, -1.0, 0.0, 2.0])\n\n",
            "\ndef safe_divide(x, y):\n    return tf.math.divide_no_nan(x, y)\n",
            "\ndef divide_no_nan_return_numerator(numerator, denominator):\n    division = tf.math.divide_no_nan(numerator, denominator)\n    result = tf.where(tf.equal(denominator, 0), numerator, division)\n    return tf.reduce_sum(result)\n\nnumerator = tf.constant([3.0, 1.0, 4.0, 5.0, 2.0, 8.0, -6.0, -7.0])\ndenominator = tf.constant([0.5, 0.0, -2.0, 0.0, 1.0, -1.0, 0.0, 2.0])\n",
            "\ndef divide_no_nan_and_sum(x, y):\n    x = tf.constant(x)\n    y = tf.constant(y)\n    result = tf.math.divide_no_nan(x, y)\n    return tf.reduce_sum(result)\n"
        ],
        "target-program": "tf.where(tf.cast(in2, tf.bool), x=tf.divide(in1, in2), y=in1)",
        "description": "(\\'like tf.divide(), but when dividing by 0, return the numerator\\')",
        "tf_operators": {
            "tf.math.divide_no_nan": 10,
            "tf.reduce_sum": 5,
            "tf.subtract": 1,
            "tf.constant": 6,
            "tf.cast": 1,
            "tf.equal": 3,
            "tf.where": 3
        },
        "coverage_percentage": 50.0,
        "total_in_target": 4,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_25",
        "completions": [
            "\ntensor = tf.eye(3)\n\ntensor = tf.expand_dims(tensor, 0)\n\nresult = tf.tile(tensor, [4, 1, 1])\n\n",
            "\nidentity_matrix = tf.eye(3)\n\nresult = tf.tile(identity_matrix, [4, 1])\n\n",
            "\nidentity_matrix = tf.eye(3)\n\nidentity_matrix = tf.reshape(identity_matrix, [1, 3, 3])\n\nresult = tf.tile(identity_matrix, [4, 1, 1])\n\n",
            "\ntensor = tf.eye(3)\n\ntensor = tf.expand_dims(tensor, axis=0)\n\nresult = tf.tile(tensor, multiples=[4, 1, 1])\n\n",
            "\nidentity = tf.eye(3)\n\noutput = tf.tile(tf.expand_dims(identity, 0), [4, 1, 1])\n\n",
            "\nidentity_matrix = tf.eye(3)\n\nreplicated_matrix = tf.tile(tf.expand_dims(identity_matrix, 0), [4, 1, 1])\n\n",
            "\neye_tensor = tf.eye(3)\n\ntiled_tensor = tf.tile(eye_tensor, [4, 1])\n\n",
            "\nidentity_matrix = tf.eye(3)\n\ntiled_identity_matrix = tf.tile(tf.expand_dims(identity_matrix, 0), [4, 1, 1])\n\n",
            "\ndef copy_tensor(n):\n    tensor = tf.eye(n)\n    copied_tensor = tf.tile(tensor, [4, 1])\n    return copied_tensor\n\n",
            "\nidentity_matrix = tf.eye(3)\n\nresult = tf.tile(identity_matrix, [4, 1])\n\n"
        ],
        "target-program": "tf.tile(tf.eye(in1), (in2, 1))",
        "description": "copy the tensor tf.eye(3), 4 times",
        "tf_operators": {
            "tf.eye": 10,
            "tf.expand_dims": 5,
            "tf.tile": 10,
            "tf.reshape": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 2,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_26",
        "completions": [
            "\ndata = [[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]]\n\ntensor_data = tf.constant(data)\n\nmax_value = tf.reduce_max(tensor_data)\n\n",
            "\nlst = [[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]]\n\ntensor = tf.constant(lst)\n\nmax_value = tf.reduce_max(tensor)\n\n",
            "\ndata = [[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]]\n\ntensor = tf.constant(data)\n\nmax_value = tf.reduce_max(tensor)\n\n",
            "\ntensor = tf.constant([[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]])\n\nresult = tf.reduce_max(tensor)\n\n",
            "\ninput_tensor = tf.constant([[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]])\n\noutput = tf.reduce_max(input_tensor)\n\n",
            "\ninput_tensor = tf.constant([[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]])\n\noutput = tf.reduce_max(input_tensor)\n\n",
            "\nx = [[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]]\n\ntensor = tf.constant(x)\n\noutput = tf.reduce_max(tensor)\n\n",
            "\ntensor = tf.constant([[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]])\n\nmax_value = tf.reduce_max(tensor)\n\n",
            "\ntensor = tf.constant([[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]])\n\nmax_value = tf.reduce_max(tensor, axis=[0, 1, 2])\n\n",
            "\ninput_tensor = tf.constant([[[3, 4], [1, 2]], [[5, -2], [-10, 3]], [[10, 20], [-4, 7]]])\n\noutput = tf.reduce_max(input_tensor)\n"
        ],
        "target-program": "tf.reduce_sum(tf.reduce_sum(in1, axis=1), axis=1)",
        "description": "reduction operation for multiple dimensions simultaneously",
        "tf_operators": {
            "tf.reduce_max": 10,
            "tf.constant": 10
        },
        "coverage_percentage": 0.0,
        "total_in_target": 1,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_27",
        "completions": [
            "\ndef boolean_tensor(indices):\n    depth = tf.reduce_max(indices) + 1\n    one_hot_tensor = tf.one_hot(indices, depth)\n    return tf.reduce_any(one_hot_tensor, 0)\n",
            "\ndef create_boolean_tensor(indices):\n    max_index = tf.reduce_max(indices)\n    result = tf.one_hot(indices, depth=max_index+1)\n    return result\n",
            "\ndef boolean_tensor(indices):\n    max_index = tf.reduce_max(indices)\n    return tf.one_hot(indices, max_index+1)\n",
            "\ndef create_boolean_tensor(indices):\n    max_index = tf.reduce_max(indices)\n    return tf.one_hot(indices, depth=max_index+1)\n",
            "\ndef one_hot_tensor(indices):\n    depth = tf.reduce_max(indices) + 1\n    return tf.one_hot(indices, depth)\n",
            "\ndef boolean_tensor(indices):\n    one_hot_tensor = tf.one_hot(indices, depth=10, on_value=1, off_value=0)\n    result = tf.reduce_any(one_hot_tensor)\n    return result\n\n",
            "\ndef boolean_tensor(indices):\n    depth = tf.reduce_max(indices) + 1\n    one_hot_tensor = tf.one_hot(indices, depth, on_value=1, off_value=0)\n    result = tf.reduce_any(one_hot_tensor, axis=0)\n    return result\n\nindices = tf.constant([0, 3, 5, 6])\noutput = boolean_tensor(indices)\n",
            "\ndef one_hot_tensor(indices):\n    depth = tf.reduce_max(indices) + 1\n    one_hot = tf.one_hot(indices, depth)\n    boolean_tensor = tf.reduce_any(one_hot, axis=0)\n    return tf.cast(boolean_tensor, tf.int32)\n\n",
            "\ndef boolean_tensor(indices):\n    depth = tf.reduce_max(indices) + 1\n    return tf.one_hot(indices, depth)\n\nindices = tf.constant([0, 3, 5, 6])\n\nindices = tf.constant([8])\n",
            "\ndef boolean_tensor(indices):\n    depth = tf.reduce_max(indices) + 1\n    return tf.one_hot(indices, depth)\n"
        ],
        "target-program": "tf.cast(tf.reduce_max(tf.one_hot(in1, in2), axis=0), tf.int32)",
        "description": "boolean tensor with 1 at the indices in the input tensor",
        "tf_operators": {
            "tf.reduce_any": 4,
            "tf.one_hot": 10,
            "tf.reduce_max": 9,
            "tf.constant": 2,
            "tf.cast": 1,
            "tf.int32": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 4,
        "total_covered": 4
    },
    {
        "task_id": "stackoverflow_28",
        "completions": [
            "\ndef extract_columns(tensor, indices):\n    tensor = tf.constant(tensor)\n    indices = tf.constant(indices)\n    return tf.gather(tensor, indices, axis=2)\n\ntensor = [[[5, 3], [0, 2]], [[7, 4], [5, 1]], [[10, 20], [15, 30]], [[11, 16], [14, 12]], [[-2, -7], [-4, 6]]]\nindices = [1, 0, 1, 1, 0]\n\n",
            "\ndef extract_columns(tensor, indices):\n    tensor = tf.constant(tensor)\n    indices = tf.constant(indices)\n    indices = tf.stack([tf.range(tf.shape(indices)[0]), indices], axis=1)\n    return tf.gather_nd(tensor, indices)\n\ntensor = [[[5, 3], [0, 2]], [[7, 4], [5, 1]], [[10, 20], [15, 30]], [[11, 16], [14, 12]], [[-2, -7], [-4, 6]]]\nindices = [1, 0, 1, 1, 0]\n",
            "\ntensor = tf.constant([[[5, 3], [0, 2]], [[7, 4], [5, 1]], [[10, 20], [15, 30]], [[11, 16], [14, 12]], [[-2, -7], [-4, 6]]])\n\nindices = tf.constant([1, 0, 1, 1, 0])\n\noutput = tf.gather(tensor, indices, axis=1)\n\n",
            "\ntensor_3d = tf.constant([[[5, 3], [0, 2]], [[7, 4], [5, 1]], [[10, 20], [15, 30]], [[11, 16], [14, 12]], [[-2, -7], [-4, 6]]])\n\ncolumn_indices = tf.constant([1, 0, 1, 1, 0])\n\nextracted_columns = tf.gather(tensor_3d, column_indices, axis=2)\n\n",
            "\ndata = [[[5, 3], [0, 2]], [[7, 4], [5, 1]], [[10, 20], [15, 30]], [[11, 16], [14, 12]], [[-2, -7], [-4, 6]]]\nindices = [1, 0, 1, 1, 0]\n\ntensor = tf.constant(data)\n\nresult = tf.gather(tensor, indices, axis=2)\n\n",
            "\ndef extract_columns(tensor, indices):\n    tensor = tf.constant(tensor)\n    indices = tf.constant(indices)\n    return tf.gather(tensor, indices, axis=2)\n",
            "\ndef extract_columns(tensor, indices):\n    return tf.gather(tensor, indices, axis=2)\n\ntensor = tf.constant([[[5, 3], [0, 2]], [[7, 4], [5, 1]], [[10, 20], [15, 30]], [[11, 16], [14, 12]], [[-2, -7], [-4, 6]]])\nindices = [1, 0, 1, 1, 0]\n",
            "\ndef extract_columns(tensor_3d, column_indices):\n    tensor_3d = tf.constant(tensor_3d)\n    column_indices = tf.constant(column_indices)\n    selected_columns = tf.gather(tensor_3d, column_indices, axis=1)\n    selected_columns = tf.squeeze(selected_columns)\n    return selected_columns.numpy().tolist()\n",
            "\ntensor = tf.constant([[[5, 3], [0, 2]], [[7, 4], [5, 1]], [[10, 20], [15, 30]], [[11, 16], [14, 12]], [[-2, -7], [-4, 6]]])\nindices = tf.constant([1, 0, 1, 1, 0])\n\nresult = tf.gather(tensor, indices, axis=2)\n\n",
            "\ndef extract_columns(tensor_3d, column_indices):\n    tensor_3d = tf.constant(tensor_3d)\n    column_indices = tf.constant(column_indices)\n    output = tf.gather(tensor_3d, column_indices, axis=2)\n    return output.numpy().tolist()\n\ntensor_3d = [[[5, 3], [0, 2]], [[7, 4], [5, 1]], [[10, 20], [15, 30]], [[11, 16], [14, 12]], [[-2, -7], [-4, 6]]]\ncolumn_indices = [1, 0, 1, 1, 0]\n"
        ],
        "target-program": "tf.squeeze(tf.gather(in1, tf.expand_dims(in2, 1), axis=-1, batch_dims=1))",
        "description": "extract columns from a 3D tensor given column indices",
        "tf_operators": {
            "tf.gather": 9,
            "tf.constant": 10,
            "tf.stack": 1,
            "tf.range": 1,
            "tf.shape": 1,
            "tf.gather_nd": 1,
            "tf.squeeze": 1
        },
        "coverage_percentage": 66.66666666666666,
        "total_in_target": 3,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_29",
        "completions": [
            "\ndef place_values_into_buckets(values):\n    value_range = tf.constant([-1.0, 1.0], dtype=tf.float32)\n    nbins = tf.constant(10, dtype=tf.int32)\n    bin_indices = tf.histogram_fixed_width_bins(values, value_range, nbins)\n    return tf.reduce_max(bin_indices)\n\nvalues = tf.constant([-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0], dtype=tf.float32)\n\nvalues = tf.constant([0.1, -10, -0.1, 1.1, 0.41], dtype=tf.float32)\n",
            "\ndef find_max_bin_index(values):\n    bin_indices = tf.histogram_fixed_width_bins(values, value_range=[-1, 1], nbins=10)\n    max_bin_index = tf.reduce_max(bin_indices)\n    return max_bin_index.numpy()\n\n",
            "\ndef bucket_values(values):\n    values = tf.constant(values)\n    bin_indices = tf.histogram_fixed_width_bins(values, value_range=[-1.0, 1.0], nbins=10)\n    unique_bins = tf.unique_with_counts(bin_indices).count\n    return unique_bins.numpy()\n",
            "\ndef place_values_into_buckets(values):\n    # Define the bucket boundaries\n    bucket_boundaries = tf.constant([-1.0, -0.5, 0.0, 0.5, 1.0], dtype=tf.float32)\n\n    # Compute the bin indices for each value in the input\n    bin_indices = tf.histogram_fixed_width_bins(values, tf.range(tf.reduce_min(bucket_boundaries), tf.reduce_max(bucket_boundaries), delta=0.5), len(bucket_boundaries) - 1)\n\n    # Compute the sum of all bin indices\n    output = tf.reduce_sum(bin_indices)\n\n    return output\n",
            "\ndef bucket_indices(values):\n    values_tensor = tf.constant(values, dtype=tf.float32)\n    value_range = tf.constant([-1.0, 1.0], dtype=tf.float32)\n    nbins = tf.constant(10, dtype=tf.int32)\n    bins = tf.histogram_fixed_width_bins(values_tensor, value_range, nbins)\n    _, _, count = tf.unique_with_counts(bins)\n    return count[0].numpy()\n\n",
            "\ndef bucket_values(values):\n  boundaries = tf.constant([-1.0, -0.5, 0.0, 0.5, 1.0])\n  input_values = tf.constant(values)\n  bin_indices = tf.histogram_fixed_width_bins(input_values, boundaries, dtype=tf.dtypes.int32)\n  return tf.size(tf.unique(bin_indices).y)\n\n",
            "\ndef max_bucket_count(values):\n    # Define the bucket boundaries\n    boundaries = [-1.0, -0.5, 0.0, 0.5, 1.0]\n    \n    # Compute the bucket indices for each value\n    bucket_indices = tf.histogram_fixed_width_bins(values, boundaries, dtype=tf.int32)\n    \n    # Count the frequency of each bucket index\n    bucket_counts = tf.math.bincount(bucket_indices)\n    \n    # Find the maximum count\n    max_count = tf.reduce_max(bucket_counts)\n    \n    return max_count\n\nvalues = tf.constant([-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0])\n\nvalues = tf.constant([0.1, -10, -0.1, 1.1, 0.41])\n",
            "\ndef bucket_indices(input_list):\n    input_tensor = tf.constant(input_list, dtype=tf.float32)\n    value_range = [-1.0, 1.0]\n    bins = tf.histogram_fixed_width_bins(input_tensor, value_range, nbins=10)\n    max_bin = tf.reduce_max(bins)\n    return max_bin\n\n",
            "\ndef bucketize_values(values):\n    boundaries = tf.constant([-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0])\n    bucket_indices = tf.raw_ops.Bucketize(input=values, boundaries=boundaries)\n    return tf.reduce_sum(bucket_indices)\n\nvalues = tf.constant([-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0])\n\nvalues = tf.constant([0.1, -10, -0.1, 1.1, 0.41])\n",
            "\ndef place_values_into_buckets(values):\n    bucket_boundaries = tf.constant([-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0])\n    indices = tf.histogram_fixed_width_bins(values, bucket_boundaries)\n    return tf.reduce_max(indices)\n\nvalues = tf.constant([-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0])\n\nvalues = tf.constant([0.1, -10, -0.1, 1.1, 0.41])\n"
        ],
        "target-program": "tf.searchsorted(in1, in2, side='left')",
        "description": "place continuous values into buckets given bucket boundaries",
        "tf_operators": {
            "tf.histogram_fixed_width_bins": 9,
            "tf.reduce_max": 6,
            "tf.int32": 3,
            "tf.float32": 4,
            "tf.constant": 9,
            "tf.unique_with_counts": 2,
            "tf.reduce_min": 1,
            "tf.range": 1,
            "tf.reduce_sum": 2,
            "tf.size": 1,
            "tf.dtypes.int32": 1,
            "tf.unique": 1,
            "tf.math.bincount": 1,
            "tf.raw_ops.Bucketize": 1
        },
        "coverage_percentage": 0.0,
        "total_in_target": 1,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_30",
        "completions": [
            "\ndef compute_euclidean_distance(tensor1, tensor2):\n    tensor1 = tf.convert_to_tensor(tensor1, dtype=tf.float32)\n    tensor2 = tf.convert_to_tensor(tensor2, dtype=tf.float32)\n    return tf.norm(tensor1-tensor2)\n\n",
            "\ndef compute_euclidean_distance(tensor1, tensor2):\n    return tf.norm(tensor1 - tensor2)\n",
            "euclidean_distance = tf.math.sqrt(tf.reduce_sum(tf.math.square(tf.subtract(tensor1, tensor2)), axis=1))",
            "\ndef euclidean_distance(tensor1, tensor2):\n    difference = tf.subtract(tensor1, tensor2)\n    square_difference = tf.square(difference)\n    sum_square_difference = tf.reduce_sum(square_difference)\n    euclidean_distance = tf.sqrt(sum_square_difference)\n    return euclidean_distance\n",
            "\ndef euclidean_distance(tensor1, tensor2):\n    difference = tf.subtract(tensor1, tensor2)\n    square_difference = tf.square(difference)\n    sum_square_difference = tf.reduce_sum(square_difference)\n    distance = tf.sqrt(sum_square_difference)\n    return distance\n",
            "\ndef euclidean_distance(tensor1, tensor2):\n    difference = tf.subtract(tensor1, tensor2)\n    return tf.norm(difference)\n",
            "\ntensor1 = tf.constant([1, 2, 3], dtype=tf.float32)\ntensor2 = tf.constant([4, 5, 6], dtype=tf.float32)\n\neuclidean_distance = tf.norm(tensor1 - tensor2)\n",
            "\ndef euclidean_distance(tensor1, tensor2):\n    difference = tf.subtract(tensor1, tensor2)\n    square_difference = tf.square(difference)\n    sum_square_difference = tf.reduce_sum(square_difference)\n    distance = tf.sqrt(sum_square_difference)\n    return distance\n",
            "\ntensor1 = tf.constant([1.2, 3.4])\ntensor2 = tf.constant([5.6, 6.8])\n\nsquared_diff = tf.square(tf.subtract(tensor1, tensor2))\n\neuclidean_distance = tf.sqrt(tf.reduce_sum(squared_diff))\n\n",
            "\na = tf.constant([1.0, 2.0, 3.0])\nb = tf.constant([4.0, 5.0, 6.0])\n\ndist = tf.norm(a-b)\n\n"
        ],
        "target-program": "tf.sqrt(tf.reduce_sum(tf.square(tf.subtract(tf.expand_dims(in1, 1), tf.expand_dims(in2, 0))), axis=2))",
        "description": "compute Euclidean distance between two tensors",
        "tf_operators": {
            "tf.norm": 5,
            "tf.convert_to_tensor": 1,
            "tf.float32": 2,
            "tf.square": 4,
            "tf.sqrt": 4,
            "tf.subtract": 5,
            "tf.reduce_sum": 4,
            "tf.constant": 3
        },
        "coverage_percentage": 80.0,
        "total_in_target": 5,
        "total_covered": 4
    },
    {
        "task_id": "stackoverflow_31",
        "completions": [
            "mse = tf.reduce_mean(tf.square(tf.sparse.to_dense(sparse_tensor) - dense_tensor))",
            "b_dense = tf.sparse.to_dense(b)\nsquared_error = tf.math.squared_difference(a, b_dense)\n",
            "total_squared_error = tf.reduce_sum(tf.square(tf.sparse.to_dense(sparse_tensor) - dense_tensor))",
            "\ntensor1 = tf.constant([1, 2, 3, 4, 5], dtype=tf.float32)\ntensor2 = tf.constant([5, 4, 3, 2, 1], dtype=tf.float32)\n\ndiff = tf.subtract(tensor1, tensor2)\n\nsquared_error = tf.square(diff)\n\n",
            "total_squared_error = tf.reduce_sum(tf.math.squared_difference(tf.sparse.to_dense(sparse_tensor), dense_tensor))",
            "squared_error = tf.square(tf.sparse.to_dense(sparse_tensor, default_value=0) - dense_tensor)\ntotal_squared_error = tf.reduce_sum(squared_error, axis=None)",
            "squared_error = tf.square(tf.sparse.to_dense(sparse_tensor) - dense_tensor)\ntotal_squared_error = tf.reduce_sum(squared_error)",
            "dense_version = tf.sparse.to_dense(sparse_tensor)\ndifference = dense_version - dense_tensor\nsquared = tf.square(difference)\ntotal_error = tf.reduce_sum(squared)",
            "dense_tensor_from_sparse = tf.sparse.to_dense(sparse_tensor)\nsquared_error = tf.math.squared_difference(dense_tensor_from_sparse, dense_tensor)\ntotal_squared_error = tf.reduce_sum(squared_error)",
            "dense_tensor_from_sparse = tf.sparse.to_dense(sparse_tensor)\nsquared_error = tf.square(dense_tensor - dense_tensor_from_sparse)\ntotal_squared_error = tf.reduce_sum(squared_error)"
        ],
        "target-program": "tf.reduce_sum(tf.square(tf.subtract(in2, tf.sparse.to_dense(in1))))",
        "description": "squared error between two tensors, one being a sparse tensor",
        "tf_operators": {
            "tf.sparse.to_dense": 1,
            "tf.math.squared_difference": 1,
            "tf.subtract": 1,
            "tf.square": 1,
            "tf.float32": 1,
            "tf.constant": 1
        },
        "coverage_percentage": 75.0,
        "total_in_target": 4,
        "total_covered": 3
    },
    {
        "task_id": "stackoverflow_32",
        "completions": [
            "\ndata = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n\ntensor = tf.constant(data)\n\nweights = tf.range(tf.shape(tensor)[1], dtype=tensor.dtype)\n\nweighted_tensor = tf.multiply(tensor, weights)\n\nresult = tf.reduce_sum(weighted_tensor)\n\n",
            "\ndata = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n\ninput_tensor = tf.constant(data)\n\nweights = tf.range(tf.shape(input_tensor)[1])\n\nweighted_tensor = tf.multiply(input_tensor, tf.cast(weights, tf.float32))\n\nresult = tf.reduce_sum(weighted_tensor)\n\n",
            "\ndata = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n\ntensor = tf.constant(data)\n\nweights = tf.range(tf.shape(tensor)[1], dtype=tensor.dtype)\n\nweighted_sum = tf.reduce_sum(tensor * weights)\n\n",
            "\ndata = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n\ndata_tensor = tf.constant(data)\n\ncolumn_indices = tf.range(tf.shape(data_tensor)[1], dtype=data_tensor.dtype)\n\nweighted_data = tf.multiply(data_tensor, column_indices)\n\nresult = tf.reduce_sum(weighted_data)\n\n",
            "\ndata = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n\nmatrix = tf.constant(data)\n\nweights = tf.range(start=0, limit=tf.shape(matrix)[1])\n\nweighted_sum = tf.reduce_sum(matrix * tf.cast(weights, tf.float32))\n\nwith tf.Session() as sess:\n    result = sess.run(weighted_sum)\n\n",
            "\ndata = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n\ninput_tensor = tf.constant(data)\n\nweights = tf.range(tf.shape(input_tensor)[1], dtype=tf.float32)\n\nweighted_sum = tf.multiply(input_tensor, weights)\n\nresult = tf.reduce_sum(weighted_sum)\n\n",
            "\ndef weighted_sum(input):\n    tensor = tf.constant(input)\n    weights = tf.range(start=0, limit=tensor.shape[1], delta=1, dtype=tf.float32)\n    weighted_tensor = tf.multiply(tensor, weights)\n    result = tf.reduce_sum(weighted_tensor)\n    return result\n\ninput = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n",
            "\ndata = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n\ninput_tensor = tf.constant(data)\n\nweights = tf.range(tf.shape(input_tensor)[1], dtype=tf.float32)\n\nweighted_tensor = tf.multiply(input_tensor, weights)\n\noutput = tf.reduce_sum(weighted_tensor)\n\n",
            "\ndata = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n\ntensor = tf.constant(data)\n\nweights = tf.range(tf.shape(tensor)[1], dtype=tf.float32)\n\nweights = tf.reshape(weights, [1, -1])\n\nweighted_tensor = tf.multiply(tensor, weights)\n\nweighted_sum = tf.reduce_sum(weighted_tensor)\n\n",
            "\ninput_array = [[0.1, 0.6, 0.2, 0.1], [0.3, 0.1, 0.4, 0.2], [0.2, 0.1, 0.2, 0.5]]\n\ninput_tensor = tf.constant(input_array)\n\nweights = tf.cast(tf.range(tf.shape(input_tensor)[1]), dtype=tf.float32)\n\nweighted_array = tf.multiply(input_tensor, weights)\n\nresult = tf.reduce_sum(weighted_array)\n\n"
        ],
        "target-program": "tf.tensordot(in1, tf.cast(tf.range(4), tf.float32), 1)",
        "description": "weighted sum across rows, where the column index is the weight",
        "tf_operators": {
            "tf.multiply": 8,
            "tf.range": 10,
            "tf.reduce_sum": 10,
            "tf.shape": 9,
            "tf.constant": 10,
            "tf.cast": 3,
            "tf.float32": 7,
            "tf.Session": 1,
            "tf.reshape": 1
        },
        "coverage_percentage": 75.0,
        "total_in_target": 4,
        "total_covered": 3
    },
    {
        "task_id": "stackoverflow_33",
        "completions": [
            "\ndef min_distance(points):\n    points = tf.constant(points)\n    pairwise_diff = tf.expand_dims(points, 1) - tf.expand_dims(points, 0)\n    pairwise_dist = tf.norm(pairwise_diff, axis=-1)\n    pairwise_dist_no_zero = tf.where(pairwise_dist > 0, pairwise_dist, float('inf'))\n    min_dist = tf.reduce_min(pairwise_dist_no_zero)\n    return min_dist.numpy()\n",
            "\ndef min_distance(points):\n    points = tf.constant(points, dtype=tf.float32)\n    points_expanded = tf.expand_dims(points, 1)\n    distances = tf.sqrt(tf.reduce_sum(tf.square(points_expanded - tf.transpose(points_expanded, perm=[1, 0, 2])), axis=2))\n    mask = tf.not_equal(distances, 0.0)\n    return tf.reduce_min(tf.boolean_mask(distances, mask))\n",
            "import numpy as np\n\ndef min_distance(points):\n    points = tf.constant(points, dtype=tf.float32)\n    pairwise_diff = points[:, None, :] - points[None, :, :]\n    pairwise_dist = tf.sqrt(tf.reduce_sum(tf.square(pairwise_diff), axis=-1))\n    mask = tf.logical_not(tf.eye(tf.shape(points)[0], dtype=tf.bool))\n    min_dist = tf.reduce_min(tf.boolean_mask(pairwise_dist, mask))\n    return min_dist\n\npoints = [[0.3, 0.1, 0.4], [0.1, 0.5, 0.9], [0.2, 0.6, 0.5], [0.3, 0.5, 0.8], [0.9, 0.7, 0.9]]\n\npoints = [[0.3, 0.2, 0.3], [0.8, 0.4, 0.6], [0.2, 0.6, 0.4], [0.3, 0.3, 0.8]]\n",
            "\ndef min_distance(points):\n    points = tf.constant(points, dtype=tf.float32)\n    points_expanded = tf.expand_dims(points, 1)\n    diff = points_expanded - points\n    dist = tf.norm(diff, axis=-1)\n    min_dist = tf.reduce_min(dist + tf.eye(tf.shape(points)[0]) * tf.reduce_max(dist))\n    return min_dist\n",
            "\ndef min_distance(points):\n    points = tf.constant(points)\n    pairwise_squared_distances = tf.reduce_sum(tf.square(points[:, None, :] - points[None, :, :]), axis=-1)\n    min_distance = tf.reduce_min(tf.linalg.band_part(pairwise_squared_distances, 0, -1) + tf.linalg.band_part(tf.ones_like(pairwise_squared_distances) * float('inf'), -1, 0))\n    return min_distance\n",
            "\ndef min_distance(points):\n    points = tf.constant(points, dtype=tf.float32)\n    expanded_a = tf.expand_dims(points, 1)\n    expanded_b = tf.expand_dims(points, 0)\n    distances = tf.sqrt(tf.reduce_sum(tf.square(tf.subtract(expanded_a, expanded_b)), -1))\n    min_distance = tf.reduce_min(distances + tf.eye(tf.shape(points)[0])*1e10)\n    return min_distance\n",
            "\ndef min_distance(points):\n    points = tf.constant(points, dtype=tf.float32)\n    pairwise_distances = tf.norm(tf.expand_dims(points, 1) - tf.expand_dims(points, 0), axis=-1)\n    pairwise_distances = tf.linalg.set_diag(pairwise_distances, tf.fill(tf.shape(points)[:1], float('inf')))\n    return tf.reduce_min(pairwise_distances).numpy()\n\n",
            "\ndef min_distance(points):\n    points = tf.constant(points, dtype=tf.float32)\n    expanded_points = tf.expand_dims(points, 1)\n    distances = tf.sqrt(tf.reduce_sum(tf.square(expanded_points - points), axis=-1))\n    distances = tf.linalg.set_diag(distances, tf.fill([len(points)], float('inf')))\n    return tf.reduce_min(distances).numpy()\n\n",
            "\ndef min_distance(points):\n    points = tf.constant(points)\n    diff = tf.expand_dims(points, 1) - tf.expand_dims(points, 0)\n    dist = tf.sqrt(tf.reduce_sum(tf.square(diff), axis=-1))\n    min_dist = tf.reduce_min(dist + tf.eye(tf.shape(points)[0])*1e10)\n    return min_dist\n",
            "\ndef min_distance(points):\n    points = tf.constant(points, dtype=tf.float32)\n    r = tf.reduce_sum(points*points, 1)\n    r = tf.reshape(r, [-1, 1])\n    D = r - 2*tf.matmul(points, tf.transpose(points)) + tf.transpose(r)\n    D = tf.sqrt(D)\n    min_distance = tf.reduce_min(D + tf.eye(tf.shape(D)[0])*1e10)\n    return min_distance\n\n"
        ],
        "target-program": "tf.reduce_min(tf.reduce_sum(tf.square(tf.subtract(tf.expand_dims(in1, 0), tf.expand_dims(in2, 1))), axis=2), axis=1)",
        "description": "find the minimum distance between two sets of points",
        "tf_operators": {
            "tf.where": 1,
            "tf.expand_dims": 7,
            "tf.reduce_min": 10,
            "tf.norm": 3,
            "tf.constant": 10,
            "tf.square": 6,
            "tf.float32": 7,
            "tf.reduce_sum": 7,
            "tf.sqrt": 6,
            "tf.boolean_mask": 2,
            "tf.transpose": 2,
            "tf.not_equal": 1,
            "tf.bool": 1,
            "tf.logical_not": 1,
            "tf.shape": 6,
            "tf.eye": 5,
            "tf.reduce_max": 1,
            "tf.linalg.band_part": 1,
            "tf.ones_like": 1,
            "tf.subtract": 1,
            "tf.linalg.set_diag": 2,
            "tf.fill": 2,
            "tf.matmul": 1,
            "tf.reshape": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 5,
        "total_covered": 5
    },
    {
        "task_id": "stackoverflow_34",
        "completions": [
            "\ndef weighted_sum_tensors(input_list):\n    # Convert the input list into a tensor\n    tensor = tf.constant(input_list)\n\n    # Create a weights tensor\n    weights = tf.range(1, len(input_list) + 1, dtype=tf.int32)\n\n    # Multiply the input tensor with the weights tensor\n    multiplied_tensor = tf.multiply(tensor, weights[:, tf.newaxis, tf.newaxis])\n\n    # Compute the weighted sum\n    weighted_sum = tf.reduce_sum(multiplied_tensor, axis=0)\n\n    return weighted_sum\n\ninput_list = [[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[10, 20], [30, 40]]]\n",
            "\ndef weighted_sum_tensors(input_tensor):\n  tensor = tf.constant(input_tensor)\n  weights = tf.range(start=1, limit=tensor.shape[0] + 1, dtype=tf.int32)\n  weighted_tensor = tf.multiply(tensor, weights[:, tf.newaxis, tf.newaxis])\n  weighted_sum = tf.reduce_sum(weighted_tensor, axis=0)\n\n  return weighted_sum.numpy().tolist()\n\n",
            "\ndef weighted_sum_tensors(input):\n    weights = tf.constant([1, 2, 3], dtype=tf.int32)\n    weights = tf.reshape(weights, [3, 1, 1])\n    output = tf.tensordot(input, weights, axes=[[0], [0]])\n    return output\n\ninput = [[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[10, 20], [30, 40]]]\n\ninput = [3, 5, 10]\n",
            "\ndef weighted_sum_tensors(tensors, weights):\n    weighted_tensors = [tf.multiply(t, w) for t, w in zip(tensors, weights)]\n    result = tf.reduce_sum(weighted_tensors, axis=0)\n    return result\n\ntensors = [tf.constant([[1, 2], [3, 4]]), tf.constant([[5, 6], [7, 8]]), tf.constant([[10, 20], [30, 40]])]\nweights = [3, 5, 10]\nresult = weighted_sum_tensors(tensors, weights)\n",
            "\ndef weighted_sum(tensors):\n    total = tf.zeros_like(tensors[0])\n    for i, tensor in enumerate(tensors):\n        total = tf.add(total, tf.multiply(i, tf.reduce_sum(tensor, axis=[0, 1])))\n    return total\n",
            "\ndef weighted_sum_tensors(input_tensor):\n    weights = tf.range(1, len(input_tensor)+1, dtype=tf.float32)\n    weighted_sum = tf.tensordot(input_tensor, weights, axes=[0, 0])\n    return tf.reduce_sum(weighted_sum, axis=-1)\n",
            "\ndef weighted_sum_tensors(tensors):\n    weights = tf.range(start=0, limit=len(tensors), dtype=tf.float32)\n    weighted_tensors = tf.map_fn(lambda x: x[0] * x[1], (tensors, weights), dtype=tf.float32)\n    result = tf.reduce_sum(weighted_tensors, axis=None)\n    return result\n\ntensors = [[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[10, 20], [30, 40]]]\n\ntensors = [3, 5, 10]\n",
            "\ndef weighted_sum_tensors(tensors):\n    tensors = tf.constant(tensors)\n    weights = tf.range(1, len(tensors) + 1)\n    weighted_tensors = tf.multiply(tensors, weights[:, None, None])\n    weighted_sum = tf.reduce_sum(weighted_tensors, axis=[0, 1, 2])\n    return weighted_sum\n\ntensors = [[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[10, 20], [30, 40]]]\n\ntensors = [3, 5, 10]\n",
            "\ndef weighted_sum_tensors(tensors, weights):\n    tensors = tf.constant(tensors, dtype=tf.float32)\n    weights = tf.constant(weights, dtype=tf.float32)\n    weighted_sum = tf.tensordot(tensors, weights, axes=0)\n    return tf.reduce_sum(weighted_sum, axis=[0, 1]).numpy().tolist()\n\ntensors = [[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[10, 20], [30, 40]]]\nweights = [3, 5, 10]\n",
            "\ndef weighted_sum_tensors(input):\n    input_tensor = tf.constant(input, dtype=tf.int32)\n    weights = tf.range(tf.size(input_tensor), dtype=tf.int32)\n    weights = tf.reshape(weights, tf.shape(input_tensor))\n    weighted_tensor = tf.multiply(input_tensor, weights)\n    return tf.reduce_sum(weighted_tensor, axis=[0, 1]).numpy().tolist()\n\n"
        ],
        "target-program": "tf.tensordot(in2, in1, 1)",
        "description": "compute a weighted sum of tensors",
        "tf_operators": {
            "tf.multiply": 6,
            "tf.newaxis": 2,
            "tf.int32": 4,
            "tf.range": 6,
            "tf.reduce_sum": 9,
            "tf.constant": 7,
            "tf.tensordot": 3,
            "tf.reshape": 2,
            "tf.zeros_like": 1,
            "tf.add": 1,
            "tf.float32": 3,
            "tf.map_fn": 1,
            "tf.size": 1,
            "tf.shape": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_35",
        "completions": [
            "\ndef interpolate_tensors(tensor1, tensor2):\n    tensor1 = tf.constant(tensor1, dtype=tf.float32)\n    tensor2 = tf.constant(tensor2, dtype=tf.float32)\n    return tf.add(tensor1, tf.multiply(tf.divide(tf.subtract(tensor2, tensor1), 10), 8))\n",
            "\ndef interpolate_tensors(tensor1, tensor2):\n    tensor1 = tf.constant(tensor1, dtype=tf.float32)\n    tensor2 = tf.constant(tensor2, dtype=tf.float32)\n    return tf.add(tensor1, tf.multiply(tf.subtract(tensor2, tensor1), 0.2))\n",
            "\ndef interpolate_tensors(tensor1, tensor2):\n    t = 0.1\n    return tf.add(tensor1, tf.multiply(tf.subtract(tensor2, tensor1), t))\n\ntensor1 = tf.constant([[[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]], [[10.0, 20.0], [30.0, 40.0], [50.0, 60.0]]])\ntensor2 = tf.constant([[[9.0, 8.0], [7.0, 6.0], [5.0, 4.0]], [[90.0, 80.0], [70.0, 60.0], [50.0, 40.0]]])\n\noutput = interpolate_tensors(tensor1, tensor2)\n",
            "\ndef interpolate_tensors(tensor1, tensor2):\n    tensor1 = tf.constant(tensor1, dtype=tf.float32)\n    tensor2 = tf.constant(tensor2, dtype=tf.float32)\n    return tf.add(tensor1, tf.divide(tf.subtract(tensor2, tensor1), tf.constant(2.0, dtype=tf.float32)))\n\ntensor1 = [[[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]], [[10.0, 20.0], [30.0, 40.0], [50.0, 60.0]]]\ntensor2 = [[[9.0, 8.0], [7.0, 6.0], [5.0, 4.0]], [[90.0, 80.0], [70.0, 60.0], [50.0, 40.0]]]\n",
            "\ndef interpolate_tensors(a, b, t=0.8):\n    a = tf.constant(a, dtype=tf.float32)\n    b = tf.constant(b, dtype=tf.float32)\n    return tf.add(tf.multiply(1.0 - t, a), tf.multiply(t, b))\n",
            "\ndef linear_interpolation(tensor1, tensor2, t=0.1):\n    tensor1 = tf.constant(tensor1, dtype=tf.float32)\n    tensor2 = tf.constant(tensor2, dtype=tf.float32)\n    result = (1 - t) * tensor1 + t * tensor2\n    return result\n",
            "\ndef interpolate_tensors(tensor1, tensor2):\n    sum_tensors = tf.add(tensor1, tensor2)\n    interpolated_tensor = tf.divide(sum_tensors, 2.0)\n    return interpolated_tensor\n\ntensor1 = tf.constant([[[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]], [[10.0, 20.0], [30.0, 40.0], [50.0, 60.0]]])\ntensor2 = tf.constant([[[9.0, 8.0], [7.0, 6.0], [5.0, 4.0]], [[90.0, 80.0], [70.0, 60.0], [50.0, 40.0]]])\ninterpolated_tensor = interpolate_tensors(tensor1, tensor2)\n",
            "\ndef interpolate_tensors(tensor1, tensor2):\n    tensor1 = tf.constant(tensor1, dtype=tf.float32)\n    tensor2 = tf.constant(tensor2, dtype=tf.float32)\n\n    x = tf.divide(tf.add(tensor1, tensor2), 2.0)\n    y1 = tensor1\n    y2 = tensor2\n\n    interpolation = tf.add(y1, tf.multiply(tf.divide(tf.subtract(y2, y1), tf.subtract(tensor2, tensor1)), tf.subtract(x, tensor1)))\n    return interpolation.numpy()\n",
            "\ndef linear_interpolation(tensors):\n    tensor1, tensor2 = tensors\n    tensor1 = tf.constant(tensor1)\n    tensor2 = tf.constant(tensor2)\n    return tf.divide(tf.add(tensor1, tensor2), 2.0)\n",
            "\ndef interpolate_tensors(tensor1, tensor2, alpha=0.8):\n    tensor1 = tf.constant(tensor1, dtype=tf.float32)\n    tensor2 = tf.constant(tensor2, dtype=tf.float32)\n\n    result = tf.add(tf.multiply(tensor1, 1 - alpha), tf.multiply(tensor2, alpha))\n    return result.numpy().tolist()\n\n"
        ],
        "target-program": "tf.add(in2, tf.multiply(tf.expand_dims(in3, 1), tf.subtract(in1, in2)))",
        "description": "linear interpolation between two tensors",
        "tf_operators": {
            "tf.multiply": 6,
            "tf.divide": 5,
            "tf.subtract": 5,
            "tf.float32": 7,
            "tf.add": 9,
            "tf.constant": 10
        },
        "coverage_percentage": 75.0,
        "total_in_target": 4,
        "total_covered": 3
    },
    {
        "task_id": "stackoverflow_36",
        "completions": [
            "\nx = tf.constant([1, 0, 1, 1, 0, 1, 0, 1])\n\nindices = tf.range(tf.size(x)) + 1\n\nindices = tf.cast(indices, tf.float32)\n\nresult = tf.divide(x, indices)\n\n",
            "\nx = tf.constant([1, 0, 1, 1, 0, 1, 0, 1], dtype=tf.float32)\n\nindices = tf.range(start=1, limit=tf.size(x) + 1, dtype=tf.float32)\n\nresult = tf.math.divide_no_nan(x, indices)\n\n",
            "\ninput_data = tf.constant([1, 0, 1, 1, 0, 1, 0, 1])\n\nreshaped_data = tf.reshape(input_data, (2, 4))\n\ncol_indices = tf.range(reshaped_data.shape[1], dtype=tf.float32)\n\noutput = tf.math.divide_no_nan(reshaped_data, col_indices)\n\n",
            "\ndef divide_by_col_index(input_data):\n    # Reshape input data into a 2D Tensor\n    input_tensor = tf.reshape(input_data, shape=(-1, 2))\n    # Create a Tensor that represents the column indices\n    col_indices = tf.add(tf.range(start=1, limit=input_tensor.shape[1]+1), 1)\n    # Divide each element of the input Tensor by the corresponding element in the column index Tensor\n    output_tensor = tf.divide(input_tensor, col_indices)\n    return output_tensor\n\ninput_data = tf.constant([1, 0, 1, 1, 0, 1, 0, 1])\n",
            "\narr = tf.constant([1, 0, 1, 1, 0, 1, 0, 1])\n\narr_reshaped = tf.reshape(arr, (-1,1))\n\nindices = tf.range(tf.shape(arr_reshaped)[1], dtype=tf.float32)\n\noutput = tf.math.divide_no_nan(arr_reshaped, indices)\n\noutput\n",
            "\ndef divide_by_column_index(input):\n    # Reshape the input into a 2D array\n    input_2d = tf.reshape(input, [1, -1])\n    \n    # Get the number of columns\n    num_columns = tf.shape(input_2d)[1]\n    \n    # Create a 2D array of column indices\n    column_indices = tf.broadcast_to(tf.range(num_columns), tf.shape(input_2d))\n    \n    # Convert the column indices to float for division\n    column_indices_float = tf.cast(column_indices, tf.float32)\n    \n    # Divide each element by the column index\n    output = tf.divide(input_2d, column_indices_float)\n    \n    # Replace NaN with 0\n    output = tf.where(tf.is_nan(output), 0., output)\n    \n    return output\n\ninput = tf.constant([1, 0, 1, 1, 0, 1, 0, 1])\noutput = divide_by_column_index(input)\n",
            "\ndef divide_by_col_index(input):\n    input = tf.reshape(input, shape=(-1, 2))\n    col_indices = tf.range(tf.shape(input)[1], dtype=input.dtype)\n    output = tf.math.divide_no_nan(input, col_indices)\n    return output\n\ninput = tf.constant([1, 0, 1, 1, 0, 1, 0, 1])\noutput = divide_by_col_index(input)\n",
            "\ninput_list = tf.constant([1, 0, 1, 1, 0, 1, 0, 1], dtype=tf.float32)\n\nlist_length = tf.size(input_list)\n\nindices = tf.range(1, list_length+1, dtype=tf.float32)\n\noutput = tf.divide(input_list, indices)\n\n",
            "\ndef divide_by_col_index(input):\n    # reshape input to a matrix shape\n    reshaped_input = tf.reshape(input, [-1, len(input)])\n    \n    # create a tensor that contains the column indices\n    col_indices = tf.range(start=1, limit=len(input)+1, delta=1, dtype=tf.float32)\n    \n    # broadcast col_indices to match the shape of reshaped_input\n    broadcasted_col_indices = tf.broadcast_to(col_indices, tf.shape(reshaped_input))\n    \n    # divide reshaped_input by broadcasted_col_indices\n    output = tf.divide(reshaped_input, broadcasted_col_indices)\n    \n    return output\n",
            "\nlst = [1, 0, 1, 1, 0, 1, 0, 1]\n\ntensor = tf.constant(lst, dtype=tf.float32)\n\nindices = tf.range(start=1, limit=len(lst)+1, delta=1, dtype=tf.float32)\n\nresult = tf.divide(tensor, indices)\n\n"
        ],
        "target-program": "tf.cast(tf.divide(in1, tf.add(in1, tf.range(8))), tf.float32)",
        "description": "divide each element by the column index",
        "tf_operators": {
            "tf.divide": 6,
            "tf.cast": 2,
            "tf.range": 10,
            "tf.size": 3,
            "tf.float32": 8,
            "tf.constant": 9,
            "tf.math.divide_no_nan": 4,
            "tf.reshape": 6,
            "tf.add": 1,
            "tf.shape": 4,
            "tf.where": 1,
            "tf.is_nan": 1,
            "tf.broadcast_to": 2
        },
        "coverage_percentage": 100.0,
        "total_in_target": 5,
        "total_covered": 5
    },
    {
        "task_id": "stackoverflow_37",
        "completions": [
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([1.0, 0.5, 1.0])\n\ndot_product = tf.tensordot(tensor, vector, axes=[-1, 0])\n\n",
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\n\nvector = tf.constant([1.0, 1.5, 2.0])\n\noutput = tf.tensordot(tensor, vector, axes=1)\n\n",
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([1.0, 0.5, 2.0])\n\noutput = tf.tensordot(tensor, vector, axes=1)\n\n",
            "\ndef dot_product(tensor, vector):\n    return tf.tensordot(tensor, vector, axes=1)\n\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([1.0, 0.5, 0.0])\nresult = dot_product(tensor, vector)\n",
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([1.0, 0.5, 0.0])\n\nresult = tf.tensordot(tensor, vector, axes=[[-1], [0]])\n\n",
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([1.0, 0.5, 1.0])\n\noutput = tf.tensordot(tensor, vector, axes=1)\n\n",
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([1.0, 0.5, 1.0])\n\nresult = tf.tensordot(tensor, vector, axes=1)\n\n",
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([1.0, 0.5, 1.0])\n\nresult = tf.tensordot(tensor, vector, axes=1)\n\n",
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([1.0, 0.5, 0.0])\n\nresult = tf.tensordot(tensor, vector, axes=[[3],[0]])\n\n",
            "\ntensor = tf.constant([[[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], [[1.2, 3.4, 5.6], [7.8, 9.8, 7.6]]]])\nvector = tf.constant([1.0, 0.5, 0.0])\n\ndot_product = tf.tensordot(tensor, vector, axes=1)\n\n"
        ],
        "target-program": "tf.tensordot(in1, in2, 1)",
        "description": "dot product a vector with last dimension of a tensor",
        "tf_operators": {
            "tf.tensordot": 10,
            "tf.constant": 10
        },
        "coverage_percentage": 100.0,
        "total_in_target": 1,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_38",
        "completions": [
            "\ndef product_of_marked_elements(values, mask):\n    values_tensor = tf.constant(values)\n    mask_tensor = tf.constant(mask)\n    marked_elements = tf.boolean_mask(values_tensor, mask_tensor)\n    return tf.reduce_prod(marked_elements).numpy()\n\nvalues = [9, 2, 5, 3, 7, 4]\nmask = [0, 0, 1, 0, 1, 0]\n\nvalues = [[9, 2, 5, 3, 7, 4], [1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12]]\nmask = [[0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1]]\n",
            "\ntensor1 = tf.constant([9, 2, 5, 3, 7, 4])\ntensor2 = tf.constant([0, 0, 1, 0, 1, 0])\n\nmarked_elements = tf.boolean_mask(tensor1, tf.cast(tensor2, tf.bool))\n\nproduct = tf.reduce_prod(marked_elements)\n\n",
            "\ndef product_of_marked_elements(input_data, mask):\n    tensor_data = tf.constant(input_data, dtype=tf.float32)\n    tensor_mask = tf.constant(mask, dtype=tf.bool)\n    marked_elements = tf.boolean_mask(tensor_data, tensor_mask)\n    product = tf.reduce_prod(marked_elements)\n    return product\n\ninput_data = [9, 2, 5, 3, 7, 4]\nmask = [0, 0, 1, 0, 1, 0]\n\ninput_data = [[0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1]]\nmask = [[0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1]]\n",
            "\ndef product_of_marked_elements(data):\n    # Create a boolean mask for the data\n    mask = tf.not_equal(data, 0)\n    # Apply the mask to the data\n    marked_elements = tf.boolean_mask(data, mask)\n    # Compute the product of the marked elements\n    product = tf.reduce_prod(marked_elements)\n    return product\n",
            "\ndef compute_product(input_data, mask):\n    masked_data = tf.boolean_mask(input_data, mask)\n    product = tf.reduce_prod(masked_data)\n    return product\n\ninput_data = tf.constant([9, 2, 5, 3, 7, 4])\nmask = tf.constant([0, 0, 1, 0, 1, 0])\n\ninput_data = tf.constant([[0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1]])\nmask = tf.constant([[0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1]])\n",
            "\ndef compute_product(data, mask):\n    data_tensor = tf.constant(data)\n    mask_tensor = tf.constant(mask)\n    masked_tensor = tf.boolean_mask(data_tensor, mask_tensor)\n    return tf.reduce_prod(masked_tensor)\n\ndata = [9, 2, 5, 3, 7, 4]\nmask = [0, 0, 1, 0, 1, 0]\n\ndata = [[0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1]]\nmask = [1, 1, 1, 1, 1, 1]\n",
            "\ndef compute_product(elements):\n    # Create a boolean mask where the condition is true\n    mask = tf.not_equal(elements, 0)\n    \n    # Select the marked elements\n    marked_elements = tf.boolean_mask(elements, mask)\n    \n    # Compute the product of the marked elements\n    product = tf.reduce_prod(marked_elements)\n    \n    return product\n",
            "\ndef compute_product(nums, mask):\n    # Convert the lists to Tensorflow tensors\n    nums_tensor = tf.constant(nums, dtype=tf.int32)\n    mask_tensor = tf.constant(mask, dtype=tf.bool)\n\n    # Select the elements from the integer tensor that correspond to the 1's in the binary tensor\n    selected_elements = tf.boolean_mask(nums_tensor, mask_tensor)\n\n    # Compute the product of the selected elements\n    product = tf.reduce_prod(selected_elements)\n\n    return product\n",
            "\ndef compute_product(input_list, mask):\n    tf_input_list = tf.constant(input_list, dtype=tf.int32)\n    tf_mask = tf.constant(mask, dtype=tf.bool)\n    masked_input = tf.boolean_mask(tf_input_list, tf_mask)\n    product = tf.reduce_prod(masked_input)\n    return product\n\ninput_list = [9, 2, 5, 3, 7, 4]\nmask = [0, 0, 1, 0, 1, 0]\n\ninput_list = [[0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1]]\nmask = [[0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1]]\n",
            "\ndef compute_product(input_array, mask):\n    selected_elements = tf.boolean_mask(input_array, mask)\n    product = tf.reduce_prod(selected_elements)\n    return product\n\ninput_array = tf.constant([9, 2, 5, 3, 7, 4])\nmask = tf.constant([0, 0, 1, 0, 1, 0])\n\ninput_array = tf.constant([[0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1]])\nmask = tf.constant([[0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1]])\n"
        ],
        "target-program": "tf.reduce_prod(tf.maximum(tf.reduce_max(in2), tf.multiply(in1, in2)), axis=1)",
        "description": "compute the product of marked elements",
        "tf_operators": {
            "tf.reduce_prod": 10,
            "tf.boolean_mask": 10,
            "tf.constant": 8,
            "tf.bool": 4,
            "tf.cast": 1,
            "tf.float32": 1,
            "tf.not_equal": 2,
            "tf.int32": 2
        },
        "coverage_percentage": 25.0,
        "total_in_target": 4,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_39",
        "completions": [
            "\nx = tf.constant([[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]])\n\nabs_x = tf.abs(x)\n\nmask = tf.greater(abs_x, 1.0)\n\nresult = tf.where(mask, tf.square(x), 0.0)\n\n",
            "\ndata = [[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]]\n\ntensor = tf.constant(data)\n\nabs_values = tf.abs(tensor)\n\nmask_ge1 = tf.greater_equal(abs_values, 1.0)\n\nsquared_elements = tf.square(tf.boolean_mask(tensor, mask_ge1))\n\nmask_lt1 = tf.less(abs_values, 1.0)\n\nzeroed_elements = tf.where(mask_lt1, 0.0, tensor)\n\noutput = tf.add(squared_elements, zeroed_elements)\n\n",
            "\ndef process_tensor(tensor):\n    abs_tensor = tf.abs(tensor)\n    mask_less_than_1 = tf.less(abs_tensor, 1)\n    tensor_0 = tf.where(mask_less_than_1, tf.zeros_like(tensor), tensor)\n    \n    mask_greater_equal_1 = tf.greater_equal(abs_tensor, 1)\n    tensor_squared = tf.where(mask_greater_equal_1, tf.square(tensor), tensor)\n    \n    output_tensor = tf.add(tensor_0, tensor_squared)\n    return output_tensor\n\ninput_tensor = tf.constant([[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]])\noutput_tensor = process_tensor(input_tensor)\n",
            "\ndef process_elements(input):\n  input = tf.constant(input)\n  mask = tf.greater(tf.abs(input), 1)\n  input = tf.where(mask, input, 0)\n  output = tf.square(input)\n  return output.numpy()\n\ninput = [[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]]\n",
            "\nx = tf.constant([[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]])\n\nmask = tf.less(tf.abs(x), 1)\n\nresult = tf.where(mask, 0, tf.square(x))\n",
            "\ndata = [[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]]\n\ntensor = tf.constant(data)\n\nmask = tf.greater_equal(tf.abs(tensor), 1)\n\nsquared_elements = tf.square(tf.boolean_mask(tensor, mask))\n\nresult = tf.where(mask, squared_elements, 0)\n\n",
            "\ndef process_tensor(input_list):\n    tensor = tf.constant(input_list, dtype=tf.float32)\n    result = tf.where(tf.abs(tensor) < 1, 0, tf.square(tensor))\n    return result\n\ninput_list = [[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]]\n",
            "\ninput_list = [[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]]\n\ninput_tensor = tf.constant(input_list)\n\nmask = tf.less(tf.abs(input_tensor), 1.0)\n\noutput_tensor = tf.where(mask, 0.0, tf.square(input_tensor))\n\n",
            "\ninput_list = [[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]]\n\ninput_tensor = tf.constant(input_list)\n\nabs_tensor = tf.abs(input_tensor)\n\nmask = tf.greater_equal(abs_tensor, 1)\n\nsquared_elements = tf.square(tf.boolean_mask(input_tensor, mask))\n\noutput_tensor = tf.where(mask, squared_elements, 0)\n\n",
            "\ndef process_elements(input):\n    input_tensor = tf.constant(input, dtype=tf.float32)\n    mask = tf.greater(tf.abs(input_tensor), 1)\n    output_tensor = tf.where(mask, tf.square(input_tensor), 0)\n    return output_tensor.numpy()\n\ninput = [[-1.5, 1.0, 0.9, 2.0], [1.1, 0.0, -0.1, -0.9], [-1.0, 0.1, -1.1, 2.5]]\n"
        ],
        "target-program": "tf.multiply(tf.square(in1), tf.cast(tf.cast(tf.cast(in1, tf.int32), tf.bool), tf.float32))",
        "description": "(\\'set to 0 the elements with absolute value less than 1, and square the other elements\\')",
        "tf_operators": {
            "tf.where": 10,
            "tf.square": 10,
            "tf.abs": 10,
            "tf.greater": 3,
            "tf.constant": 10,
            "tf.greater_equal": 4,
            "tf.boolean_mask": 3,
            "tf.add": 2,
            "tf.less": 4,
            "tf.zeros_like": 1,
            "tf.float32": 2
        },
        "coverage_percentage": 33.33333333333333,
        "total_in_target": 6,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_40",
        "completions": [
            "\ndef top_k_to_sparse_tensor(input_tensor):\n    top_k_values, top_k_indices = tf.nn.top_k(input_tensor, k=1)\n    sparse_tensor = tf.sparse.SparseTensor(indices=top_k_indices, values=top_k_values, dense_shape=tf.shape(input_tensor))\n    dense_tensor = tf.sparse.to_dense(sparse_tensor, default_value=0)\n    return dense_tensor\n",
            "\ninput_list = tf.constant([4, 5, 2, 7, 8, 6])\n\nvalues, indices = tf.nn.top_k(input_list, k=5)\n\nsparse_tensor = tf.SparseTensor(indices=tf.expand_dims(indices, 1), values=tf.cast(values, tf.float32), dense_shape=input_list.shape)\n\ndense_tensor = tf.sparse.to_dense(sparse_tensor, validate_indices=False)\n\n",
            "\ndef top_k_to_sparse_tensor(input, k):\n    # Get top k values and their indices\n    values, indices = tf.nn.top_k(input, k)\n\n    # Create a sparse tensor with the indices of the top k elements marked with their values\n    sparse_tensor = tf.SparseTensor(indices=tf.expand_dims(indices, axis=1), \n                                    values=tf.cast(values, tf.float32), \n                                    dense_shape=[tf.size(input)])\n\n    # Convert the sparse tensor to a dense tensor\n    dense_tensor = tf.sparse.to_dense(sparse_tensor, validate_indices=False)\n\n    return dense_tensor\n\ninput = tf.constant([4, 5, 2, 7, 8, 6])\noutput = top_k_to_sparse_tensor(input, 2)\n",
            "\ndef create_sparse_tensor(input):\n    values, _ = tf.nn.top_k(input, k=5)\n    indices = tf.range(tf.shape(input)[0])\n    dense_shape = tf.shape(input)\n    sparse_tensor = tf.SparseTensor(indices=indices[:, tf.newaxis], values=values, dense_shape=dense_shape)\n    return sparse_tensor\n",
            "\ndef top_k_to_sparse_tensor(input, k):\n    top_k_values, top_k_indices = tf.nn.top_k(input, k)\n    sparse_tensor = tf.SparseTensor(top_k_indices, top_k_values, tf.shape(input))\n    return sparse_tensor\n",
            "\ndef top_k_to_sparse_tensor(input, k):\n    values, indices = tf.nn.top_k(input, k)\n    sparse_tensor = tf.SparseTensor(indices, values, tf.shape(input, out_type=tf.int64))\n    return tf.sparse.to_dense(sparse_tensor, validate_indices=False)\n",
            "\ndef top_k_to_sparse_tensor(input_tensor):\n    # Get the top k values and their indices\n    values, indices = tf.nn.top_k(input_tensor, k=tf.size(input_tensor))\n\n    # Create a sparse tensor from the indices and values\n    sparse_tensor = tf.SparseTensor(indices=tf.expand_dims(indices, axis=-1), \n                                    values=values, \n                                    dense_shape=tf.shape(input_tensor))\n    \n    return sparse_tensor\n",
            "\ndef top_k_to_sparse_tensor(input, k):\n    # Find top k values and their indices\n    values, indices = tf.nn.top_k(input, k)\n\n    # Create SparseTensor using the indices of the top k values\n    sparse_tensor = tf.SparseTensor(indices=tf.expand_dims(indices, -1), \n                                    values=values, \n                                    dense_shape=tf.shape(input, out_type=tf.int64))\n\n    # Convert SparseTensor to dense for output\n    output = tf.sparse.to_dense(sparse_tensor, validate_indices=False)\n    \n    return output\n",
            "\ndef top_k_to_sparse_tensor(input, k=1):\n    # Find top k values and their indices\n    values, indices = tf.nn.top_k(input, k)\n\n    # Create a sparse tensor using the indices and values\n    sparse_tensor = tf.SparseTensor(indices, values, tf.shape(input))\n\n    # Convert the sparse tensor to a dense tensor\n    dense_tensor = tf.sparse.to_dense(sparse_tensor)\n\n    return dense_tensor\n",
            "\ndef top_k_to_sparse_tensor(input, k):\n    # Get the top k values and their indices\n    values, indices = tf.nn.top_k(input, k)\n\n    # Create a sparse tensor from the indices and values\n    sparse_tensor = tf.SparseTensor(indices, values, tf.shape(input))\n\n    # Convert the sparse tensor to a dense tensor\n    dense_tensor = tf.sparse.to_dense(sparse_tensor)\n\n    return dense_tensor\n"
        ],
        "target-program": "tf.sparse.to_dense(tf.SparseTensor(tf.cast(in2, tf.int64), in1, (3, 5)))",
        "description": "use the output of tf.nn.top_k to make a sparse tensor",
        "tf_operators": {
            "tf.shape": 8,
            "tf.sparse.to_dense": 7,
            "tf.sparse.SparseTensor": 1,
            "tf.nn.top_k": 10,
            "tf.cast": 2,
            "tf.expand_dims": 4,
            "tf.float32": 2,
            "tf.SparseTensor": 9,
            "tf.constant": 2,
            "tf.size": 2,
            "tf.newaxis": 1,
            "tf.range": 1,
            "tf.int64": 2
        },
        "coverage_percentage": 100.0,
        "total_in_target": 4,
        "total_covered": 4
    },
    {
        "task_id": "stackoverflow_41",
        "completions": [
            "\ndef remove_index_elements(input_list, index):\n    input_tensor = tf.constant(input_list)\n    mask = tf.Variable(tf.ones_like(input_tensor, dtype=tf.bool))\n    mask[index].assign(False)\n    output_tensor = tf.boolean_mask(input_tensor, mask)\n    return output_tensor.numpy().tolist()\n\n",
            "\ndef copy_elements_except_index(input_list, index):\n    tensor = tf.constant(input_list)\n    indices = [i for i in range(len(input_list)) if i != index]\n    result = tf.gather(tensor, indices)\n    return result\n\ninput_list = [5, 2, 8, 2, 4, 1, 1, 0, 2, 1]\nindex = 3\n",
            "def get_element(lst, index):\n    return lst[index]\n",
            "\ndef remove_element(lst, index):\n    tensor = tf.constant(lst)\n    first_part = tensor[:index]\n    second_part = tensor[index+1:]\n    result = tf.concat([first_part, second_part], 0)\n    return result\n\n",
            "\ndef remove_element(tensor, index):\n    mask = tf.sequence_mask([index], tf.size(tensor))\n    mask = tf.concat([mask[0], tf.fill([tf.size(tensor) - index - 1], True)], 0)\n    return tf.boolean_mask(tensor, mask)\n\ntensor = tf.constant([5, 2, 8, 2, 4, 1, 1, 0, 2, 1])\nindex = 3\n",
            "\ndef copy_except_index(lst, index):\n    indices = tf.range(len(lst))\n    mask = tf.not_equal(indices, index)\n    return tf.boolean_mask(lst, mask)\n\nlst = tf.constant([5, 2, 8, 2, 4, 1, 1, 0, 2, 1])\nindex = tf.constant(3)\n\n",
            "\nlist_elements = tf.constant([5, 2, 8, 2, 4, 1, 1, 0, 2, 1])\n\nindex = tf.constant(3)\n\nelement = tf.gather(list_elements, index)\n\n",
            "\ndef remove_element_at_index(lst, index):\n    # Convert list to tensor\n    tensor = tf.constant(lst)\n    \n    # Get slices before and after the index\n    slice_before = tf.slice(tensor, [0], [index])\n    slice_after = tf.slice(tensor, [index+1], [tf.size(tensor) - index - 1])\n\n    # Concatenate slices\n    result = tf.concat([slice_before, slice_after], 0)\n    \n    return result\n\nlst = [5, 2, 8, 2, 4, 1, 1, 0, 2, 1]\nindex = 3\n",
            "\ndef copy_except_index(input_list, index):\n    all_indices = tf.range(len(input_list))\n    mask = tf.not_equal(all_indices, index)\n    indices = tf.boolean_mask(all_indices, mask)\n    output = tf.gather(input_list, indices)\n    return output\n\ninput_list = tf.constant([5, 2, 8, 2, 4, 1, 1, 0, 2, 1])\nindex = tf.constant(3)\n",
            "\ndef copy_except_index(input_list, index):\n    mask = [True]*len(input_list)\n    mask[index] = False\n    result = tf.boolean_mask(input_list, mask)\n    return result\n\ninput_list = [5, 2, 8, 2, 4, 1, 1, 0, 2, 1]\nindex = 3\n"
        ],
        "target-program": "tf.boolean_mask(in1, tf.not_equal(tf.constant(in2), tf.range(10)))",
        "description": "copy all elements except at the given index",
        "tf_operators": {
            "tf.bool": 1,
            "tf.Variable": 1,
            "tf.boolean_mask": 5,
            "tf.ones_like": 1,
            "tf.constant": 8,
            "tf.gather": 3,
            "tf.concat": 3,
            "tf.sequence_mask": 1,
            "tf.fill": 1,
            "tf.size": 2,
            "tf.range": 2,
            "tf.not_equal": 2,
            "tf.slice": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 4,
        "total_covered": 4
    },
    {
        "task_id": "stackoverflow_42",
        "completions": [
            "\ndef create_binary_vector(input):\n    input_tensor = tf.constant(input)\n    max_index = tf.argmax(input_tensor)\n    binary_vector = tf.one_hot(max_index, len(input))\n    return binary_vector.numpy()\n",
            "\nlist_input = [4, 6, 2, 6, 7, 3, -3]\n\ntensor_input = tf.constant(list_input)\n\nmax_index = tf.argmax(tensor_input)\n\nbinary_vector = tf.one_hot(max_index, depth=len(list_input))\n\n",
            "\ndef max_one_hot_vector(input):\n    max_position = tf.argmax(input)\n    binary_vector = tf.one_hot(max_position, len(input))\n    return binary_vector\n\ninput = [4, 6, 2, 6, 7, 3, -3]\n",
            "\ndef create_binary_vector(input_list):\n    tensor = tf.constant(input_list)\n    max_index = tf.argmax(tensor)\n    binary_vector = tf.one_hot(max_index, len(input_list))\n    return binary_vector\n\ninput_list = [4, 6, 2, 6, 7, 3, -3]\nbinary_vector = create_binary_vector(input_list)\n",
            "\ndef binary_vector_max(input):\n    max_index = tf.argmax(input)\n    binary_vector = tf.zeros_like(input)\n    binary_vector = tf.tensor_scatter_nd_update(binary_vector, [[max_index]], [1])\n    return binary_vector\n\ninput = tf.constant([4, 6, 2, 6, 7, 3, -3])\n",
            "\ndef create_binary_vector(input_data):\n    max_value = tf.reduce_max(input_data)\n    binary_vector = tf.cast(tf.equal(input_data, max_value), tf.int32)\n    return binary_vector\n\ninput_data = tf.constant([4, 6, 2, 6, 7, 3, -3])\n",
            "\ndef binary_vector(input):\n    input_tensor = tf.constant(input)\n    max_val = tf.reduce_max(input_tensor)\n    binary_vector = tf.cast(tf.equal(input_tensor, max_val), tf.int32)\n    return binary_vector\n\ninput = [4, 6, 2, 6, 7, 3, -3]\n",
            "\ndef create_binary_vector(input):\n    max_index = tf.argmax(input, 0)\n    binary_vector = tf.one_hot(max_index, depth=len(input))\n    return binary_vector\n\ninput = [4, 6, 2, 6, 7, 3, -3]\noutput = create_binary_vector(input)\n",
            "\ndef max_to_one_hot(input):\n    max_index = tf.argmax(input)\n    one_hot = tf.one_hot(max_index, depth=len(input))\n    return one_hot\n\ninput = [4, 6, 2, 6, 7, 3, -3]\n",
            "\nlist_tensor = tf.constant([4, 6, 2, 6, 7, 3, -3])\n\nmax_index = tf.argmax(list_tensor)\n\nbinary_vector = tf.one_hot(max_index, depth=tf.size(list_tensor))\n\n"
        ],
        "target-program": "tf.cast(tf.equal(in1, tf.reduce_max(in1)), tf.int32)",
        "description": "create a binary vector where the max element is 1",
        "tf_operators": {
            "tf.argmax": 8,
            "tf.one_hot": 7,
            "tf.constant": 7,
            "tf.zeros_like": 1,
            "tf.tensor_scatter_nd_update": 1,
            "tf.reduce_max": 2,
            "tf.cast": 2,
            "tf.int32": 2,
            "tf.equal": 2,
            "tf.size": 1
        },
        "coverage_percentage": 100.0,
        "total_in_target": 4,
        "total_covered": 4
    },
    {
        "task_id": "stackoverflow_43",
        "completions": [
            "\ntensor = tf.constant([[12, 34, 56, 78, 90, 10], [99, 88, 77, 55, 44, 33], [-1, -2, -3, -4, -5, -6]])\nindices = tf.constant([0, 1, 1, 0, 2, 0])\n\nextracted_elements = tf.gather_nd(tensor, tf.expand_dims(indices, axis=-1))\n\n",
            "\ntensor = tf.constant([[12, 34, 56, 78, 90, 10], [99, 88, 77, 55, 44, 33], [-1, -2, -3, -4, -5, -6]])\n\nindices = tf.constant([[0, 0], [1, 1], [1, 1], [0, 0], [2, 0], [0, 0]])\n\noutput = tf.gather_nd(tensor, indices)\n\n",
            "\ndef extract_elements(tensor, indices):\n    tensor = tf.constant(tensor)\n    indices = tf.constant(indices)\n    result = tf.gather(tensor, indices)\n    return result\n",
            "\ndef extract_elements(input_tensor, row_indices):\n    indices = [[row_index, 1] for row_index in row_indices]\n    return tf.gather_nd(input_tensor, indices)\n\ninput_tensor = tf.constant([[12, 34, 56, 78, 90, 10], [99, 88, 77, 55, 44, 33], [-1, -2, -3, -4, -5, -6]])\nrow_indices = [0, 1, 1, 0, 2, 0]\n\noutput = extract_elements(input_tensor, row_indices)\n",
            "\ntensor = tf.constant([[12, 34, 56, 78, 90, 10], [99, 88, 77, 55, 44, 33], [-1, -2, -3, -4, -5, -6]])\nindices = tf.constant([0, 1, 1, 0, 2, 0])\n\nresult = tf.gather(tensor, indices)\n\n",
            "\ntensor = tf.constant([[12, 34, 56, 78, 90, 10], [99, 88, 77, 55, 44, 33], [-1, -2, -3, -4, -5, -6]])\nindices = tf.constant([0, 1, 1, 0, 2, 0])\n\nextracted_elements = tf.gather_nd(tensor, tf.reshape(indices, [-1, 1]))\n\n",
            "\ntensor = tf.constant([[12, 34, 56, 78, 90, 10], [99, 88, 77, 55, 44, 33], [-1, -2, -3, -4, -5, -6]])\nindices = tf.constant([0, 1, 1, 0, 2, 0])\n\noutput = tf.gather_nd(tensor, tf.reshape(indices, [-1, 1]))\n\n",
            "\nparams = tf.constant([[12, 34, 56, 78, 90, 10], [99, 88, 77, 55, 44, 33], [-1, -2, -3, -4, -5, -6]])\n\nindices = tf.constant([[0, 0], [1, 1]])\n\noutput = tf.gather_nd(params, indices)\n\n",
            "\ndef extract_elements(tensor, indices):\n    tensor = tf.constant(tensor)\n    indices = list(zip(range(len(indices)), indices))\n    return tf.gather_nd(tensor, indices)\n\ntensor = [[12, 34, 56, 78, 90, 10], [99, 88, 77, 55, 44, 33], [-1, -2, -3, -4, -5, -6]]\nindices = [0, 1, 1, 0, 2, 0]\n",
            "\ndef extract_elements(tensor, indices):\n    tensor = tf.constant(tensor)\n    indices = tf.constant(indices)\n    rows = tf.range(tf.shape(tensor)[0])\n    indices = tf.stack([rows, indices], axis=1)\n    return tf.gather_nd(tensor, indices)\n"
        ],
        "target-program": "tf.gather_nd(tf.transpose(in1), tf.expand_dims(in2, 1), batch_dims=1)",
        "description": "extract elements of a tensor given row indices",
        "tf_operators": {
            "tf.expand_dims": 1,
            "tf.gather_nd": 8,
            "tf.constant": 10,
            "tf.gather": 2,
            "tf.reshape": 2,
            "tf.stack": 1,
            "tf.range": 1,
            "tf.shape": 1
        },
        "coverage_percentage": 66.66666666666666,
        "total_in_target": 3,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_44",
        "completions": [
            "\ndata = [[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]]\n\ndata_tensor = tf.constant(data)\n\nrow_sums = tf.reduce_sum(data_tensor, axis=1)\n\npair_sums = tf.add(row_sums[:-1], row_sums[1:])\n\n",
            "\ndata = tf.constant([[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]])\n\nreshaped_data = tf.reshape(data, (-1, 2*data.shape[1]))\n\nresult = tf.reduce_sum(reshaped_data, axis=1)\n\n",
            "\ndef sum_consecutive_rows(data):\n    data = tf.constant(data)\n    result = []\n    for i in range(0, len(data), 2):\n        sum_rows = tf.reduce_sum(data[i:i+2], axis=1)\n        result.append(sum_rows)\n    return result\n\ndata = [[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]]\n",
            "\ndata = [[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]]\n\ntensor_data = tf.constant(data)\n\nresult = []\n\nfor i in range(0, len(data), 2):\n    # calculate the sum across columns for every two rows\n    sum = tf.reduce_sum(tensor_data[i:i+2], axis=[0, 1])\n    # store the result\n    result.append(sum)\n\nresult_tensor = tf.stack(result)\n\n",
            "\ndef sum_consecutive_rows(tensor):\n    reshaped_tensor = tf.reshape(tensor, (-1, 2))\n    summed_tensor = tf.reduce_sum(reshaped_tensor, axis=1)\n    return summed_tensor\n\ntensor = tf.constant([[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]])\noutput = sum_consecutive_rows(tensor)\n",
            "\ndef sum_consecutive_rows(tensor):\n    reshaped_tensor = tf.reshape(tensor, (-1, 2, tensor.shape[1]))\n    return tf.reduce_sum(reshaped_tensor, axis=1)\n\ninput = tf.constant([[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]])\noutput = sum_consecutive_rows(input)\n",
            "\ndata = [[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]]\n\ndata_tf = tf.constant(data)\n\npair_sum = tf.add(data_tf[::2], data_tf[1::2])\n\nresult = tf.reduce_sum(pair_sum, axis=1)\n\n",
            "\ninput_tensor = tf.constant([[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]])\n\nreshaped_tensor = tf.reshape(input_tensor, [-1, input_tensor.shape[1]*2])\n\noutput = tf.reduce_sum(reshaped_tensor, axis=1)\n\n",
            "\ndef sum_consecutive_rows(input):\n    tensor = tf.constant(input)\n    indices1 = tf.range(start=0, limit=tf.shape(tensor)[0], delta=2)\n    indices2 = tf.range(start=1, limit=tf.shape(tensor)[0], delta=2)\n    rows1 = tf.gather(tensor, indices1)\n    rows2 = tf.gather(tensor, indices2)\n    sum_rows1 = tf.reduce_sum(rows1, axis=1)\n    sum_rows2 = tf.reduce_sum(rows2, axis=1)\n    return tf.add(sum_rows1, sum_rows2)\n\ninput = [[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]]\n",
            "\ndef sum_consecutive_rows(data):\n    tensor = tf.constant(data)\n    reshaped_tensor = tf.reshape(tensor, (-1, 2))\n    result = tf.reduce_sum(reshaped_tensor, axis=1)\n    return result\n\ndata = [[3, 5, 2], [6, 2, 3], [8, 7, 1], [0, -3, 5], [-4, 7, 3], [2, 1, 6], [10, 20, 30], [4, 5, 6]]\n"
        ],
        "target-program": "tf.squeeze(tf.reduce_sum(tf.reshape(in1, (-1, 2, in1.shape[1])), axis=1))",
        "description": "sum across columns for pairs of consecutive rows",
        "tf_operators": {
            "tf.reduce_sum": 10,
            "tf.add": 3,
            "tf.constant": 10,
            "tf.reshape": 5,
            "tf.stack": 1,
            "tf.range": 1,
            "tf.shape": 1,
            "tf.gather": 1
        },
        "coverage_percentage": 66.66666666666666,
        "total_in_target": 3,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_45",
        "completions": [
            "\ntensor = tf.constant([[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]])\n\nreversed_tensor = tf.reverse(tensor, axis=[0])\n\noutput = reversed_tensor.numpy().tolist()\n\n",
            "\ndata = [[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]]\n\ntensor = tf.constant(data)\n\noutput = tf.reverse(tensor, axis=[2])\n\n",
            "\ninput_tensor = tf.constant([[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]])\n\nreverse_indices = [0, 2, 4]\n\noutput_tensor = tf.tensor_scatter_nd_update(input_tensor, tf.reshape(reverse_indices, [-1, 1, 1]), tf.reverse(tf.gather_nd(input_tensor, tf.reshape(reverse_indices, [-1, 1, 1])), axis=[-1]))\n\n",
            "\ninput_tensor = tf.constant([[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]])\n\noutput_tensor = tf.reverse(input_tensor, axis=[2])\n\n",
            "\ndata = tf.constant([[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]])\n\nmask = tf.constant([True, False, True, False, True])\n\nmasked_data = tf.boolean_mask(data, mask, axis=1)\n\nreversed_data = tf.reverse(masked_data, axis=[2])\n\ninverse_mask = tf.math.logical_not(mask)\n\ninverse_masked_data = tf.boolean_mask(data, inverse_mask, axis=1)\n\noutput = tf.concat([reversed_data, inverse_masked_data], axis=1)\n\n",
            "\ntensor = tf.constant([[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]])\n\nindices = tf.constant([0, 2, 4])\n\nrows_to_reverse = tf.gather(tensor, indices, axis=1)\n\nreversed_rows = tf.reverse(rows_to_reverse, axis=[2])\n\nmask = tf.sequence_mask(indices, tensor.shape[1])\n\noutput = tf.where(mask, reversed_rows, tensor)\n\n",
            "\ndef reverse_rows(input_tensor, mask):\n    reversed_tensor = tf.reverse(input_tensor, axis=[1])\n    output = tf.where(mask, reversed_tensor, input_tensor)\n    return output\n\ninput_tensor = tf.constant([[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]])\nmask = tf.constant([[True, False, True, False, True]])\n\noutput = reverse_rows(input_tensor, mask)\n",
            "\ndata = [[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]]\n\ntensor = tf.constant(data)\n\nreversed_tensor = tf.reverse(tensor, axis=[2])\n\n",
            "\ndata = [[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]]\n\ntensor = tf.constant(data)\n\nresult = tf.reverse(tensor, [2])\n\n",
            "\ntensor = tf.constant([[[12, 34], [56, 78], [23, 54], [76, 78], [42, 24]]])\n\noutput = tf.reverse(tensor, axis=[-1])\n\n"
        ],
        "target-program": "tf.where(tf.sequence_mask(in2), x=tf.roll(in1, 1, -1), y=in1)",
        "description": "reverse the order in the marked rows",
        "tf_operators": {
            "tf.reverse": 10,
            "tf.constant": 10,
            "tf.reshape": 1,
            "tf.tensor_scatter_nd_update": 1,
            "tf.gather_nd": 1,
            "tf.concat": 1,
            "tf.boolean_mask": 1,
            "tf.math.logical_not": 1,
            "tf.sequence_mask": 1,
            "tf.where": 2,
            "tf.gather": 1
        },
        "coverage_percentage": 66.66666666666666,
        "total_in_target": 3,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_46",
        "completions": [
            "\ndef convert_lengths_to_ids(lengths):\n    return tf.repeat(tf.range(len(lengths)), lengths)\n\nlengths = tf.constant([3, 4, 1])\n",
            "\ndef segment_lengths_to_ids(lengths):\n    return tf.repeat(tf.range(len(lengths)), lengths)\n",
            "\ndef convert_lengths_to_ids(lengths):\n    indices = tf.range(len(lengths))\n    return tf.repeat(indices, lengths)\n\nlengths = tf.constant([3, 4, 1])\nids = convert_lengths_to_ids(lengths)\n",
            "\ndef segment_lengths_to_ids(lengths):\n    lengths_tensor = tf.constant(lengths)\n    indices = tf.range(tf.reduce_max(lengths_tensor) + 1)\n    return tf.repeat(indices, lengths_tensor)\n\nlengths = [3, 4, 1]\n",
            "\ndef segment_lengths_to_ids(segment_lengths):\n    segment_ids = []\n    for i, length in enumerate(segment_lengths):\n        segment_ids.append(tf.fill([length], i))\n    segment_ids = tf.concat(segment_ids, axis=0)\n    return segment_ids\n\nsegment_lengths = [3, 4, 1]\nsegment_ids = segment_lengths_to_ids(segment_lengths)\n",
            "\ndef segment_lengths_to_ids(lengths):\n    segment_ids = tf.range(len(lengths))\n    return tf.repeat(segment_ids, lengths)\n",
            "\ndef segment_lengths_to_ids(lengths):\n    return tf.repeat(tf.range(len(lengths)), lengths)\n",
            "\ndef segment_lengths_to_ids(lengths):\n    ids = tf.repeat(tf.range(len(lengths)), lengths)\n    return ids\n\nlengths = tf.constant([3, 4, 1])\nids = segment_lengths_to_ids(lengths)\n",
            "\ndef convert_lengths_to_ids(lengths):\n    ids = [tf.range(l) for l in lengths]\n    return tf.concat(ids, axis=0)\n\nlengths = [3, 4, 1]\nids = convert_lengths_to_ids(lengths)\n",
            "\ndef segment_lengths_to_ids(lengths):\n    indices = tf.range(len(lengths))\n    return tf.repeat(indices, lengths)\n"
        ],
        "target-program": "tf.cast(tf.where(tf.sequence_mask(in1))[:, 0], tf.int32)",
        "description": "convert segment lengths to segment ids",
        "tf_operators": {
            "tf.range": 9,
            "tf.constant": 4,
            "tf.repeat": 8,
            "tf.reduce_max": 1,
            "tf.fill": 1,
            "tf.concat": 2
        },
        "coverage_percentage": 0.0,
        "total_in_target": 4,
        "total_covered": 0
    },
    {
        "task_id": "stackoverflow_47",
        "completions": [
            "\ndef create_sequence_mask(input):\n    if isinstance(input[0], int):\n        return tf.sequence_mask(input, 3)\n    elif isinstance(input[0], list):\n        return [tf.math.count_nonzero(x) for x in input]\n",
            "\ndef sequence_mask(lengths, maxlen):\n    return tf.sequence_mask(lengths, maxlen)\n\n",
            "\ndef create_sequence_mask(input_list):\n    # Create a tensor from the input list\n    input_tensor = tf.constant(input_list)\n    # Create a sequence mask\n    mask = tf.sequence_mask(input_tensor, maxlen=len(input_list))\n    # Convert the mask to integers\n    mask = tf.cast(mask, tf.int32)\n    # Sum the mask along the last dimension to get the final output\n    output = tf.reduce_sum(mask, axis=-1)\n    return output.numpy().tolist()\n\n",
            "\ndef sequence_mask(lengths):\n    mask = tf.sequence_mask(lengths)\n    mask = tf.cast(mask, tf.int32)\n    return mask\n\nlengths = [3, 2, 5, 4, 1, 2]\n",
            "\nvalues = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n\nmask = tf.sequence_mask(values)\n\nmask_int = tf.cast(mask, tf.int32)\n\noutput = tf.reduce_sum(mask_int, axis=1)\n\n",
            "\ndef count_true_values(input):\n    input_tensor = tf.constant(input)\n    int_tensor = tf.cast(input_tensor, tf.int32)\n    return tf.reduce_sum(int_tensor, axis=1)\n\ninput = [[True, True, True, False, False], [True, True, False, False, False], [True, True, True, True, True], [True, True, True, True, False], [True, False, False, False, False], [True, True, False, False, False]]\n",
            "\ndef sequence_mask(values):\n  mask = tf.sequence_mask(values)\n  mask = tf.cast(mask, tf.int32)\n  sum_values = tf.reduce_sum(mask, axis=1)\n  return sum_values\n\nvalues = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n",
            "\nvalues = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\nmask = tf.sequence_mask(values, 5)\n\nvalues = [[True, True, True, False, False], [True, True, False, False, False], [True, True, True, True, True], [True, True, True, True, False], [True, False, False, False, False], [True, True, False, False, False]]\nvalues_int = tf.cast(values, tf.int32)\n",
            "\ndef sequence_mask_and_count(lengths):\n    mask = tf.sequence_mask(lengths)\n    count = tf.math.count_nonzero(mask, axis=1)\n    return count\n\nlengths = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n\nlengths = [[True, True, True, False, False], [True, True, False, False, False], [True, True, True, True, True], [True, True, True, True, False], [True, False, False, False, False], [True, True, False, False, False]]\n",
            "\ndef apply_sequence_mask(values):\n    tensor_values = tf.constant(values)\n    mask = tf.sequence_mask(tensor_values)\n    return tf.reduce_sum(tf.cast(mask, tf.int32), axis=-1)\n"
        ],
        "target-program": "tf.reshape(tf.gather(in1, tf.cumsum(tf.reshape(tf.cast(in2, tf.int32), [-1]), exclusive=True) * tf.reshape(tf.cast(in2, tf.int32), [-1])), in2.shape)",
        "description": "put given values into a sequence mask",
        "tf_operators": {
            "tf.sequence_mask": 9,
            "tf.math.count_nonzero": 2,
            "tf.cast": 7,
            "tf.int32": 7,
            "tf.reduce_sum": 5,
            "tf.constant": 3
        },
        "coverage_percentage": 40.0,
        "total_in_target": 5,
        "total_covered": 2
    },
    {
        "task_id": "stackoverflow_48",
        "completions": [
            "\ndef find_indices(lst):\n    tensor = tf.constant(lst)\n    indices = tf.where(tf.equal(tensor, 38))\n    return indices.numpy().flatten()[0]\n\n",
            "input_tensor = tf.constant([32, 53, 45, 38, 29, 89, 64, 23])\nindices_of_elements = tf.where(input_tensor > 30)",
            "\ndef find_min_index(arr):\n    tensor = tf.constant(arr)\n    min_index = tf.argmin(tensor, axis=0)\n    return min_index.numpy()\n\n",
            "\nlist = tf.constant([32, 53, 45, 38, 29, 89, 64, 23])\n\nvalue = tf.constant(38)\n\nindex = tf.where(tf.equal(list, value))[0, 0]\n\n",
            "\nlist = [32, 53, 45, 38, 29, 89, 64, 23]\n\ntensor = tf.constant(list)\n\nindices = tf.where(tf.equal(tensor, 38))\n\n",
            "\ndef find_index(array, number):\n    array = tf.constant(array)\n    indices = tf.where(tf.equal(array, number))\n    first_index = tf.gather(indices, 0)\n    return first_index.numpy()[0]\n\n",
            "\ndef find_indices(elements):\n    indices = tf.range(len(elements))\n    return indices\n",
            "\ndef find_index(lst):\n    tensor = tf.constant(lst)\n    index = tf.argmin(tensor).numpy()\n    return index\n\n",
            "\nlist = tf.constant([32, 53, 45, 38, 29, 89, 64, 23])\ntarget = 38\n\nindices = tf.where(tf.equal(list, target))\n\n",
            "\ndef find_min_index(array):\n    tensor = tf.constant(array)\n    min_index = tf.argmin(tensor).numpy()\n    return min_index\n"
        ],
        "target-program": "tf.cast(tf.argmax(tf.cast(tf.equal(in1, tf.expand_dims(in2, 1)), tf.int32), axis=1), tf.int32)",
        "description": "find the indices of all elements",
        "tf_operators": {
            "tf.where": 5,
            "tf.equal": 5,
            "tf.constant": 8,
            "tf.argmin": 3,
            "tf.gather": 1,
            "tf.range": 1
        },
        "coverage_percentage": 20.0,
        "total_in_target": 5,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_49",
        "completions": [
            "\ndef batch_multiply(tensors, scalars):\n    # Reshape the scalars to match the shape of the tensors\n    scalars_reshaped = tf.reshape(scalars, shape=(-1, 1, 1, 1))\n    # Multiply the tensors by the scalars\n    result = tf.multiply(tensors, scalars_reshaped)\n    return result\n\ntensors = tf.constant([[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]])\nscalars = tf.constant([2.0, 0.5, 1.0])\noutput = batch_multiply(tensors, scalars)\n",
            "\ntensors = tf.constant([[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]])\n\nscalars = tf.constant([2.0, 0.5, 1.0])\n\nscalars_reshaped = tf.reshape(scalars, shape=(-1, 1, 1, 1))\n\noutput = tf.multiply(tensors, scalars_reshaped)\n\n",
            "\ntensors = tf.constant([[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]])\nscalars = tf.constant([2.0, 0.5, 1.0])\n\nscalars_4d = tf.reshape(scalars, shape=(-1, 1, 1, 1))\n\nscalars_broadcasted = tf.broadcast_to(scalars_4d, tf.shape(tensors))\n\nresult = tf.multiply(tensors, scalars_broadcasted)\n\n",
            "\ntensor1 = tf.constant([[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]])\nscalar1 = tf.constant([2.0, 0.5, 1.0])\n\nresult = tf.multiply(tensor1, tf.reshape(scalar1, [-1, 1, 1, 1]))\n\n",
            "\ntensor_4D = tf.constant([[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]])\ntensor_1D = tf.constant([2.0, 0.5, 1.0])\n\ntensor_1D_broadcasted = tf.reshape(tensor_1D, (-1, 1, 1, 1))\n\nresult = tf.multiply(tensor_4D, tensor_1D_broadcasted)\n\n",
            "\ndef multiply_tensors(tensors, scalars):\n    tensors = tf.constant(tensors, dtype=tf.float32)\n    scalars = tf.constant(scalars, dtype=tf.float32)\n    return tf.multiply(tensors, scalars)\n\ntensors = [[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]]\nscalars = [2.0, 0.5, 1.0]\n",
            "\ntensors = tf.constant([[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]])\nscalars = tf.constant([2.0, 0.5, 1.0])\n\nscalars_reshaped = tf.reshape(scalars, shape=(-1, 1, 1, 1))\n\nresult = tf.multiply(tensors, scalars_reshaped)\n\n",
            "\ntensor = tf.constant([[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]])\nscalars = tf.constant([2.0, 0.5, 1.0])\n\nscalars_reshaped = tf.reshape(scalars, (-1, 1, 1, 1))\n\nresult = tf.multiply(tensor, scalars_reshaped)\n\n",
            "\ndef multiply_tensors(tensor_4d, tensor_1d):\n    tensor_1d = tf.reshape(tensor_1d, [-1, 1, 1, 1])\n    tensor_1d = tf.broadcast_to(tensor_1d, tf.shape(tensor_4d))\n    result = tf.multiply(tensor_4d, tensor_1d)\n    return result\n",
            "\ndef multiply_tensors_by_scalars(tensors, scalars):\n    result = []\n    for tensor, scalar in zip(tensors, scalars):\n        result.append(tf.multiply(tensor, scalar))\n    return result\n\ntensors = tf.constant([[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]], [[[0.8, 1.0, 0.0], [0.6, 0.4, 0.2]]], [[[0.9, 0.8, 0.7], [0.1, 0.2, 0.3]]]])\nscalars = tf.constant([2.0, 0.5, 1.0])\n"
        ],
        "target-program": "tf.transpose(tf.multiply(in2, tf.transpose(in1)))",
        "description": "multiply tensors by scalars in a batched way",
        "tf_operators": {
            "tf.multiply": 10,
            "tf.constant": 9,
            "tf.reshape": 8,
            "tf.shape": 2,
            "tf.broadcast_to": 2,
            "tf.float32": 1
        },
        "coverage_percentage": 50.0,
        "total_in_target": 2,
        "total_covered": 1
    },
    {
        "task_id": "stackoverflow_50",
        "completions": [
            "\ndef create_one_hot_vector(index, depth):\n    return tf.one_hot(index, depth)\n\n",
            "\ndef create_binary_matrix(index):\n    binary_matrix = tf.one_hot(index, 6)\n    return binary_matrix.numpy().tolist()\n\n",
            "\ndef create_binary_matrix(index):\n    return tf.one_hot(index, index+1)\n\n",
            "\ndef create_binary_matrix(index):\n    return tf.one_hot(index, depth=6)\n",
            "\ndef create_binary_matrix(column):\n    return tf.one_hot(column, 6)\n\n",
            "\nzeros = tf.zeros([6], tf.int32)\n\nresult = tf.tensor_scatter_nd_update(zeros, [[3]], [1])\n\n",
            "\nsize = 6\n\nindex = 5\n\ntensor = tf.zeros([size], dtype=tf.int32)\n\ntensor = tf.tensor_scatter_nd_update(tensor, [[index]], [1])\n\n",
            "\ndef create_binary_matrix(column):\n    return tf.one_hot(column, column + 1)\n\n",
            "\ndef set_one_at_index(index, size):\n    tensor = tf.zeros([size], dtype=tf.int32)\n    indices = [[index]]\n    updates = [1]\n    return tf.tensor_scatter_nd_update(tensor, indices, updates)\n\n",
            "\ncolumn = 5\n\nbinary_matrix = tf.one_hot(column, depth=6)\n\n"
        ],
        "target-program": "tf.cast(tf.one_hot(tf.fill((in1,), in3), in2), tf.int32)",
        "description": "create a binary matrix where a specified column is set to one",
        "tf_operators": {
            "tf.one_hot": 7,
            "tf.int32": 3,
            "tf.tensor_scatter_nd_update": 3,
            "tf.zeros": 3
        },
        "coverage_percentage": 50.0,
        "total_in_target": 4,
        "total_covered": 2
    }
]